"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[42843],{15680:(e,n,t)=>{t.d(n,{xA:()=>p,yg:()=>m});var i=t(96540);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function r(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);n&&(i=i.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,i)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?r(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,i,a=function(e,n){if(null==e)return{};var t,i,a={},r=Object.keys(e);for(i=0;i<r.length;i++)t=r[i],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(i=0;i<r.length;i++)t=r[i],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var s=i.createContext({}),g=function(e){var n=i.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):o(o({},n),e)),t},p=function(e){var n=g(e.components);return i.createElement(s.Provider,{value:n},e.children)},c="mdxType",d={inlineCode:"code",wrapper:function(e){var n=e.children;return i.createElement(i.Fragment,{},n)}},u=i.forwardRef((function(e,n){var t=e.components,a=e.mdxType,r=e.originalType,s=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),c=g(t),u=a,m=c["".concat(s,".").concat(u)]||c[u]||d[u]||r;return t?i.createElement(m,o(o({ref:n},p),{},{components:t})):i.createElement(m,o({ref:n},p))}));function m(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var r=t.length,o=new Array(r);o[0]=u;var l={};for(var s in n)hasOwnProperty.call(n,s)&&(l[s]=n[s]);l.originalType=e,l[c]="string"==typeof e?e:a,o[1]=l;for(var g=2;g<r;g++)o[g]=t[g];return i.createElement.apply(null,o)}return i.createElement.apply(null,t)}u.displayName="MDXCreateElement"},8566:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>o,default:()=>d,frontMatter:()=>r,metadata:()=>l,toc:()=>g});var i=t(58168),a=(t(96540),t(15680));const r={description:"This tutorial will explain how to properly use the camera on the XIAO ESP32S3 Sense.",title:"Camera Usage for Sense Version",keywords:["xiao esp32s3","esp32s3","camera"],image:"https://files.seeedstudio.com/wiki/seeed_logo/logo_2023.png",slug:"/xiao_esp32s3_camera_usage",last_update:{date:"04/17/2023",author:"Citric"}},o="Camera Usage in Seeed Studio XIAO ESP32S3 Sense",l={unversionedId:"Sensor/SeeedStudio_XIAO/SeeedStudio_XIAO_ESP32S3_Sense/XIAO_ESP32S3_Sense_camera",id:"Sensor/SeeedStudio_XIAO/SeeedStudio_XIAO_ESP32S3_Sense/XIAO_ESP32S3_Sense_camera",title:"Camera Usage for Sense Version",description:"This tutorial will explain how to properly use the camera on the XIAO ESP32S3 Sense.",source:"@site/docs/Sensor/SeeedStudio_XIAO/SeeedStudio_XIAO_ESP32S3_Sense/XIAO_ESP32S3_Sense_camera.md",sourceDirName:"Sensor/SeeedStudio_XIAO/SeeedStudio_XIAO_ESP32S3_Sense",slug:"/xiao_esp32s3_camera_usage",permalink:"/xiao_esp32s3_camera_usage",draft:!1,editUrl:"https://github.com/Seeed-Studio/wiki-documents/blob/docusaurus-version/docs/Sensor/SeeedStudio_XIAO/SeeedStudio_XIAO_ESP32S3_Sense/XIAO_ESP32S3_Sense_camera.md",tags:[],version:"current",lastUpdatedBy:"Citric",lastUpdatedAt:1681689600,formattedLastUpdatedAt:"Apr 17, 2023",frontMatter:{description:"This tutorial will explain how to properly use the camera on the XIAO ESP32S3 Sense.",title:"Camera Usage for Sense Version",keywords:["xiao esp32s3","esp32s3","camera"],image:"https://files.seeedstudio.com/wiki/seeed_logo/logo_2023.png",slug:"/xiao_esp32s3_camera_usage",last_update:{date:"04/17/2023",author:"Citric"}},sidebar:"ProductSidebar",previous:{title:"MicroSD card for Sense Version",permalink:"/xiao_esp32s3_sense_filesystem"},next:{title:"Miniature ChatGPT Voice Assistant based on XIAO ESP32S3 Sense",permalink:"/xiao_esp32s3_speech2chatgpt"}},s={},g=[{value:"Getting Started",id:"getting-started",level:2},{value:"Installation of antenna",id:"installation-of-antenna",level:4},{value:"Installation of expansion boards (for Sense)",id:"installation-of-expansion-boards-for-sense",level:3},{value:"Prepare the microSD card",id:"prepare-the-microsd-card",level:3},{value:"Camera slot circuit design for expansion boards",id:"camera-slot-circuit-design-for-expansion-boards",level:3},{value:"Turn on the PSRAM option",id:"turn-on-the-psram-option",level:3},{value:"Camera Library Overview",id:"camera-library-overview",level:2},{value:"Part I: esp_camera.h",id:"part-i-esp_camerah",level:3},{value:"Part II: img_converters.h",id:"part-ii-img_convertersh",level:3},{value:"Part III: app_httpd.cpp",id:"part-iii-app_httpdcpp",level:3},{value:"Taking photos with the camera",id:"taking-photos-with-the-camera",level:2},{value:"Program annotation",id:"program-annotation",level:3},{value:"Project I: Making a handheld camera",id:"project-i-making-a-handheld-camera",level:2},{value:"Preliminary Preparation",id:"preliminary-preparation",level:3},{value:"Specific operation",id:"specific-operation",level:3},{value:"Program annotation",id:"program-annotation-1",level:3},{value:"Record short videos and save to microSD card",id:"record-short-videos-and-save-to-microsd-card",level:2},{value:"Program annotation",id:"program-annotation-2",level:3},{value:"Project II: Video Streaming",id:"project-ii-video-streaming",level:2},{value:"Troubleshooting",id:"troubleshooting",level:2},{value:"Q1: When XIAO ESP32S3 Sense and Round Display are used together, do I have to cut the J3 pin? Which SD card slot can be used?",id:"q1-when-xiao-esp32s3-sense-and-round-display-are-used-together-do-i-have-to-cut-the-j3-pin-which-sd-card-slot-can-be-used",level:3},{value:"Tech Support &amp; Product Discussion",id:"tech-support--product-discussion",level:2}],p={toc:g},c="wrapper";function d(e){let{components:n,...t}=e;return(0,a.yg)(c,(0,i.A)({},p,t,{components:n,mdxType:"MDXLayout"}),(0,a.yg)("h1",{id:"camera-usage-in-seeed-studio-xiao-esp32s3-sense"},"Camera Usage in Seeed Studio XIAO ESP32S3 Sense"),(0,a.yg)("admonition",{type:"tip"},(0,a.yg)("p",{parentName:"admonition"},"The content of this tutorial is only applicable to Seeed Studio XIAO ESP32S3 Sense.")),(0,a.yg)("p",null,"In this tutorial, we will walk you through using the camera module on the XIAO ESP32S3 Sense. This tutorial is divided into the following parts, first, we will explain the camera function provided by ESP32 and its functions. Secondly, we will bring you how to use the camera in two dimensions: taking pictures and recording videos, and finally, we will create some interesting projects around taking pictures and recording videos."),(0,a.yg)("div",{class:"table-center"},(0,a.yg)("table",{align:"center"},(0,a.yg)("tr",null,(0,a.yg)("th",null,"Seeed Studio XIAO ESP32S3 Sense")),(0,a.yg)("tr",null,(0,a.yg)("td",null,(0,a.yg)("div",{style:{textAlign:"center"}},(0,a.yg)("img",{src:"https://files.seeedstudio.com/wiki/SeeedStudio-XIAO-ESP32S3/img/xiaoesp32s3sense.jpg",style:{width:250,height:"auto"}})))),(0,a.yg)("tr",null,(0,a.yg)("td",null,(0,a.yg)("div",{class:"get_one_now_container",style:{textAlign:"center"}},(0,a.yg)("a",{class:"get_one_now_item",href:"https://www.seeedstudio.com/XIAO-ESP32S3-Sense-p-5639.html"},(0,a.yg)("strong",null,(0,a.yg)("span",null,(0,a.yg)("font",{color:"FFFFFF",size:"4"}," Get One Now \ud83d\uddb1\ufe0f"))))))))),(0,a.yg)("h2",{id:"getting-started"},"Getting Started"),(0,a.yg)("p",null,"This tutorial may involve the use of microSD card, camera, antenna, etc. Please prepare the following materials and install them correctly according to your project needs."),(0,a.yg)("h4",{id:"installation-of-antenna"},"Installation of antenna"),(0,a.yg)("p",null,'On the bottom left of the front of XIAO ESP32S3, there is a separate "WiFi/BT Antenna Connector". In order to get better WiFi/Bluetooth signal, you need to take out the antenna inside the package and install it on the connector.'),(0,a.yg)("p",null,"There is a little trick to the installation of the antenna, if you press down hard on it directly, you will find it very difficult to press and your fingers will hurt! The correct way to install the antenna is to put one side of the antenna connector into the connector block first, then press down a little on the other side, and the antenna will be installed."),(0,a.yg)("div",{style:{textAlign:"center"}},(0,a.yg)("img",{src:"https://files.seeedstudio.com/wiki/SeeedStudio-XIAO-ESP32S3/img/5.gif",style:{width:500,height:"auto"}})),(0,a.yg)("h3",{id:"installation-of-expansion-boards-for-sense"},"Installation of expansion boards (for Sense)"),(0,a.yg)("p",null,'Installing the expansion board is very simple, you just need to align the connector on the expansion board with the B2B connector on the XIAO ESP32S3, press it hard and hear a "click", the installation is complete.'),(0,a.yg)("div",{style:{textAlign:"center"}},(0,a.yg)("img",{src:"https://files.seeedstudio.com/wiki/SeeedStudio-XIAO-ESP32S3/img/61.gif",style:{width:500,height:"auto"}})),(0,a.yg)("p",null,"We now have a new fully XIAO ESP32S3 Sense-compatible powerful camera, the OV5640, on our shelves, and if you purchase it, you can replace the camera to use it."),(0,a.yg)("div",{style:{textAlign:"center"}},(0,a.yg)("img",{src:"https://files.seeedstudio.com/wiki/SeeedStudio-XIAO-ESP32S3/img/ov5640.gif",style:{width:500,height:"auto"}})),(0,a.yg)("div",{class:"get_one_now_container",style:{textAlign:"center"}},(0,a.yg)("a",{class:"get_one_now_item",href:"https://www.seeedstudio.com/OV5640-Camera-for-XIAO-ESP32S3-Sense-With-Heat-Sink-p-5739.html"},(0,a.yg)("strong",null,(0,a.yg)("span",null,(0,a.yg)("font",{color:"FFFFFF",size:"4"}," Get One Now \ud83d\uddb1\ufe0f"))))),(0,a.yg)("p",null,"If you need to know the detailed parameter information of ov5640, you can refer to the following chart."),(0,a.yg)("div",{style:{textAlign:"center"}},(0,a.yg)("img",{src:"https://files.seeedstudio.com/wiki/SeeedStudio-XIAO-ESP32S3/img/datasheet.png",style:{width:1e3,height:"auto"}})),(0,a.yg)("admonition",{type:"tip"},(0,a.yg)("p",{parentName:"admonition"},"All the programs about cameras in the Wiki are compatible with both OV5640 and OV2640 cameras.")),(0,a.yg)("h3",{id:"prepare-the-microsd-card"},"Prepare the microSD card"),(0,a.yg)("p",null,"XIAO ESP32S3 Sense supports microSD cards up to ",(0,a.yg)("strong",{parentName:"p"},"32GB"),", so if you are ready to buy a microSD card for XIAO, please refer to this specification. And format the microSD card to ",(0,a.yg)("strong",{parentName:"p"},"FAT32")," format before using the microSD card."),(0,a.yg)("div",{style:{textAlign:"center"}},(0,a.yg)("img",{src:"https://files.seeedstudio.com/wiki/SeeedStudio-XIAO-ESP32S3/img/67.png",style:{width:250,height:"auto"}})),(0,a.yg)("p",null,"After formatting, you can insert the microSD card into the microSD card slot. Please note the direction of insertion, the side with the gold finger should face inward."),(0,a.yg)("div",{style:{textAlign:"center"}},(0,a.yg)("img",{src:"https://files.seeedstudio.com/wiki/SeeedStudio-XIAO-ESP32S3/img/66.jpg",style:{width:500,height:"auto"}})),(0,a.yg)("h3",{id:"camera-slot-circuit-design-for-expansion-boards"},"Camera slot circuit design for expansion boards"),(0,a.yg)("p",null,"The XIAO ESP32S3 Sense card slot occupies 14 GPIOs of the ESP32-S3, and the pin details of the occupancy are shown in the table below."),(0,a.yg)("div",{class:"table-center"},(0,a.yg)("table",{align:"center"},(0,a.yg)("tr",null,(0,a.yg)("th",{align:"center"},"ESP32-S3 GPIO"),(0,a.yg)("th",{align:"center"},"Camera"),(0,a.yg)("th",{align:"center"},"ESP32-S3 GPIO"),(0,a.yg)("th",{align:"center"},"Camera")),(0,a.yg)("tr",null,(0,a.yg)("td",{align:"center"},"GPIO10"),(0,a.yg)("td",{align:"center"},"XMCLK"),(0,a.yg)("td",{align:"center"},"GPIO11"),(0,a.yg)("td",{align:"center"},"DVP_Y8")),(0,a.yg)("tr",null,(0,a.yg)("td",{align:"center"},"GPIO12"),(0,a.yg)("td",{align:"center"},"DVP_Y7"),(0,a.yg)("td",{align:"center"},"GPIO13"),(0,a.yg)("td",{align:"center"},"DVP_PCLK")),(0,a.yg)("tr",null,(0,a.yg)("td",{align:"center"},"GPIO14"),(0,a.yg)("td",{align:"center"},"DVP_Y6"),(0,a.yg)("td",{align:"center"},"GPIO15"),(0,a.yg)("td",{align:"center"},"DVP_Y2")),(0,a.yg)("tr",null,(0,a.yg)("td",{align:"center"},"GPIO16"),(0,a.yg)("td",{align:"center"},"DVP_Y5"),(0,a.yg)("td",{align:"center"},"GPIO17"),(0,a.yg)("td",{align:"center"},"DVP_Y3")),(0,a.yg)("tr",null,(0,a.yg)("td",{align:"center"},"GPIO18"),(0,a.yg)("td",{align:"center"},"DVP_Y4"),(0,a.yg)("td",{align:"center"},"GPIO38"),(0,a.yg)("td",{align:"center"},"DVP_VSYNC")),(0,a.yg)("tr",null,(0,a.yg)("td",{align:"center"},"GPIO39"),(0,a.yg)("td",{align:"center"},"CAM_SCL"),(0,a.yg)("td",{align:"center"},"GPIO40"),(0,a.yg)("td",{align:"center"},"CAM_SDA")),(0,a.yg)("tr",null,(0,a.yg)("td",{align:"center"},"GPIO47"),(0,a.yg)("td",{align:"center"},"DVP_HREF"),(0,a.yg)("td",{align:"center"},"GPIO48"),(0,a.yg)("td",{align:"center"},"DVP_Y9")))),(0,a.yg)("h3",{id:"turn-on-the-psram-option"},"Turn on the PSRAM option"),(0,a.yg)("p",null,"The PSRAM of ESP32 refers to the external PSRAM (Pseudo Static Random Access Memory) on the ESP32 chip, which provides additional memory space to increase the available memory of the ESP32 system. In the ESP32 system, PSRAM has the following main uses:"),(0,a.yg)("ol",null,(0,a.yg)("li",{parentName:"ol"},(0,a.yg)("p",{parentName:"li"},"Extending the available RAM: The built-in RAM of ESP32 is limited, especially for some applications that need a lot of memory, such as image processing, audio processing, etc., the built-in RAM may not be enough. By using PSRAM, the available RAM of ESP32 can be extended to meet the needs of these applications.")),(0,a.yg)("li",{parentName:"ol"},(0,a.yg)("p",{parentName:"li"},"Accelerated memory access: Since PSRAM is external memory, the access speed is slower than the internal RAM, however it can be used as a cache or temporary memory to accelerate memory access and data processing.")),(0,a.yg)("li",{parentName:"ol"},(0,a.yg)("p",{parentName:"li"},"Storage buffers: For applications that require large buffers, such as network buffers, audio buffers, etc., PSRAM can provide enough storage space to avoid out-of-memory situations."))),(0,a.yg)("p",null,"For the content of this tutorial, you ",(0,a.yg)("strong",{parentName:"p"},"need to turn on the PSRAM function")," of the Arduino IDE to ensure that the camera works properly."),(0,a.yg)("div",{style:{textAlign:"center"}},(0,a.yg)("img",{src:"https://files.seeedstudio.com/wiki/SeeedStudio-XIAO-ESP32S3/img/94.png",style:{width:700,height:"auto"}})),(0,a.yg)("h2",{id:"camera-library-overview"},"Camera Library Overview"),(0,a.yg)("p",null,"Before we start, we recommend you to read this chapter to understand the common camera functions. So that you can use these functions to complete your own project development or be able to read the program more easily."),(0,a.yg)("h3",{id:"part-i-esp_camerah"},"Part I: esp_camera.h"),(0,a.yg)("ol",null,(0,a.yg)("li",{parentName:"ol"},"Configuration structure for camera initialization.")),(0,a.yg)("p",null,"The following is an example of the configuration, just fill in according to the actual pin situation."),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-cpp"},"static camera_config_t camera_example_config = {\n        .pin_pwdn       = PWDN_GPIO_NUM,\n        .pin_reset      = RESET_GPIO_NUM,\n        .pin_xclk       = XCLK_GPIO_NUM,\n        .pin_sccb_sda   = SIOD_GPIO_NUM,\n        .pin_sccb_scl   = SIOC_GPIO_NUM,\n        .pin_d7         = Y9_GPIO_NUM,\n        .pin_d6         = Y8_GPIO_NUM,\n        .pin_d5         = Y7_GPIO_NUM,\n        .pin_d4         = Y6_GPIO_NUM,\n        .pin_d3         = Y5_GPIO_NUM,\n        .pin_d2         = Y4_GPIO_NUM,\n        .pin_d1         = Y3_GPIO_NUM,\n        .pin_d0         = Y2_GPIO_NUM,\n        .pin_vsync      = VSYNC_GPIO_NUM,\n        .pin_href       = HREF_GPIO_NUM,\n        .pin_pclk       = PCLK_GPIO_NUM,\n\n        .xclk_freq_hz   = 20000000, // The clock frequency of the image sensor\n        .fb_location = CAMERA_FB_IN_PSRAM; // Set the frame buffer storage location\n        .pixel_format   = PIXFORMAT_JPEG, // The pixel format of the image: PIXFORMAT_ + YUV422|GRAYSCALE|RGB565|JPEG\n        .frame_size     = FRAMESIZE_UXGA, // The resolution size of the image: FRAMESIZE_ + QVGA|CIF|VGA|SVGA|XGA|SXGA|UXGA\n        .jpeg_quality   = 12, // The quality of the JPEG image, ranging from 0 to 63.\n        .fb_count       = 2, // The number of frame buffers to use.\n        .grab_mode      = CAMERA_GRAB_WHEN_EMPTY //  The image capture mode.\n    };\n")),(0,a.yg)("ol",{start:2},(0,a.yg)("li",{parentName:"ol"},"Initialize the camera driver.")),(0,a.yg)("p",null,"After configuring ",(0,a.yg)("inlineCode",{parentName:"p"},"camera_example_config")," in the above format, we need to use this function to initialize the camera driver."),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-cpp"},"esp_err_t esp_camera_init(const camera_config_t* config);\n")),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("p",{parentName:"li"},(0,a.yg)("strong",{parentName:"p"},"Input Parameters"),": Camera configuration parameters")),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("p",{parentName:"li"},(0,a.yg)("strong",{parentName:"p"},"Output"),": ESP_OK on success"))),(0,a.yg)("admonition",{type:"note"},(0,a.yg)("p",{parentName:"admonition"},"Currently this function can only be called once and there is no way to de-initialize this module.")),(0,a.yg)("ol",{start:3},(0,a.yg)("li",{parentName:"ol"},"Obtain pointer to a frame buffer.")),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-cpp"},"camera_fb_t* esp_camera_fb_get();\n")),(0,a.yg)("p",null,"Data structure of camera frame buffer:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-cpp"},"typedef struct {\n    uint8_t * buf;              /*!< Pointer to the pixel data */\n    size_t len;                 /*!< Length of the buffer in bytes */\n    size_t width;               /*!< Width of the buffer in pixels */\n    size_t height;              /*!< Height of the buffer in pixels */\n    pixformat_t format;         /*!< Format of the pixel data */\n    struct timeval timestamp;   /*!< Timestamp since boot of the first DMA buffer of the frame */\n} camera_fb_t;\n")),(0,a.yg)("ol",{start:4},(0,a.yg)("li",{parentName:"ol"},"Return the frame buffer to be reused again.")),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-cpp"},"void esp_camera_fb_return(camera_fb_t * fb);\n")),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"Input Parameters"),": Pointer to the frame buffer")),(0,a.yg)("ol",{start:5},(0,a.yg)("li",{parentName:"ol"},"Get a pointer to the image sensor control structure.")),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-cpp"},"sensor_t * esp_camera_sensor_get();\n")),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"Output"),": pointer to the sensor")),(0,a.yg)("ol",{start:6},(0,a.yg)("li",{parentName:"ol"},"Save camera settings to non-volatile-storage (NVS).")),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-cpp"},"esp_err_t esp_camera_save_to_nvs(const char *key);\n")),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"Input Parameters"),": A unique nvs key name for the camera settings ")),(0,a.yg)("ol",{start:7},(0,a.yg)("li",{parentName:"ol"},"Load camera settings from non-volatile-storage (NVS).")),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-cpp"},"esp_err_t esp_camera_load_from_nvs(const char *key);\n")),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"Input Parameters"),": A unique nvs key name for the camera settings ")),(0,a.yg)("h3",{id:"part-ii-img_convertersh"},"Part II: img_converters.h"),(0,a.yg)("ol",null,(0,a.yg)("li",{parentName:"ol"},"Convert image buffer to JPEG.")),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-cpp"},"bool fmt2jpg_cb(uint8_t *src, size_t src_len, uint16_t width, uint16_t height, pixformat_t format, uint8_t quality, jpg_out_cb cb, void * arg);\n")),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("p",{parentName:"li"},(0,a.yg)("strong",{parentName:"p"},"Input Parameters"),":"),(0,a.yg)("ul",{parentName:"li"},(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"src"),":       Source buffer in RGB565, RGB888, YUYV or GRAYSCALE format"),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"src_len"),":   Length in bytes of the source buffer"),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"width"),":     Width in pixels of the source image"),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"height"),":    Height in pixels of the source image"),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"format"),":    Format of the source image"),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"quality"),":   JPEG quality of the resulting image"),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"cp"),":        Callback to be called to write the bytes of the output JPEG"),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"arg"),":       Pointer to be passed to the callback"))),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("p",{parentName:"li"},(0,a.yg)("strong",{parentName:"p"},"Output"),": true on success"))),(0,a.yg)("ol",{start:2},(0,a.yg)("li",{parentName:"ol"},"Convert camera frame buffer to JPEG.")),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-cpp"},"bool frame2jpg_cb(camera_fb_t * fb, uint8_t quality, jpg_out_cb cb, void * arg);\n")),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("p",{parentName:"li"},(0,a.yg)("strong",{parentName:"p"},"Input Parameters"),":"),(0,a.yg)("ul",{parentName:"li"},(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"fb"),":       Source camera frame buffer"),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"quality"),":  JPEG quality of the resulting image"),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"cp"),":       Callback to be called to write the bytes of the output JPEG"),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"arg"),":      Pointer to be passed to the callback"))),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("p",{parentName:"li"},(0,a.yg)("strong",{parentName:"p"},"Output"),": true on success"))),(0,a.yg)("ol",{start:3},(0,a.yg)("li",{parentName:"ol"},"Convert image buffer to JPEG buffer.")),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-cpp"},"bool fmt2jpg(uint8_t *src, size_t src_len, uint16_t width, uint16_t height, pixformat_t format, uint8_t quality, uint8_t ** out, size_t * out_len);\n")),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("p",{parentName:"li"},(0,a.yg)("strong",{parentName:"p"},"Input Parameters"),":"),(0,a.yg)("ul",{parentName:"li"},(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"src"),":       Source buffer in RGB565, RGB888, YUYV or GRAYSCALE format"),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"src_len"),":   Length in bytes of the source buffer"),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"width"),":     Width in pixels of the source image"),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"height"),":    Height in pixels of the source image"),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"format"),":    Format of the source image"),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"quality"),":   JPEG quality of the resulting image"),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"out"),":       Pointer to be populated with the address of the resulting buffer. You MUST free the pointer once you are done with it."),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"out_len"),":   Pointer to be populated with the length of the output buffer"))),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("p",{parentName:"li"},(0,a.yg)("strong",{parentName:"p"},"Output"),": true on success"))),(0,a.yg)("ol",{start:4},(0,a.yg)("li",{parentName:"ol"},"Convert camera frame buffer to JPEG buffer.")),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-cpp"},"bool frame2jpg(camera_fb_t * fb, uint8_t quality, uint8_t ** out, size_t * out_len);\n")),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("p",{parentName:"li"},(0,a.yg)("strong",{parentName:"p"},"Input Parameters"),":"),(0,a.yg)("ul",{parentName:"li"},(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"fb"),":       Source camera frame buffer"),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"quality"),":  JPEG quality of the resulting image"),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"out"),":      Pointer to be populated with the address of the resulting buffer"),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"out_len"),":  Pointer to be populated with the length of the output buffer"))),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("p",{parentName:"li"},(0,a.yg)("strong",{parentName:"p"},"Output"),": true on success"))),(0,a.yg)("ol",{start:5},(0,a.yg)("li",{parentName:"ol"},"Convert image buffer to BMP buffer.")),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-cpp"},"bool fmt2bmp(uint8_t *src, size_t src_len, uint16_t width, uint16_t height, pixformat_t format, uint8_t ** out, size_t * out_len);\n")),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("p",{parentName:"li"},(0,a.yg)("strong",{parentName:"p"},"Input Parameters"),":"),(0,a.yg)("ul",{parentName:"li"},(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"src"),":       Source buffer in RGB565, RGB888, YUYV or GRAYSCALE format"),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"src_len"),":   Length in bytes of the source buffer"),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"width"),":     Width in pixels of the source image"),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"height"),":    Height in pixels of the source image"),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"format"),":    Format of the source image"),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"quality"),":   JPEG quality of the resulting image"),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"out"),":       Pointer to be populated with the address of the resulting buffer."),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"out_len"),":   Pointer to be populated with the length of the output buffer"))),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("p",{parentName:"li"},(0,a.yg)("strong",{parentName:"p"},"Output"),": true on success"))),(0,a.yg)("ol",{start:6},(0,a.yg)("li",{parentName:"ol"},"Convert camera frame buffer to BMP buffer.")),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-cpp"},"bool frame2bmp(camera_fb_t * fb, uint8_t ** out, size_t * out_len);\n")),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("p",{parentName:"li"},(0,a.yg)("strong",{parentName:"p"},"Input Parameters"),":"),(0,a.yg)("ul",{parentName:"li"},(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"fb"),":       Source camera frame buffer"),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"quality"),":  JPEG quality of the resulting image"),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"cp"),":       Callback to be called to write the bytes of the output JPEG"),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"arg"),":      Pointer to be passed to the callback"))),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("p",{parentName:"li"},(0,a.yg)("strong",{parentName:"p"},"Output"),": true on success"))),(0,a.yg)("h3",{id:"part-iii-app_httpdcpp"},"Part III: app_httpd.cpp"),(0,a.yg)("admonition",{type:"note"},(0,a.yg)("p",{parentName:"admonition"},"This part of the library introduction is based on the ",(0,a.yg)("a",{parentName:"p",href:"#project-iii-create-a-video-preservation-terminal----based-webserver"},"Create a video preservation terminal -- Based WebServer")," section. This library is mainly used to perform image acquisition and face recognition functions for the web server. It is not directly included in the onboard package of ESP.")),(0,a.yg)("ol",null,(0,a.yg)("li",{parentName:"ol"},"Face recognition function.")),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-cpp"},"static int run_face_recognition(fb_data_t *fb, std::list<dl::detect::result_t> *results)\n")),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"Input Parameters"),":",(0,a.yg)("ul",{parentName:"li"},(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"fb"),": a pointer to a struct representing a frame buffer containing image data."),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"results"),": a pointer to a list of detected face results.")))),(0,a.yg)("ol",{start:2},(0,a.yg)("li",{parentName:"ol"},"Handles HTTP requests for BMP image files.")),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-cpp"},"static esp_err_t bmp_handler(httpd_req_t *req)\n")),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"Input Parameters"),": a pointer to a struct representing the HTTP request.")),(0,a.yg)("ol",{start:3},(0,a.yg)("li",{parentName:"ol"},"Encodes JPEG image data in a streaming fashion.")),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-cpp"},"static size_t jpg_encode_stream(void *arg, size_t index, const void *data, size_t len)\n")),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"Input Parameters"),":",(0,a.yg)("ul",{parentName:"li"},(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"arg"),": a pointer to a user-defined argument that is passed to the function."),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"index"),": an index value indicating the current position within the image data."),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"data"),": a pointer to a buffer containing the image data to be encoded."),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"len"),": the length of the data buffer.")))),(0,a.yg)("ol",{start:4},(0,a.yg)("li",{parentName:"ol"},"Handles HTTP requests for capturing and streaming images from camera.")),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-cpp"},"static esp_err_t capture_handler(httpd_req_t *req)\n")),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"Input Parameters"),": a pointer to a struct representing the HTTP request.")),(0,a.yg)("ol",{start:5},(0,a.yg)("li",{parentName:"ol"},"Handles HTTP requests for streaming video from a camera.")),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-cpp"},"static esp_err_t stream_handler(httpd_req_t *req)\n")),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"Input Parameters"),": a pointer to a struct representing the HTTP request.")),(0,a.yg)("ol",{start:6},(0,a.yg)("li",{parentName:"ol"},"Initializes and starts a camera server that captures and streams video over HTTP.")),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-cpp"},"void startCameraServer()\n")),(0,a.yg)("h2",{id:"taking-photos-with-the-camera"},"Taking photos with the camera"),(0,a.yg)("p",null,"Next we start with the most basic usage of the camera, for example, we will first use the camera to complete the image acquisition. The first project we will use the microSD card, the main task of this program is to get the camera footage every minute and then save the footage to the microSD."),(0,a.yg)("p",null,"Before you start, do what I did and install the microSD card and the camera."),(0,a.yg)("div",{style:{textAlign:"center"}},(0,a.yg)("img",{src:"https://files.seeedstudio.com/wiki/SeeedStudio-XIAO-ESP32S3/img/91.jpg",style:{width:300,height:"auto"}})),(0,a.yg)("p",null,"You can find the complete program code and the required dependency files below this link."),(0,a.yg)("div",{class:"github_container",style:{textAlign:"center"}},(0,a.yg)("a",{class:"github_item",href:"https://github.com/limengdu/SeeedStudio-XIAO-ESP32S3-Sense-camera/tree/main/take_photos"},(0,a.yg)("strong",null,(0,a.yg)("span",null,(0,a.yg)("font",{color:"FFFFFF",size:"4"}," Download the Code")))," ",(0,a.yg)("svg",{"aria-hidden":"true",focusable:"false",role:"img",className:"mr-2",viewBox:"-3 10 9 1",width:16,height:16,fill:"currentColor",style:{textAlign:"center",display:"inline-block",userSelect:"none",verticalAlign:"text-bottom",overflow:"visible"}},(0,a.yg)("path",{d:"M8 0c4.42 0 8 3.58 8 8a8.013 8.013 0 0 1-5.45 7.59c-.4.08-.55-.17-.55-.38 0-.27.01-1.13.01-2.2 0-.75-.25-1.23-.54-1.48 1.78-.2 3.65-.88 3.65-3.95 0-.88-.31-1.59-.82-2.15.08-.2.36-1.02-.08-2.12 0 0-.67-.22-2.2.82-.64-.18-1.32-.27-2-.27-.68 0-1.36.09-2 .27-1.53-1.03-2.2-.82-2.2-.82-.44 1.1-.16 1.92-.08 2.12-.51.56-.82 1.28-.82 2.15 0 3.06 1.86 3.75 3.64 3.95-.23.2-.44.55-.51 1.07-.46.21-1.61.55-2.33-.66-.15-.24-.6-.83-1.23-.82-.67.01-.27.38.01.53.34.19.73.9.82 1.13.16.45.68 1.31 2.69.94 0 .67.01 1.3.01 1.49 0 .21-.15.45-.55.38A7.995 7.995 0 0 1 0 8c0-4.42 3.58-8 8-8Z"})))),(0,a.yg)("p",null,"Here is the Arduino program for this project."),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-cpp"},'#include "esp_camera.h"\n#include "FS.h"\n#include "SD.h"\n#include "SPI.h"\n\n#define CAMERA_MODEL_XIAO_ESP32S3 // Has PSRAM\n\n#include "camera_pins.h"\n\nunsigned long lastCaptureTime = 0; // Last shooting time\nint imageCount = 1;                // File Counter\nbool camera_sign = false;          // Check camera status\nbool sd_sign = false;              // Check sd status\n\n// Save pictures to SD card\nvoid photo_save(const char * fileName) {\n  // Take a photo\n  camera_fb_t *fb = esp_camera_fb_get();\n  if (!fb) {\n    Serial.println("Failed to get camera frame buffer");\n    return;\n  }\n  // Save photo to file\n  writeFile(SD, fileName, fb->buf, fb->len);\n  \n  // Release image buffer\n  esp_camera_fb_return(fb);\n\n  Serial.println("Photo saved to file");\n}\n\n// SD card write file\nvoid writeFile(fs::FS &fs, const char * path, uint8_t * data, size_t len){\n    Serial.printf("Writing file: %s\\n", path);\n\n    File file = fs.open(path, FILE_WRITE);\n    if(!file){\n        Serial.println("Failed to open file for writing");\n        return;\n    }\n    if(file.write(data, len) == len){\n        Serial.println("File written");\n    } else {\n        Serial.println("Write failed");\n    }\n    file.close();\n}\n\nvoid setup() {\n  Serial.begin(115200);\n  while(!Serial); // When the serial monitor is turned on, the program starts to execute\n\n  camera_config_t config;\n  config.ledc_channel = LEDC_CHANNEL_0;\n  config.ledc_timer = LEDC_TIMER_0;\n  config.pin_d0 = Y2_GPIO_NUM;\n  config.pin_d1 = Y3_GPIO_NUM;\n  config.pin_d2 = Y4_GPIO_NUM;\n  config.pin_d3 = Y5_GPIO_NUM;\n  config.pin_d4 = Y6_GPIO_NUM;\n  config.pin_d5 = Y7_GPIO_NUM;\n  config.pin_d6 = Y8_GPIO_NUM;\n  config.pin_d7 = Y9_GPIO_NUM;\n  config.pin_xclk = XCLK_GPIO_NUM;\n  config.pin_pclk = PCLK_GPIO_NUM;\n  config.pin_vsync = VSYNC_GPIO_NUM;\n  config.pin_href = HREF_GPIO_NUM;\n  config.pin_sscb_sda = SIOD_GPIO_NUM;\n  config.pin_sscb_scl = SIOC_GPIO_NUM;\n  config.pin_pwdn = PWDN_GPIO_NUM;\n  config.pin_reset = RESET_GPIO_NUM;\n  config.xclk_freq_hz = 20000000;\n  config.frame_size = FRAMESIZE_UXGA;\n  config.pixel_format = PIXFORMAT_JPEG; // for streaming\n  config.grab_mode = CAMERA_GRAB_WHEN_EMPTY;\n  config.fb_location = CAMERA_FB_IN_PSRAM;\n  config.jpeg_quality = 12;\n  config.fb_count = 1;\n  \n  // if PSRAM IC present, init with UXGA resolution and higher JPEG quality\n  //                      for larger pre-allocated frame buffer.\n  if(config.pixel_format == PIXFORMAT_JPEG){\n    if(psramFound()){\n      config.jpeg_quality = 10;\n      config.fb_count = 2;\n      config.grab_mode = CAMERA_GRAB_LATEST;\n    } else {\n      // Limit the frame size when PSRAM is not available\n      config.frame_size = FRAMESIZE_SVGA;\n      config.fb_location = CAMERA_FB_IN_DRAM;\n    }\n  } else {\n    // Best option for face detection/recognition\n    config.frame_size = FRAMESIZE_240X240;\n#if CONFIG_IDF_TARGET_ESP32S3\n    config.fb_count = 2;\n#endif\n  }\n\n  // camera init\n  esp_err_t err = esp_camera_init(&config);\n  if (err != ESP_OK) {\n    Serial.printf("Camera init failed with error 0x%x", err);\n    return;\n  }\n  \n  camera_sign = true; // Camera initialization check passes\n\n  // Initialize SD card\n  if(!SD.begin(21)){\n    Serial.println("Card Mount Failed");\n    return;\n  }\n  uint8_t cardType = SD.cardType();\n\n  // Determine if the type of SD card is available\n  if(cardType == CARD_NONE){\n    Serial.println("No SD card attached");\n    return;\n  }\n\n  Serial.print("SD Card Type: ");\n  if(cardType == CARD_MMC){\n    Serial.println("MMC");\n  } else if(cardType == CARD_SD){\n    Serial.println("SDSC");\n  } else if(cardType == CARD_SDHC){\n    Serial.println("SDHC");\n  } else {\n    Serial.println("UNKNOWN");\n  }\n\n  sd_sign = true; // sd initialization check passes\n\n  Serial.println("Photos will begin in one minute, please be ready.");\n}\n\nvoid loop() {\n  // Camera & SD available, start taking pictures\n  if(camera_sign && sd_sign){\n    // Get the current time\n    unsigned long now = millis();\n  \n    //If it has been more than 1 minute since the last shot, take a picture and save it to the SD card\n    if ((now - lastCaptureTime) >= 60000) {\n      char filename[32];\n      sprintf(filename, "/image%d.jpg", imageCount);\n      photo_save(filename);\n      Serial.printf("Saved picture\uff1a%s\\n", filename);\n      Serial.println("Photos will begin in one minute, please be ready.");\n      imageCount++;\n      lastCaptureTime = now;\n    }\n  }\n}\n')),(0,a.yg)("admonition",{type:"note"},(0,a.yg)("p",{parentName:"admonition"},"The compilation and upload of this program requires two other dependencies, please go to GitHub and download them in full.")),(0,a.yg)("p",null,"Please upload the program for XIAO ESP32S3, after the program is uploaded successfully, please turn on the serial monitor, adjust the camera to face the object you want to shoot, wait for one minute, the shot will be saved to the SD card. Next, XIAO will take a photo every minute."),(0,a.yg)("div",{style:{textAlign:"center"}},(0,a.yg)("img",{src:"https://files.seeedstudio.com/wiki/SeeedStudio-XIAO-ESP32S3/img/89.png",style:{width:700,height:"auto"}})),(0,a.yg)("p",null,"Remove the microSD card and with the help of the card reader, you can see the photos saved inside the card."),(0,a.yg)("h3",{id:"program-annotation"},"Program annotation"),(0,a.yg)("p",null,"The program starts with the camera and SD card libraries we need to use, and the import of some pin dependency files we defined for the XIAO ESP32S3."),(0,a.yg)("p",null,"Then for easy reading, we define two functions one after another, one is the function ",(0,a.yg)("inlineCode",{parentName:"p"},"photo_save()")," that saves the captured image to the SD card, and the other is the function ",(0,a.yg)("inlineCode",{parentName:"p"},"writeFile()")," that writes the file."),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-cpp"},'// Save pictures to SD card\nvoid photo_save(const char * fileName) {\n  // Take a photo\n  camera_fb_t *fb = esp_camera_fb_get();\n  if (!fb) {\n    Serial.println("Failed to get camera frame buffer");\n    return;\n  }\n  // Save photo to file\n  writeFile(SD, fileName, fb->buf, fb->len);\n  \n  // Release image buffer\n  esp_camera_fb_return(fb);\n\n  Serial.println("Photo saved to file");\n}\n')),(0,a.yg)("p",null,"In the function that saves the image to the microSD card, two main tasks are accomplished. The first one is the acquisition of the picture and the second one is the call to the function that writes the file."),(0,a.yg)("p",null,"Getting the image can be done with ",(0,a.yg)("inlineCode",{parentName:"p"},"esp_camera_fb_get()"),", the image information will be saved in the pointer ",(0,a.yg)("inlineCode",{parentName:"p"},"fb"),", and then we can write the ",(0,a.yg)("inlineCode",{parentName:"p"},"buf")," of ",(0,a.yg)("inlineCode",{parentName:"p"},"fb")," to the SD card."),(0,a.yg)("p",null,"In the ",(0,a.yg)("inlineCode",{parentName:"p"},"Setup()")," function, a large segment of the program is configuring the camera pins and camera initialization, we can just apply it directly by default. If you have requirements for the camera's pixels or quality, you can adjust the values inside according to the functions described in the ",(0,a.yg)("a",{parentName:"p",href:"#camera-library-overview"},"Camera Library Overview")," chapter."),(0,a.yg)("p",null,"The last thing to do in the ",(0,a.yg)("inlineCode",{parentName:"p"},"loop()")," function is to control the photos to be taken every minute and follow the incremental number as the file name suffix of the taken photos."),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-cpp"},'if(camera_sign && sd_sign){\n    // Get the current time\n    unsigned long now = millis();\n  \n    //If it has been more than 1 minute since the last shot, take a picture and save it to the SD card\n    if ((now - lastCaptureTime) >= 60000) {\n      char filename[32];\n      sprintf(filename, "/image%d.jpg", imageCount);\n      photo_save(filename);\n      Serial.printf("Saved picture\uff1a%s\\n", filename);\n      Serial.println("Photos will begin in one minute, please be ready.");\n      imageCount++;\n      lastCaptureTime = now;\n    }\n  }\n')),(0,a.yg)("p",null,"Before executing the ",(0,a.yg)("inlineCode",{parentName:"p"},"loop()"),", we configure two flag checks ",(0,a.yg)("inlineCode",{parentName:"p"},"camera_sign")," and ",(0,a.yg)("inlineCode",{parentName:"p"},"sd_sign"),". This ensures that the task of taking and saving pictures must be run after the camera and SD card checks have been successfully executed in ",(0,a.yg)("inlineCode",{parentName:"p"},"Setup()"),"."),(0,a.yg)("h2",{id:"project-i-making-a-handheld-camera"},"Project I: Making a handheld camera"),(0,a.yg)("p",null,"Next, we use the above theoretical knowledge to create a super small photo artifact. The end result of this project is that the live camera feed is displayed on the Seeed Studio Round Display for XIAO, and when you lock the object you want to photograph, touch the screen and take a picture to record on the microSD card."),(0,a.yg)("h3",{id:"preliminary-preparation"},"Preliminary Preparation"),(0,a.yg)("p",null,"Before starting this project, you will need to prepare the following hardware in advance."),(0,a.yg)("div",{class:"table-center"},(0,a.yg)("table",{align:"center"},(0,a.yg)("tr",null,(0,a.yg)("th",null,"Seeed Studio XIAO ESP32S3 Sense"),(0,a.yg)("th",null,"Seeed Studio Round Display for XIAO")),(0,a.yg)("tr",null,(0,a.yg)("td",null,(0,a.yg)("div",{style:{textAlign:"center"}},(0,a.yg)("img",{src:"https://files.seeedstudio.com/wiki/SeeedStudio-XIAO-ESP32S3/img/xiaoesp32s3sense.jpg",style:{width:250,height:"auto"}}))),(0,a.yg)("td",null,(0,a.yg)("div",{style:{textAlign:"center"}},(0,a.yg)("img",{src:"https://files.seeedstudio.com/wiki/round_display_for_xiao/rounddisplay.jpg",style:{width:250,height:"auto"}})))),(0,a.yg)("tr",null,(0,a.yg)("td",null,(0,a.yg)("div",{class:"get_one_now_container",style:{textAlign:"center"}},(0,a.yg)("a",{class:"get_one_now_item",href:"https://www.seeedstudio.com/XIAO-ESP32S3-Sense-p-5639.html"},(0,a.yg)("strong",null,(0,a.yg)("span",null,(0,a.yg)("font",{color:"FFFFFF",size:"4"}," Get One Now \ud83d\uddb1\ufe0f")))))),(0,a.yg)("td",null,(0,a.yg)("div",{class:"get_one_now_container",style:{textAlign:"center"}},(0,a.yg)("a",{class:"get_one_now_item",href:"https://www.seeedstudio.com/Seeed-Studio-Round-Display-for-XIAO-p-5638.html"},(0,a.yg)("strong",null,(0,a.yg)("span",null,(0,a.yg)("font",{color:"FFFFFF",size:"4"}," Get One Now \ud83d\uddb1\ufe0f"))))))))),(0,a.yg)("p",null,"Since this project will use Round Display for XIAO, please read the contents of the ",(0,a.yg)("strong",{parentName:"p"},(0,a.yg)("a",{parentName:"strong",href:"https://wiki.seeedstudio.com/get_start_round_display#software-preparation"},"Wiki environment configuration of the display expansion board")),", install the necessary libraries and configure the TFT environment before you run the routines of this project."),(0,a.yg)("p",null,"Since the XIAO EPS32S3 Sense is designed with three pull-up resistors R4~R6 connected to the SD card slot, and the round display also has pull-up resistors, the SD card cannot be read when both are used at the same time. To solve this problem, we need to cut off J3 on the XIAO ESP32S3 Sense expansion board."),(0,a.yg)("admonition",{type:"tip"},(0,a.yg)("p",{parentName:"admonition"},"However, ",(0,a.yg)("strong",{parentName:"p"},"we need to thank engineer Mjrovai for the new method of using the microSD card slot on the XIAO ESP32S3 Sense at the same time"),", which is also possible at software level. We can refer to ",(0,a.yg)("strong",{parentName:"p"},(0,a.yg)("a",{parentName:"strong",href:"https://github.com/Mjrovai/XIAO-ESP32S3-Sense/tree/main/camera_round_display_save_jpeg"},"his methods and procedures")),".")),(0,a.yg)("div",{style:{textAlign:"center"}},(0,a.yg)("img",{src:"https://files.seeedstudio.com/wiki/SeeedStudio-XIAO-ESP32S3/img/33.png",style:{width:500,height:"auto"}})),(0,a.yg)("p",null,"After disconnecting J3, the SD card slot on XIAO ESP32S3 Sense will not work properly, so you need to insert a microSD card into the SD card slot on the Round Display."),(0,a.yg)("p",null,"Next, please install the microSD card, XIAO ESP32S3 Sense and Round Display in order."),(0,a.yg)("div",{style:{textAlign:"center"}},(0,a.yg)("img",{src:"https://files.seeedstudio.com/wiki/SeeedStudio-XIAO-ESP32S3/img/101.gif",style:{width:500,height:"auto"}})),(0,a.yg)("admonition",{type:"tip"},(0,a.yg)("p",{parentName:"admonition"},"We recommend that you remove the camera module first to avoid scratching the camera when you cut the J3 connection with the blade.")),(0,a.yg)("h3",{id:"specific-operation"},"Specific operation"),(0,a.yg)("p",null,"You can find the complete program code and the required dependency files below this link."),(0,a.yg)("div",{class:"github_container",style:{textAlign:"center"}},(0,a.yg)("a",{class:"github_item",href:"https://github.com/limengdu/SeeedStudio-XIAO-ESP32S3-Sense-camera/tree/main/round_display_take_picture"},(0,a.yg)("strong",null,(0,a.yg)("span",null,(0,a.yg)("font",{color:"FFFFFF",size:"4"}," Download the Code")))," ",(0,a.yg)("svg",{"aria-hidden":"true",focusable:"false",role:"img",className:"mr-2",viewBox:"-3 10 9 1",width:16,height:16,fill:"currentColor",style:{textAlign:"center",display:"inline-block",userSelect:"none",verticalAlign:"text-bottom",overflow:"visible"}},(0,a.yg)("path",{d:"M8 0c4.42 0 8 3.58 8 8a8.013 8.013 0 0 1-5.45 7.59c-.4.08-.55-.17-.55-.38 0-.27.01-1.13.01-2.2 0-.75-.25-1.23-.54-1.48 1.78-.2 3.65-.88 3.65-3.95 0-.88-.31-1.59-.82-2.15.08-.2.36-1.02-.08-2.12 0 0-.67-.22-2.2.82-.64-.18-1.32-.27-2-.27-.68 0-1.36.09-2 .27-1.53-1.03-2.2-.82-2.2-.82-.44 1.1-.16 1.92-.08 2.12-.51.56-.82 1.28-.82 2.15 0 3.06 1.86 3.75 3.64 3.95-.23.2-.44.55-.51 1.07-.46.21-1.61.55-2.33-.66-.15-.24-.6-.83-1.23-.82-.67.01-.27.38.01.53.34.19.73.9.82 1.13.16.45.68 1.31 2.69.94 0 .67.01 1.3.01 1.49 0 .21-.15.45-.55.38A7.995 7.995 0 0 1 0 8c0-4.42 3.58-8 8-8Z"})))),(0,a.yg)("p",null,"Here is the Arduino program for this project."),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-c"},'#include <Arduino.h>\n#include <TFT_eSPI.h>\n#include <SPI.h>\n#include "esp_camera.h"\n#include "FS.h"\n#include "SD.h"\n#include "SPI.h"\n\n#define CAMERA_MODEL_XIAO_ESP32S3 // Has PSRAM\n#define TOUCH_INT D7\n\n#include "camera_pins.h"\n\n// Width and height of round display\nconst int camera_width = 240;\nconst int camera_height = 240;\n\n// File Counter\nint imageCount = 1;\nbool camera_sign = false;          // Check camera status\nbool sd_sign = false;              // Check sd status\n\nTFT_eSPI tft = TFT_eSPI();\n\n// SD card write file\nvoid writeFile(fs::FS &fs, const char * path, uint8_t * data, size_t len){\n    Serial.printf("Writing file: %s\\n", path);\n\n    File file = fs.open(path, FILE_WRITE);\n    if(!file){\n        Serial.println("Failed to open file for writing");\n        return;\n    }\n    if(file.write(data, len) == len){\n        Serial.println("File written");\n    } else {\n        Serial.println("Write failed");\n    }\n    file.close();\n}\n\nbool display_is_pressed(void)\n{\n    if(digitalRead(TOUCH_INT) != LOW) {\n        delay(3);\n        if(digitalRead(TOUCH_INT) != LOW)\n        return false;\n    }\n    return true;\n}\n\nvoid setup() {\n  // put your setup code here, to run once:\n  Serial.begin(115200);\n//  while(!Serial);\n\n  // Camera pinout\n  camera_config_t config;\n  config.ledc_channel = LEDC_CHANNEL_0;\n  config.ledc_timer = LEDC_TIMER_0;\n  config.pin_d0 = Y2_GPIO_NUM;\n  config.pin_d1 = Y3_GPIO_NUM;\n  config.pin_d2 = Y4_GPIO_NUM;\n  config.pin_d3 = Y5_GPIO_NUM;\n  config.pin_d4 = Y6_GPIO_NUM;\n  config.pin_d5 = Y7_GPIO_NUM;\n  config.pin_d6 = Y8_GPIO_NUM;\n  config.pin_d7 = Y9_GPIO_NUM;\n  config.pin_xclk = XCLK_GPIO_NUM;\n  config.pin_pclk = PCLK_GPIO_NUM;\n  config.pin_vsync = VSYNC_GPIO_NUM;\n  config.pin_href = HREF_GPIO_NUM;\n  config.pin_sscb_sda = SIOD_GPIO_NUM;\n  config.pin_sscb_scl = SIOC_GPIO_NUM;\n  config.pin_pwdn = PWDN_GPIO_NUM;\n  config.pin_reset = RESET_GPIO_NUM;\n  config.xclk_freq_hz = 20000000;\n//  config.frame_size = FRAMESIZE_UXGA;\n  config.frame_size = FRAMESIZE_240X240;\n//  config.pixel_format = PIXFORMAT_JPEG; // for streaming\n  config.pixel_format = PIXFORMAT_RGB565;\n  config.grab_mode = CAMERA_GRAB_WHEN_EMPTY;\n  config.fb_location = CAMERA_FB_IN_PSRAM;\n  config.jpeg_quality = 12;\n  config.fb_count = 1;\n  \n  // if PSRAM IC present, init with UXGA resolution and higher JPEG quality\n  //                      for larger pre-allocated frame buffer.\n  if(config.pixel_format == PIXFORMAT_JPEG){\n    if(psramFound()){\n      config.jpeg_quality = 10;\n      config.fb_count = 2;\n      config.grab_mode = CAMERA_GRAB_LATEST;\n    } else {\n      // Limit the frame size when PSRAM is not available\n      config.frame_size = FRAMESIZE_SVGA;\n      config.fb_location = CAMERA_FB_IN_DRAM;\n    }\n  } else {\n    // Best option for face detection/recognition\n    config.frame_size = FRAMESIZE_240X240;\n#if CONFIG_IDF_TARGET_ESP32S3\n    config.fb_count = 2;\n#endif\n  }\n\n  // camera init\n  esp_err_t err = esp_camera_init(&config);\n  if (err != ESP_OK) {\n    Serial.printf("Camera init failed with error 0x%x", err);\n    return;\n  }\n  Serial.println("Camera ready");\n  camera_sign = true; // Camera initialization check passes\n\n  // Display initialization\n  tft.init();\n  tft.setRotation(1);\n  tft.fillScreen(TFT_WHITE);\n\n  // Initialize SD card\n  if(!SD.begin(D2)){\n    Serial.println("Card Mount Failed");\n    return;\n  }\n  uint8_t cardType = SD.cardType();\n\n  // Determine if the type of SD card is available\n  if(cardType == CARD_NONE){\n    Serial.println("No SD card attached");\n    return;\n  }\n\n  Serial.print("SD Card Type: ");\n  if(cardType == CARD_MMC){\n    Serial.println("MMC");\n  } else if(cardType == CARD_SD){\n    Serial.println("SDSC");\n  } else if(cardType == CARD_SDHC){\n    Serial.println("SDHC");\n  } else {\n    Serial.println("UNKNOWN");\n  }\n\n  sd_sign = true; // sd initialization check passes\n\n}\n\nvoid loop() {\n  if( sd_sign && camera_sign){\n\n    // Take a photo\n    camera_fb_t *fb = esp_camera_fb_get();\n    if (!fb) {\n      Serial.println("Failed to get camera frame buffer");\n      return;\n    }\n    \n    if(display_is_pressed()){\n      Serial.println("display is touched");\n      char filename[32];\n      sprintf(filename, "/image%d.jpg", imageCount);\n      // Save photo to file\n      writeFile(SD, filename, fb->buf, fb->len);\n      Serial.printf("Saved picture\uff1a%s\\n", filename);\n      imageCount++;\n    }\n  \n    // Decode JPEG images\n    uint8_t* buf = fb->buf;\n    uint32_t len = fb->len;\n    tft.startWrite();\n    tft.setAddrWindow(0, 0, camera_width, camera_height);\n    tft.pushColors(buf, len);\n    tft.endWrite();\n      \n    // Release image buffer\n    esp_camera_fb_return(fb);\n\n    delay(10);\n  }\n}\n')),(0,a.yg)("p",null,"Upload the program to XIAO ESP32S3 Sense, if the screen does not light up after successful upload, you may need to click the Reset button on XIAO, then you will see the monitoring screen displayed on the Round Display in real time. Click anywhere on the screen, the image will be recorded and saved in the microSD card."),(0,a.yg)("div",{style:{textAlign:"center"}},(0,a.yg)("img",{src:"https://files.seeedstudio.com/wiki/SeeedStudio-XIAO-ESP32S3/img/95.gif",style:{width:800,height:"auto"}})),(0,a.yg)("h3",{id:"program-annotation-1"},"Program annotation"),(0,a.yg)("p",null,"The configuration of the camera and the microSD card are the previous contents, so we will not repeat them here. For the use of microSD card, you can refer to the ",(0,a.yg)("a",{parentName:"p",href:"https://wiki.seeedstudio.com/xiao_esp32s3_sense_filesystem"},"XIAO ESP32S3 Sense file system")," Wiki to learn how to use it."),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-cpp"},'// Take a photo\ncamera_fb_t *fb = esp_camera_fb_get();\nif (!fb) {\n  Serial.println("Failed to get camera frame buffer");\n  return;\n}\n\n...\n  \n// Release image buffer\nesp_camera_fb_return(fb);\n\ndelay(10);\n')),(0,a.yg)("p",null,"The above program, which is the basic block of code for calling the camera, is divided into three parts: screen capture, exception exit, and releasing the photo buffer."),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-cpp"},'if(display_is_pressed()){\n  Serial.println("display is touched");\n  char filename[32];\n  sprintf(filename, "/image%d.jpg", imageCount);\n  // Save photo to file\n  writeFile(SD, filename, fb->buf, fb->len);\n  Serial.printf("Saved picture\uff1a%s\\n", filename);\n  imageCount++;\n}\n')),(0,a.yg)("p",null,"The above program is used to checks if the screen is touched. If it is, the code saves the captured image to a file on an microSD card."),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-cpp"},"// Decode JPEG images\nuint8_t* buf = fb->buf;\nuint32_t len = fb->len;\ntft.startWrite();\ntft.setAddrWindow(0, 0, camera_width, camera_height);\ntft.pushColors(buf, len);\ntft.endWrite();\n")),(0,a.yg)("p",null,"This part of the code displays the captured image on a screen. It first retrieves the image buffer and its length from the ",(0,a.yg)("inlineCode",{parentName:"p"},"camera_fb_t")," structure. Then, it sets up the screen to receive the image data and displays the image on the screen using the ",(0,a.yg)("inlineCode",{parentName:"p"},"pushColors()")," function."),(0,a.yg)("h2",{id:"record-short-videos-and-save-to-microsd-card"},"Record short videos and save to microSD card"),(0,a.yg)("admonition",{type:"note"},(0,a.yg)("p",{parentName:"admonition"},"We do not recommend video encoding export on top of MCU because the current supported encoding library resources are too small and the operation is very complicated and tedious."),(0,a.yg)("p",{parentName:"admonition"},"This example does not involve video encoding, and the exported video is an MJPG composite of AVI per frame, so the video recording may not be particularly good and satisfying. The purpose of this tutorial is to provide you with simple methods and ideas for recording short videos, and we welcome partners who have better solutions to submit PR to us.")),(0,a.yg)("p",null,"In the previous chapters, we mastered how to use the camera to capture images. We know that a single image is stitched together to make a moving video picture. Based on this theory, our project in this chapter will guide you how to write a program to record a 10-second video every 1 minute and save it in a microSD card."),(0,a.yg)("p",null,"You can find the complete program code and the required dependency files below this link."),(0,a.yg)("div",{class:"github_container",style:{textAlign:"center"}},(0,a.yg)("a",{class:"github_item",href:"https://github.com/limengdu/SeeedStudio-XIAO-ESP32S3-Sense-camera/tree/main/record_video"},(0,a.yg)("strong",null,(0,a.yg)("span",null,(0,a.yg)("font",{color:"FFFFFF",size:"4"}," Download the Code")))," ",(0,a.yg)("svg",{"aria-hidden":"true",focusable:"false",role:"img",className:"mr-2",viewBox:"-3 10 9 1",width:16,height:16,fill:"currentColor",style:{textAlign:"center",display:"inline-block",userSelect:"none",verticalAlign:"text-bottom",overflow:"visible"}},(0,a.yg)("path",{d:"M8 0c4.42 0 8 3.58 8 8a8.013 8.013 0 0 1-5.45 7.59c-.4.08-.55-.17-.55-.38 0-.27.01-1.13.01-2.2 0-.75-.25-1.23-.54-1.48 1.78-.2 3.65-.88 3.65-3.95 0-.88-.31-1.59-.82-2.15.08-.2.36-1.02-.08-2.12 0 0-.67-.22-2.2.82-.64-.18-1.32-.27-2-.27-.68 0-1.36.09-2 .27-1.53-1.03-2.2-.82-2.2-.82-.44 1.1-.16 1.92-.08 2.12-.51.56-.82 1.28-.82 2.15 0 3.06 1.86 3.75 3.64 3.95-.23.2-.44.55-.51 1.07-.46.21-1.61.55-2.33-.66-.15-.24-.6-.83-1.23-.82-.67.01-.27.38.01.53.34.19.73.9.82 1.13.16.45.68 1.31 2.69.94 0 .67.01 1.3.01 1.49 0 .21-.15.45-.55.38A7.995 7.995 0 0 1 0 8c0-4.42 3.58-8 8-8Z"})))),(0,a.yg)("p",null,"Here is the Arduino program for this project."),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-cpp"},'#include "esp_camera.h"\n#include "FS.h"\n#include "SD.h"\n#include "SPI.h"\n#include "esp_timer.h"\n\n#define CAMERA_MODEL_XIAO_ESP32S3 // Has PSRAM\n\n#include "camera_pins.h"\n\nconst int SD_PIN_CS = 21;\n\nFile videoFile;\nbool camera_sign = false;\nbool sd_sign = false;\nunsigned long lastCaptureTime = 0;\nunsigned long captureDuration = 10000; // 10 seconds\nint imageCount = 0;\n\nvoid setup() {\n  Serial.begin(115200);\n  while(!Serial);\n  \n  // Initialize the camera\n  camera_config_t config;\n  config.ledc_channel = LEDC_CHANNEL_0;\n  config.ledc_timer = LEDC_TIMER_0;\n  config.pin_d0 = Y2_GPIO_NUM;\n  config.pin_d1 = Y3_GPIO_NUM;\n  config.pin_d2 = Y4_GPIO_NUM;\n  config.pin_d3 = Y5_GPIO_NUM;\n  config.pin_d4 = Y6_GPIO_NUM;\n  config.pin_d5 = Y7_GPIO_NUM;\n  config.pin_d6 = Y8_GPIO_NUM;\n  config.pin_d7 = Y9_GPIO_NUM;\n  config.pin_xclk = XCLK_GPIO_NUM;\n  config.pin_pclk = PCLK_GPIO_NUM;\n  config.pin_vsync = VSYNC_GPIO_NUM;\n  config.pin_href = HREF_GPIO_NUM;\n  config.pin_sscb_sda = SIOD_GPIO_NUM;\n  config.pin_sscb_scl = SIOC_GPIO_NUM;\n  config.pin_pwdn = PWDN_GPIO_NUM;\n  config.pin_reset = RESET_GPIO_NUM;\n  config.xclk_freq_hz = 20000000;\n  config.pixel_format = PIXFORMAT_JPEG;\n  config.frame_size = FRAMESIZE_SVGA;\n  config.grab_mode = CAMERA_GRAB_WHEN_EMPTY;\n  config.fb_location = CAMERA_FB_IN_PSRAM;\n  config.jpeg_quality = 12;\n  config.fb_count = 1;\n\n  // camera init\n  esp_err_t err = esp_camera_init(&config);\n  if (err != ESP_OK) {\n    Serial.printf("Camera init failed with error 0x%x", err);\n    return;\n  }\n  \n  camera_sign = true;\n  \n  // Initialize the SD card\n  if (!SD.begin(SD_PIN_CS)) {\n    Serial.println("SD card initialization failed!");\n    return;\n  }\n\n  uint8_t cardType = SD.cardType();\n\n  // Determine if the type of SD card is available\n  if(cardType == CARD_NONE){\n    Serial.println("No SD card attached");\n    return;\n  }\n\n  Serial.print("SD Card Type: ");\n  if(cardType == CARD_MMC){\n    Serial.println("MMC");\n  } else if(cardType == CARD_SD){\n    Serial.println("SDSC");\n  } else if(cardType == CARD_SDHC){\n    Serial.println("SDHC");\n  } else {\n    Serial.println("UNKNOWN");\n  }\n  \n  sd_sign = true;\n\n  Serial.println("Video will begin in one minute, please be ready.");\n}\n\nvoid loop() {\n  // Camera & SD available, start taking video\n  if (camera_sign && sd_sign) {\n    // Get the current time\n    unsigned long now = millis();\n\n    //If it has been more than 1 minute since the last video capture, start capturing a new video\n    if ((now - lastCaptureTime) >= 60000) {\n      char filename[32];\n      sprintf(filename, "/video%d.avi", imageCount);\n      videoFile = SD.open(filename, FILE_WRITE);\n      if (!videoFile) {\n        Serial.println("Error opening video file!");\n        return;\n      }\n      Serial.printf("Recording video\uff1a%s\\n", filename);\n      lastCaptureTime = now;\n      \n      // Start capturing video frames\n      while ((millis() - lastCaptureTime) < captureDuration) {\n        camera_fb_t *fb = esp_camera_fb_get();\n        if (!fb) {\n          Serial.println("Error getting framebuffer!");\n          break;\n        }\n        videoFile.write(fb->buf, fb->len);\n        esp_camera_fb_return(fb);\n      }\n      \n      // Close the video file\n      videoFile.close();\n      Serial.printf("Video saved: %s\\n", filename);\n      imageCount++;\n\n      Serial.println("Video will begin in one minute, please be ready.");\n\n      // Wait for the remaining time of the minute\n      delay(60000 - (millis() - lastCaptureTime));\n    }\n  }\n}\n')),(0,a.yg)("p",null,"Upload the code to XIAO ESP32S3 Sense, turn on the serial monitor, at this time please adjust the camera position to the object you want to record, after one minute, the orange LED on XIAO will start flashing and the recording will start and save to the microSD card."),(0,a.yg)("div",{style:{textAlign:"center"}},(0,a.yg)("img",{src:"https://files.seeedstudio.com/wiki/SeeedStudio-XIAO-ESP32S3/img/96.png",style:{width:800,height:"auto"}})),(0,a.yg)("admonition",{type:"note"},(0,a.yg)("p",{parentName:"admonition"},"Since the program does not involve settings such as encoding and frame rate, the video may open for only one second if there is no change in each frame of the recorded footage.")),(0,a.yg)("h3",{id:"program-annotation-2"},"Program annotation"),(0,a.yg)("p",null,"The core and key in the procedure of recording video is to keep acquiring the photo stream for a continuous period of 10 seconds and write it to the microSD card continuously."),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-cpp"},'// Start capturing video frames\nwhile ((millis() - lastCaptureTime) < captureDuration) {\n  camera_fb_t *fb = esp_camera_fb_get();\n  if (!fb) {\n    Serial.println("Error getting framebuffer!");\n    break;\n  }\n  videoFile.write(fb->buf, fb->len);\n  esp_camera_fb_return(fb);\n}\n')),(0,a.yg)("p",null,"On top of that, we nest a layer of 1-minute wait judgments on the outside to ensure that the video starts every 1 minute."),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-cpp"},"//If it has been more than 1 minute since the last video capture, start capturing a new video\nif ((now - lastCaptureTime) >= 60000) {\n\n  ...\n\n  delay(60000 - (millis() - lastCaptureTime));\n}\n")),(0,a.yg)("h2",{id:"project-ii-video-streaming"},"Project II: Video Streaming"),(0,a.yg)("p",null,"At the end of this tutorial, let's show a video streaming project. This project allows you to see a live video stream on a web page created by XIAO ESP32S3 Sense, and you can change the display of the screen by setting some parameters."),(0,a.yg)("p",null,"You can find the complete program code and the required dependency files below this link."),(0,a.yg)("div",{class:"github_container",style:{textAlign:"center"}},(0,a.yg)("a",{class:"github_item",href:"https://github.com/limengdu/SeeedStudio-XIAO-ESP32S3-Sense-camera/tree/main/CameraWebServer"},(0,a.yg)("strong",null,(0,a.yg)("span",null,(0,a.yg)("font",{color:"FFFFFF",size:"4"}," Download the Code")))," ",(0,a.yg)("svg",{"aria-hidden":"true",focusable:"false",role:"img",className:"mr-2",viewBox:"-3 10 9 1",width:16,height:16,fill:"currentColor",style:{textAlign:"center",display:"inline-block",userSelect:"none",verticalAlign:"text-bottom",overflow:"visible"}},(0,a.yg)("path",{d:"M8 0c4.42 0 8 3.58 8 8a8.013 8.013 0 0 1-5.45 7.59c-.4.08-.55-.17-.55-.38 0-.27.01-1.13.01-2.2 0-.75-.25-1.23-.54-1.48 1.78-.2 3.65-.88 3.65-3.95 0-.88-.31-1.59-.82-2.15.08-.2.36-1.02-.08-2.12 0 0-.67-.22-2.2.82-.64-.18-1.32-.27-2-.27-.68 0-1.36.09-2 .27-1.53-1.03-2.2-.82-2.2-.82-.44 1.1-.16 1.92-.08 2.12-.51.56-.82 1.28-.82 2.15 0 3.06 1.86 3.75 3.64 3.95-.23.2-.44.55-.51 1.07-.46.21-1.61.55-2.33-.66-.15-.24-.6-.83-1.23-.82-.67.01-.27.38.01.53.34.19.73.9.82 1.13.16.45.68 1.31 2.69.94 0 .67.01 1.3.01 1.49 0 .21-.15.45-.55.38A7.995 7.995 0 0 1 0 8c0-4.42 3.58-8 8-8Z"})))),(0,a.yg)("p",null,"Here is the Arduino program for this project."),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-cpp"},'#include "esp_camera.h"\n#include <WiFi.h>\n\n#define CAMERA_MODEL_XIAO_ESP32S3 // Has PSRAM\n\n#include "camera_pins.h"\n\n// ===========================\n// Enter your WiFi credentials\n// ===========================\nconst char* ssid = "**********";\nconst char* password = "**********";\n\nvoid startCameraServer();\nvoid setupLedFlash(int pin);\n\nvoid setup() {\n  Serial.begin(115200);\n  while(!Serial);\n  Serial.setDebugOutput(true);\n  Serial.println();\n\n  camera_config_t config;\n  config.ledc_channel = LEDC_CHANNEL_0;\n  config.ledc_timer = LEDC_TIMER_0;\n  config.pin_d0 = Y2_GPIO_NUM;\n  config.pin_d1 = Y3_GPIO_NUM;\n  config.pin_d2 = Y4_GPIO_NUM;\n  config.pin_d3 = Y5_GPIO_NUM;\n  config.pin_d4 = Y6_GPIO_NUM;\n  config.pin_d5 = Y7_GPIO_NUM;\n  config.pin_d6 = Y8_GPIO_NUM;\n  config.pin_d7 = Y9_GPIO_NUM;\n  config.pin_xclk = XCLK_GPIO_NUM;\n  config.pin_pclk = PCLK_GPIO_NUM;\n  config.pin_vsync = VSYNC_GPIO_NUM;\n  config.pin_href = HREF_GPIO_NUM;\n  config.pin_sscb_sda = SIOD_GPIO_NUM;\n  config.pin_sscb_scl = SIOC_GPIO_NUM;\n  config.pin_pwdn = PWDN_GPIO_NUM;\n  config.pin_reset = RESET_GPIO_NUM;\n  config.xclk_freq_hz = 20000000;\n  config.frame_size = FRAMESIZE_UXGA;\n  config.pixel_format = PIXFORMAT_JPEG; // for streaming\n  //config.pixel_format = PIXFORMAT_RGB565; // for face detection/recognition\n  config.grab_mode = CAMERA_GRAB_WHEN_EMPTY;\n  config.fb_location = CAMERA_FB_IN_PSRAM;\n  config.jpeg_quality = 12;\n  config.fb_count = 1;\n  \n  // if PSRAM IC present, init with UXGA resolution and higher JPEG quality\n  //                      for larger pre-allocated frame buffer.\n  if(config.pixel_format == PIXFORMAT_JPEG){\n    if(psramFound()){\n      config.jpeg_quality = 10;\n      config.fb_count = 2;\n      config.grab_mode = CAMERA_GRAB_LATEST;\n    } else {\n      // Limit the frame size when PSRAM is not available\n      config.frame_size = FRAMESIZE_SVGA;\n      config.fb_location = CAMERA_FB_IN_DRAM;\n    }\n  } else {\n    // Best option for face detection/recognition\n    config.frame_size = FRAMESIZE_240X240;\n#if CONFIG_IDF_TARGET_ESP32S3\n    config.fb_count = 2;\n#endif\n  }\n\n  // camera init\n  esp_err_t err = esp_camera_init(&config);\n  if (err != ESP_OK) {\n    Serial.printf("Camera init failed with error 0x%x", err);\n    return;\n  }\n\n  sensor_t * s = esp_camera_sensor_get();\n  // initial sensors are flipped vertically and colors are a bit saturated\n  if (s->id.PID == OV3660_PID) {\n    s->set_vflip(s, 1); // flip it back\n    s->set_brightness(s, 1); // up the brightness just a bit\n    s->set_saturation(s, -2); // lower the saturation\n  }\n  // drop down frame size for higher initial frame rate\n  if(config.pixel_format == PIXFORMAT_JPEG){\n    s->set_framesize(s, FRAMESIZE_QVGA);\n  }\n\n// Setup LED FLash if LED pin is defined in camera_pins.h\n#if defined(LED_GPIO_NUM)\n  setupLedFlash(LED_GPIO_NUM);\n#endif\n\n  WiFi.begin(ssid, password);\n  WiFi.setSleep(false);\n\n  while (WiFi.status() != WL_CONNECTED) {\n    delay(500);\n    Serial.print(".");\n  }\n  Serial.println("");\n  Serial.println("WiFi connected");\n\n  startCameraServer();\n\n  Serial.print("Camera Ready! Use \'http://");\n  Serial.print(WiFi.localIP());\n  Serial.println("\' to connect");\n}\n\nvoid loop() {\n  // Do nothing. Everything is done in another task by the web server\n  delay(10000);\n}\n')),(0,a.yg)("p",null,"Before uploading the program, you need to change the WiFi name and password in the code to your own. After uploading the program, if the XIAO ESP32C3 successfully connects to your WiFi, its IP address will be printed out."),(0,a.yg)("admonition",{type:"caution"},(0,a.yg)("p",{parentName:"admonition"},"XIAO ESP32S3 If you perform this project for a long time, please pay attention to heat dissipation, XIAO will become very hot, please be careful of burns!")),(0,a.yg)("div",{style:{textAlign:"center"}},(0,a.yg)("img",{src:"https://files.seeedstudio.com/wiki/SeeedStudio-XIAO-ESP32S3/img/97.png",style:{width:800,height:"auto"}})),(0,a.yg)("admonition",{type:"tip"},(0,a.yg)("p",{parentName:"admonition"},"As you can see in the above figure, if you turn on the output of debug information, then you may see some of the chip kernel's debug information printed out in the serial monitor. For example ",(0,a.yg)("inlineCode",{parentName:"p"},"[0;31mE (2947) MFN: Partition Not found[0m"),", please don't worry about it, it doesn't affect the running of the program.")),(0,a.yg)("p",null,"Please open your browser, we recommend Edge or Google Chrome, and enter that IP address and you will see the configuration page for the video."),(0,a.yg)("admonition",{type:"note"},(0,a.yg)("p",{parentName:"admonition"},"Please note that the device you are using the browser on needs to be on the same LAN as XIAO.")),(0,a.yg)("p",null,"After configuring the video stream specifications you want to set up, click ",(0,a.yg)("strong",{parentName:"p"},"Start Stream")," at the bottom of the left toolbar and you will see the live feed of the camera."),(0,a.yg)("div",{style:{textAlign:"center"}},(0,a.yg)("img",{src:"https://files.seeedstudio.com/wiki/SeeedStudio-XIAO-ESP32S3/img/98.png",style:{width:1e3,height:"auto"}})),(0,a.yg)("p",null,"Fortunately, ESP32 has also officially added face recognition to the program. You can experience the feature by turning on the button switch for face recognition with reduced picture quality."),(0,a.yg)("admonition",{type:"tip"},(0,a.yg)("p",{parentName:"admonition"},"For performance reasons, the quality of the screen cannot be higher than ",(0,a.yg)("strong",{parentName:"p"},"CIF"),", otherwise the web page will pop up with an error when you turn on the switch for face recognition.")),(0,a.yg)("div",{style:{textAlign:"center"}},(0,a.yg)("img",{src:"https://files.seeedstudio.com/wiki/SeeedStudio-XIAO-ESP32S3/img/99.png",style:{width:400,height:"auto"}})),(0,a.yg)("p",null,"Oh, my big face is circled."),(0,a.yg)("div",{style:{textAlign:"center"}},(0,a.yg)("img",{src:"https://files.seeedstudio.com/wiki/SeeedStudio-XIAO-ESP32S3/img/100.png",style:{width:600,height:"auto"}})),(0,a.yg)("h2",{id:"troubleshooting"},"Troubleshooting"),(0,a.yg)("h3",{id:"q1-when-xiao-esp32s3-sense-and-round-display-are-used-together-do-i-have-to-cut-the-j3-pin-which-sd-card-slot-can-be-used"},"Q1: When XIAO ESP32S3 Sense and Round Display are used together, do I have to cut the J3 pin? Which SD card slot can be used?"),(0,a.yg)("p",null,"A: In principle, you need to cut the J3 pin when XIAO ESP32S3 Sense is used together with Round Display to use microSD card. The reason is that there are pull-up resistors in the design of the circuit of both expansion boards, so theoretically, if two pull-up resistors work at the same time, then the SD card slot will not work properly. An error message of SD card mount failure will appear. Since the pull-up resistor on the Round Display cannot be blocked, you need to cut J3 on the sense expansion board to make sure only one pull-up resistor is working when the two are used together. This also determines that when both are used together, there is and only the SD card slot on the Round Display is active."),(0,a.yg)("p",null,"However, ",(0,a.yg)("strong",{parentName:"p"},"we need to thank engineer Mjrovai for the new method of using the microSD card slot on the XIAO ESP32S3 Sense at the same time"),", which is also possible at software level. We can refer to ",(0,a.yg)("strong",{parentName:"p"},(0,a.yg)("a",{parentName:"strong",href:"https://github.com/Mjrovai/XIAO-ESP32S3-Sense/tree/main/camera_round_display_save_jpeg"},"his methods and procedures")),"."),(0,a.yg)("h2",{id:"tech-support--product-discussion"},"Tech Support & Product Discussion"),(0,a.yg)("p",null,"Thank you for choosing our products! We are here to provide you with different support to ensure that your experience with our products is as smooth as possible. We offer several communication channels to cater to different preferences and needs."),(0,a.yg)("div",{class:"button_tech_support_container"},(0,a.yg)("a",{href:"https://forum.seeedstudio.com/",class:"button_forum"}),(0,a.yg)("a",{href:"https://www.seeedstudio.com/contacts",class:"button_email"})),(0,a.yg)("div",{class:"button_tech_support_container"},(0,a.yg)("a",{href:"https://discord.gg/eWkprNDMU7",class:"button_discord"}),(0,a.yg)("a",{href:"https://github.com/Seeed-Studio/wiki-documents/discussions/69",class:"button_discussion"})))}d.isMDXComponent=!0}}]);