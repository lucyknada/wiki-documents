"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[23727],{15680:(e,n,t)=>{t.d(n,{xA:()=>g,yg:()=>c});var a=t(96540);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function r(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function l(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?r(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function o(e,n){if(null==e)return{};var t,a,i=function(e,n){if(null==e)return{};var t,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var p=a.createContext({}),s=function(e){var n=a.useContext(p),t=n;return e&&(t="function"==typeof e?e(n):l(l({},n),e)),t},g=function(e){var n=s(e.components);return a.createElement(p.Provider,{value:n},e.children)},d="mdxType",u={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},m=a.forwardRef((function(e,n){var t=e.components,i=e.mdxType,r=e.originalType,p=e.parentName,g=o(e,["components","mdxType","originalType","parentName"]),d=s(t),m=i,c=d["".concat(p,".").concat(m)]||d[m]||u[m]||r;return t?a.createElement(c,l(l({ref:n},g),{},{components:t})):a.createElement(c,l({ref:n},g))}));function c(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var r=t.length,l=new Array(r);l[0]=m;var o={};for(var p in n)hasOwnProperty.call(n,p)&&(o[p]=n[p]);o.originalType=e,o[d]="string"==typeof e?e:i,l[1]=o;for(var s=2;s<r;s++)l[s]=t[s];return a.createElement.apply(null,l)}return a.createElement.apply(null,t)}m.displayName="MDXCreateElement"},3173:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>p,contentTitle:()=>l,default:()=>u,frontMatter:()=>r,metadata:()=>o,toc:()=>s});var a=t(58168),i=(t(96540),t(15680));const r={description:"Wio-WM1110 Dev Kit Hardware Overview",title:"Hardware Overview",keywords:["Wio-WM1110 Dev Kit"],image:"https://files.seeedstudio.com/wiki/wiki-platform/S-tempor.png",slug:"/Wio-WM1110_Dev_Kit_Hardware_Overview",last_update:{date:"8/8/2023",author:"Jessie"}},l=void 0,o={unversionedId:"Sensor/Wio_Series/Wio-WM1110_Dev_Kit/Development_Tutorial/Hardware_Overview",id:"Sensor/Wio_Series/Wio-WM1110_Dev_Kit/Development_Tutorial/Hardware_Overview",title:"Hardware Overview",description:"Wio-WM1110 Dev Kit Hardware Overview",source:"@site/docs/Sensor/Wio_Series/Wio-WM1110_Dev_Kit/Development_Tutorial/Hardware_Overview.md",sourceDirName:"Sensor/Wio_Series/Wio-WM1110_Dev_Kit/Development_Tutorial",slug:"/Wio-WM1110_Dev_Kit_Hardware_Overview",permalink:"/Wio-WM1110_Dev_Kit_Hardware_Overview",draft:!1,editUrl:"https://github.com/Seeed-Studio/wiki-documents/blob/docusaurus-version/docs/Sensor/Wio_Series/Wio-WM1110_Dev_Kit/Development_Tutorial/Hardware_Overview.md",tags:[],version:"current",lastUpdatedBy:"Jessie",lastUpdatedAt:1691452800,formattedLastUpdatedAt:"Aug 8, 2023",frontMatter:{description:"Wio-WM1110 Dev Kit Hardware Overview",title:"Hardware Overview",keywords:["Wio-WM1110 Dev Kit"],image:"https://files.seeedstudio.com/wiki/wiki-platform/S-tempor.png",slug:"/Wio-WM1110_Dev_Kit_Hardware_Overview",last_update:{date:"8/8/2023",author:"Jessie"}},sidebar:"ProductSidebar",previous:{title:"Get Started with Wio-WM1110 Dev Kit",permalink:"/Get_Started_with_Wio-WM1110_Dev_Kit"},next:{title:"LPWAN Dev Kit for Sidewalk",permalink:"/wio_tracker_for_sidewalk"}},p={},s=[{value:"Hardware Overview",id:"hardware-overview",level:2},{value:"Pinout",id:"pinout",level:2},{value:"LoRaWAN\xae Communication",id:"lorawan-communication",level:2},{value:"Setup the keys",id:"setup-the-keys",level:3},{value:"Positioning",id:"positioning",level:2},{value:"GNSS",id:"gnss",level:3},{value:"Wi-Fi",id:"wi-fi",level:3},{value:"GNSS and Wi-Fi",id:"gnss-and-wi-fi",level:3},{value:"BLE",id:"ble",level:2},{value:"On-board Sensors",id:"on-board-sensors",level:2},{value:"TH Sensor(SHT41)",id:"th-sensorsht41",level:3},{value:"3-axis Accelerometer(LIS3DHTR)",id:"3-axis-accelerometerlis3dhtr",level:3},{value:"Grove",id:"grove",level:2},{value:"Grove IIC",id:"grove-iic",level:3},{value:"Grove UART",id:"grove-uart",level:3},{value:"Grove ADC",id:"grove-adc",level:3},{value:"Resources",id:"resources",level:2},{value:"Tech Support",id:"tech-support",level:2}],g={toc:s},d="wrapper";function u(e){let{components:n,...t}=e;return(0,i.yg)(d,(0,a.A)({},g,t,{components:n,mdxType:"MDXLayout"}),(0,i.yg)("p",null,"The Wio WM1110 Dev Kit is an open source platform for building IoT projects. It provides low-power loRa network connection and a full range of location coverage services. This kit also includes a range of sensors and peripherals, making it a versatile platform for building IoT projects."),(0,i.yg)("p",null,"In this tutorial, we will introduce the hardware overview and how to develop your own application! "),(0,i.yg)("h2",{id:"hardware-overview"},"Hardware Overview"),(0,i.yg)("p",null,"The Wio-WM1110 Dev Kit is based on ",(0,i.yg)("a",{parentName:"p",href:"https://www.seeedstudio.com/Wio-WM1110-Module-LR1110-and-nRF52840-p-5676.html"},"Wio-WM1110 Module"),",integrates Semtech's LoRa\xae transceiver and a multi-purpose radio front-end for geolocation, the board has a built-in TH sensor and a 3-axis Accelerometer, also providing connectivity options for a variety of peripherals."),(0,i.yg)("p",{style:{textAlign:"center"}},(0,i.yg)("img",{src:"https://files.seeedstudio.com/wiki/SenseCAP/Wio-WM1110%20Dev%20Kit/hardware_overview1.png",alt:"pir",width:800,height:"auto"})),(0,i.yg)("h2",{id:"pinout"},"Pinout"),(0,i.yg)("p",{style:{textAlign:"center"}},(0,i.yg)("img",{src:"https://files.seeedstudio.com/wiki/SenseCAP/Wio-WM1110%20Dev%20Kit/PIN.png",alt:"pir",width:800,height:"auto"})),(0,i.yg)("h2",{id:"lorawan-communication"},"LoRaWAN\xae Communication"),(0,i.yg)("h3",{id:"setup-the-keys"},"Setup the keys"),(0,i.yg)("p",null,"Before a device can communicate via the NS, we need to register it with the 3 keys."),(0,i.yg)("p",null,"Wio-WM1110 DK allows users to set the DevEUI, AppEUI, and AppKey, so you can set up our own parameters in the 'lorawan_key_config.h' file, then flash it onto the DK."),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-cpp"},"...\\Seeed_Wio_WM1110_Dev_Board\\apps\\common\\lorawan_key_config.h\n")),(0,i.yg)("p",{style:{textAlign:"center"}},(0,i.yg)("img",{src:"https://files.seeedstudio.com/wiki/SenseCAP/Wio-WM1110%20Dev%20Kit/keys.png",alt:"pir",width:800,height:"auto"})),(0,i.yg)("p",null,(0,i.yg)("strong",{parentName:"p"},"LoRa Basics Modem LoRaWAN\xae Class A/C example")),(0,i.yg)("p",null,"The application will automatically starts a procedure to join a LoRaWAN network see ",(0,i.yg)("strong",{parentName:"p"},"lorawan_key_config.h")),(0,i.yg)("p",null,"Once a network is joined (i.e. when the corresponding event is triggered), uplinks are sent periodically. This periodic action is based on the LoRa Basics Modem alarm functionality. Each time the alarm-related event is triggered, the application requests an uplink."),(0,i.yg)("p",null,"The content of the uplink is the value read out from the charge counter by calling ",(0,i.yg)("inlineCode",{parentName:"p"},"smtc_modem_get_charge()"),"."),(0,i.yg)("p",null,"The application is also capable of displaying data and meta-data of a received downlink."),(0,i.yg)("p",null,(0,i.yg)("strong",{parentName:"p"},"Configuration")),(0,i.yg)("p",null,"Several parameters can be updated in ",(0,i.yg)("inlineCode",{parentName:"p"},"main_lorawan.h")," header file:"),(0,i.yg)("table",null,(0,i.yg)("thead",{parentName:"table"},(0,i.yg)("tr",{parentName:"thead"},(0,i.yg)("th",{parentName:"tr",align:null},"Constant"),(0,i.yg)("th",{parentName:"tr",align:null},"Description"))),(0,i.yg)("tbody",{parentName:"table"},(0,i.yg)("tr",{parentName:"tbody"},(0,i.yg)("td",{parentName:"tr",align:null},(0,i.yg)("inlineCode",{parentName:"td"},"LORAWAN_APP_PORT")),(0,i.yg)("td",{parentName:"tr",align:null},"LoRaWAN\xae FPort used for the uplink messages")),(0,i.yg)("tr",{parentName:"tbody"},(0,i.yg)("td",{parentName:"tr",align:null},(0,i.yg)("inlineCode",{parentName:"td"},"LORAWAN_CONFIRMED_MSG_ON")),(0,i.yg)("td",{parentName:"tr",align:null},"Request a confirmation from the LNS that the uplink message has been received")),(0,i.yg)("tr",{parentName:"tbody"},(0,i.yg)("td",{parentName:"tr",align:null},(0,i.yg)("inlineCode",{parentName:"td"},"APP_TX_DUTYCYCLE")),(0,i.yg)("td",{parentName:"tr",align:null},"Delay in second between two uplinks")))),(0,i.yg)("h2",{id:"positioning"},"Positioning"),(0,i.yg)("h3",{id:"gnss"},"GNSS"),(0,i.yg)("p",null,"By capturing a short portion of the signal broadcast by the GNSS satellites, and extracting the information required to calculate the device position - the pseudo-ranges. This information is aggregated into a NAV message which can be sent to a back-end system to compute the device position."),(0,i.yg)("p",{style:{textAlign:"center"}},(0,i.yg)("img",{src:"https://wdcdn.qpic.cn/MTY4ODg1NTkyNTI4NTI1MQ_47857_JbH8r_MU_X1uz1V7_1687329215?w=1265&h=592&type=image/jpeg",alt:"pir",width:800,height:"auto"})),(0,i.yg)("p",null,"The GNSS scanner of the Wio-WM1110 has two modes of operations: autonomous and assisted."),(0,i.yg)("p",null,(0,i.yg)("strong",{parentName:"p"},"GNSS autonomous mode:")," Does not require any assistance location or almanac data, and aims to detect strong satellite signals. Therefore it is suitable for outdoor conditions with good sky visibility."),(0,i.yg)("p",null,(0,i.yg)("strong",{parentName:"p"},"GNSS assisted mode"),"\uff1aIt allows the most efficient GNSS geolocation. Assistance information can build a list of the satellites in view at the current time and location, in order to reduce the GNSS satellites search space, and therefore optimize the time and energy spent geolocating. The assistance information is tailored to an LPWAN network, limiting the data sent, especially the downlink size and frequency. It consists of:  "),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"LR1110 approximate position "),(0,i.yg)("li",{parentName:"ul"},"Current time "),(0,i.yg)("li",{parentName:"ul"},"Up-to-date reduced size Almanac information (less than 3 months old)")),(0,i.yg)("p",null,(0,i.yg)("strong",{parentName:"p"},"Geolocation GNSS Example")),(0,i.yg)("p",null,"This example illustrates the GNSS scan procedure:"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"configuration of the LoRa Basics Modem library; and"),(0,i.yg)("li",{parentName:"ul"},"execution of GNSS ",(0,i.yg)("em",{parentName:"li"},"scan & send")," feature using the ",(0,i.yg)("em",{parentName:"li"},"GNSS geolocation middleware"),".")),(0,i.yg)("p",null,(0,i.yg)("strong",{parentName:"p"},"GNSS demonstration related configuration")),(0,i.yg)("p",null,"The ",(0,i.yg)("inlineCode",{parentName:"p"},"main_geolocation_gnss.h")," header file defines several constants to configure geolocation parameters."),(0,i.yg)("table",null,(0,i.yg)("thead",{parentName:"table"},(0,i.yg)("tr",{parentName:"thead"},(0,i.yg)("th",{parentName:"tr",align:null},"Constant"),(0,i.yg)("th",{parentName:"tr",align:null},"Comments"),(0,i.yg)("th",{parentName:"tr",align:null},"Possible values"),(0,i.yg)("th",{parentName:"tr",align:null},"Default Value"))),(0,i.yg)("tbody",{parentName:"table"},(0,i.yg)("tr",{parentName:"tbody"},(0,i.yg)("td",{parentName:"tr",align:null},(0,i.yg)("inlineCode",{parentName:"td"},"MODEM_EXAMPLE_ASSISTANCE_POSITION_AUTO")),(0,i.yg)("td",{parentName:"tr",align:null},"If set to ",(0,i.yg)("inlineCode",{parentName:"td"},"true"),": configures the application to autonomously get an assistance position"),(0,i.yg)("td",{parentName:"tr",align:null},"{",(0,i.yg)("inlineCode",{parentName:"td"},"true"),",",(0,i.yg)("inlineCode",{parentName:"td"},"false"),"}"),(0,i.yg)("td",{parentName:"tr",align:null},(0,i.yg)("inlineCode",{parentName:"td"},"true"))))),(0,i.yg)("p",null,"If manual mode is selected for assistance position, the following constants define the position to be used."),(0,i.yg)("table",null,(0,i.yg)("thead",{parentName:"table"},(0,i.yg)("tr",{parentName:"thead"},(0,i.yg)("th",{parentName:"tr",align:null},"Constant"),(0,i.yg)("th",{parentName:"tr",align:null},"Comments"),(0,i.yg)("th",{parentName:"tr",align:null},"Possible values"),(0,i.yg)("th",{parentName:"tr",align:null},"Default Value"))),(0,i.yg)("tbody",{parentName:"table"},(0,i.yg)("tr",{parentName:"tbody"},(0,i.yg)("td",{parentName:"tr",align:null},(0,i.yg)("inlineCode",{parentName:"td"},"MODEM_EXAMPLE_ASSISTANCE_POSITION_LAT")),(0,i.yg)("td",{parentName:"tr",align:null},"The latitude to use for GNSS Assisted scan (decimal degree)"),(0,i.yg)("td",{parentName:"tr",align:null},"Any ",(0,i.yg)("inlineCode",{parentName:"td"},"float")," in ","[-90, 90]"),(0,i.yg)("td",{parentName:"tr",align:null},"45.181454")),(0,i.yg)("tr",{parentName:"tbody"},(0,i.yg)("td",{parentName:"tr",align:null},(0,i.yg)("inlineCode",{parentName:"td"},"MODEM_EXAMPLE_ASSISTANCE_POSITION_LONG")),(0,i.yg)("td",{parentName:"tr",align:null},"The longitude to use for GNSS Assisted scan (decimal degree)"),(0,i.yg)("td",{parentName:"tr",align:null},"Any ",(0,i.yg)("inlineCode",{parentName:"td"},"float")," in ","[-180, 180]"),(0,i.yg)("td",{parentName:"tr",align:null},"5.720893")),(0,i.yg)("tr",{parentName:"tbody"},(0,i.yg)("td",{parentName:"tr",align:null},(0,i.yg)("inlineCode",{parentName:"td"},"MODEM_EXAMPLE_ASSISTANCE_POSITION_TEXT")),(0,i.yg)("td",{parentName:"tr",align:null},"A text representation of the assistance position, for information printing only"),(0,i.yg)("td",{parentName:"tr",align:null},"Any constant c-string"),(0,i.yg)("td",{parentName:"tr",align:null},'"Grenoble, FRANCE"')))),(0,i.yg)("p",null,(0,i.yg)("strong",{parentName:"p"},(0,i.yg)("em",{parentName:"strong"},"Note")),": The pre-defined assistance position must be within a 150 km range of the actual location."),(0,i.yg)("table",null,(0,i.yg)("thead",{parentName:"table"},(0,i.yg)("tr",{parentName:"thead"},(0,i.yg)("th",{parentName:"tr",align:null},"Constant"),(0,i.yg)("th",{parentName:"tr",align:null},"Comments"),(0,i.yg)("th",{parentName:"tr",align:null},"Possible values"),(0,i.yg)("th",{parentName:"tr",align:null},"Default Value"))),(0,i.yg)("tbody",{parentName:"table"},(0,i.yg)("tr",{parentName:"tbody"},(0,i.yg)("td",{parentName:"tr",align:null},(0,i.yg)("inlineCode",{parentName:"td"},"GNSS_SCAN_GROUP_PERIOD")),(0,i.yg)("td",{parentName:"tr",align:null},"Defines the duration between the end of a scan & send sequence and the start of next sequence"),(0,i.yg)("td",{parentName:"tr",align:null},(0,i.yg)("inlineCode",{parentName:"td"},"uint32_t")),(0,i.yg)("td",{parentName:"tr",align:null},"30")),(0,i.yg)("tr",{parentName:"tbody"},(0,i.yg)("td",{parentName:"tr",align:null},(0,i.yg)("inlineCode",{parentName:"td"},"GNSS_SCAN_MODE")),(0,i.yg)("td",{parentName:"tr",align:null},"Defines the GNSS scan mode (static or mobile) to be used for scan & send sequences."),(0,i.yg)("td",{parentName:"tr",align:null},"Value in ",(0,i.yg)("inlineCode",{parentName:"td"},"gnss_mw_mode_t")),(0,i.yg)("td",{parentName:"tr",align:null},(0,i.yg)("inlineCode",{parentName:"td"},"GNSS_MW_MODE_STATIC"))))),(0,i.yg)("p",null,"The GNSS scan mode selected by default is ",(0,i.yg)("inlineCode",{parentName:"p"},"GNSS_MW_MODE_STATIC"),", meaning that\nthis application example targets non-mobile objects."),(0,i.yg)("h3",{id:"wi-fi"},"Wi-Fi"),(0,i.yg)("p",null,"By discovering the Wi-Fi b/g/n access points available in the vicinity of the device, and extract MAC addresses allowing to geolocate the device. The objective is to obtain at least 2 MAC addresses, which can be used to position the device, after they have been sent to an online Wi-Fi lookup service"),(0,i.yg)("p",{style:{textAlign:"center"}},(0,i.yg)("img",{src:"https://files.seeedstudio.com/wiki/SenseCAP/Wio-WM1110%20Dev%20Kit/Schematic02.png",alt:"pir",width:800,height:"auto"})),(0,i.yg)("p",null,(0,i.yg)("strong",{parentName:"p"},"Geolocation Wi-Fi Example")),(0,i.yg)("p",null,"This application demonstrates the usage of the Wi-Fi geolocation middleware and\nhow the LoRa Basics Modem should be configured to meet the prerequisites for\nThis example illustrates the Wi-Fi scan procedure:"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"configuration of the LoRa Basics Modem library; and"),(0,i.yg)("li",{parentName:"ul"},"execution of Wi-Fi ",(0,i.yg)("em",{parentName:"li"},"scan & send")," feature using the ",(0,i.yg)("em",{parentName:"li"},"Wi-Fi geolocation middleware"),".")),(0,i.yg)("p",null,(0,i.yg)("strong",{parentName:"p"},"Wi-Fi demonstration related configuration")),(0,i.yg)("p",null,"The ",(0,i.yg)("inlineCode",{parentName:"p"},"main_geolocation_wifi.h")," header file defines several constants which can be\nset to define the configurable parameters of the application."),(0,i.yg)("table",null,(0,i.yg)("thead",{parentName:"table"},(0,i.yg)("tr",{parentName:"thead"},(0,i.yg)("th",{parentName:"tr",align:null},"Constant"),(0,i.yg)("th",{parentName:"tr",align:null},"Comments"),(0,i.yg)("th",{parentName:"tr",align:null},"Possible values"),(0,i.yg)("th",{parentName:"tr",align:null},"Default Value"))),(0,i.yg)("tbody",{parentName:"table"},(0,i.yg)("tr",{parentName:"tbody"},(0,i.yg)("td",{parentName:"tr",align:null},(0,i.yg)("inlineCode",{parentName:"td"},"WIFI_SCAN_PERIOD")),(0,i.yg)("td",{parentName:"tr",align:null},"Defines the duration between the end of a scan & send sequence and the start of next sequence"),(0,i.yg)("td",{parentName:"tr",align:null},(0,i.yg)("inlineCode",{parentName:"td"},"uint32_t")),(0,i.yg)("td",{parentName:"tr",align:null},"30")))),(0,i.yg)("h3",{id:"gnss-and-wi-fi"},"GNSS and Wi-Fi"),(0,i.yg)("p",null,(0,i.yg)("strong",{parentName:"p"},"Geolocation GNSS and Wi-Fi example"),"\nThis example illustrates the combination of GNSS and Wi-Fi scan procedures:"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"configuration of the LoRa Basics Modem library; and"),(0,i.yg)("li",{parentName:"ul"},"concurrent execution of GNSS and Wi-Fi ",(0,i.yg)("em",{parentName:"li"},"scan & send")," features using the\n",(0,i.yg)("em",{parentName:"li"},"GNSS geolocation middleware")," and the ",(0,i.yg)("em",{parentName:"li"},"Wi-Fi geolocation middleware"),".")),(0,i.yg)("p",null,(0,i.yg)("strong",{parentName:"p"},"Geolocation demonstration related configuration")),(0,i.yg)("p",null,"The ",(0,i.yg)("inlineCode",{parentName:"p"},"main_geolocation_gnss_wifi.h")," header file defines several constants to configure geolocation parameters."),(0,i.yg)("table",null,(0,i.yg)("thead",{parentName:"table"},(0,i.yg)("tr",{parentName:"thead"},(0,i.yg)("th",{parentName:"tr",align:null},"Constant"),(0,i.yg)("th",{parentName:"tr",align:null},"Comments"),(0,i.yg)("th",{parentName:"tr",align:null},"Possible values"),(0,i.yg)("th",{parentName:"tr",align:null},"Default Value"))),(0,i.yg)("tbody",{parentName:"table"},(0,i.yg)("tr",{parentName:"tbody"},(0,i.yg)("td",{parentName:"tr",align:null},(0,i.yg)("inlineCode",{parentName:"td"},"MODEM_EXAMPLE_ASSISTANCE_POSITION_AUTO")),(0,i.yg)("td",{parentName:"tr",align:null},"If set to ",(0,i.yg)("inlineCode",{parentName:"td"},"true"),": configures the application to autonomously get an assistance position"),(0,i.yg)("td",{parentName:"tr",align:null},"{",(0,i.yg)("inlineCode",{parentName:"td"},"true"),",",(0,i.yg)("inlineCode",{parentName:"td"},"false"),"}"),(0,i.yg)("td",{parentName:"tr",align:null},(0,i.yg)("inlineCode",{parentName:"td"},"false"))))),(0,i.yg)("p",null,"If manual mode is selected for assistance position, the following constants define the position to be used."),(0,i.yg)("table",null,(0,i.yg)("thead",{parentName:"table"},(0,i.yg)("tr",{parentName:"thead"},(0,i.yg)("th",{parentName:"tr",align:null},"Constant"),(0,i.yg)("th",{parentName:"tr",align:null},"Comments"),(0,i.yg)("th",{parentName:"tr",align:null},"Possible values"),(0,i.yg)("th",{parentName:"tr",align:null},"Default Value"))),(0,i.yg)("tbody",{parentName:"table"},(0,i.yg)("tr",{parentName:"tbody"},(0,i.yg)("td",{parentName:"tr",align:null},(0,i.yg)("inlineCode",{parentName:"td"},"MODEM_EXAMPLE_ASSISTANCE_POSITION_LAT")),(0,i.yg)("td",{parentName:"tr",align:null},"The latitude to use for GNSS Assisted scan (decimal degree)"),(0,i.yg)("td",{parentName:"tr",align:null},"Any ",(0,i.yg)("inlineCode",{parentName:"td"},"float")," in ","[-90, 90]"),(0,i.yg)("td",{parentName:"tr",align:null},"45.181454")),(0,i.yg)("tr",{parentName:"tbody"},(0,i.yg)("td",{parentName:"tr",align:null},(0,i.yg)("inlineCode",{parentName:"td"},"MODEM_EXAMPLE_ASSISTANCE_POSITION_LONG")),(0,i.yg)("td",{parentName:"tr",align:null},"The longitude to use for GNSS Assisted scan (decimal degree)"),(0,i.yg)("td",{parentName:"tr",align:null},"Any ",(0,i.yg)("inlineCode",{parentName:"td"},"float")," in ","[-180, 180]"),(0,i.yg)("td",{parentName:"tr",align:null},"5.720893")),(0,i.yg)("tr",{parentName:"tbody"},(0,i.yg)("td",{parentName:"tr",align:null},(0,i.yg)("inlineCode",{parentName:"td"},"MODEM_EXAMPLE_ASSISTANCE_POSITION_TEXT")),(0,i.yg)("td",{parentName:"tr",align:null},"A text representation of the assistance position, for information printing only"),(0,i.yg)("td",{parentName:"tr",align:null},"Any constant c-string"),(0,i.yg)("td",{parentName:"tr",align:null},'"Grenoble, FRANCE"')))),(0,i.yg)("p",null,(0,i.yg)("strong",{parentName:"p"},(0,i.yg)("em",{parentName:"strong"},"Note")),": The pre-defined assistance position must be within a 150 km range of the actual location."),(0,i.yg)("table",null,(0,i.yg)("thead",{parentName:"table"},(0,i.yg)("tr",{parentName:"thead"},(0,i.yg)("th",{parentName:"tr",align:null},"Constant"),(0,i.yg)("th",{parentName:"tr",align:null},"Comments"),(0,i.yg)("th",{parentName:"tr",align:null},"Possible values"),(0,i.yg)("th",{parentName:"tr",align:null},"Default Value"))),(0,i.yg)("tbody",{parentName:"table"},(0,i.yg)("tr",{parentName:"tbody"},(0,i.yg)("td",{parentName:"tr",align:null},(0,i.yg)("inlineCode",{parentName:"td"},"GNSS_SCAN_GROUP_PERIOD")),(0,i.yg)("td",{parentName:"tr",align:null},"Defines the duration between the end of a scan & send sequence and the start of next sequence"),(0,i.yg)("td",{parentName:"tr",align:null},(0,i.yg)("inlineCode",{parentName:"td"},"uint32_t")),(0,i.yg)("td",{parentName:"tr",align:null},"30")),(0,i.yg)("tr",{parentName:"tbody"},(0,i.yg)("td",{parentName:"tr",align:null},(0,i.yg)("inlineCode",{parentName:"td"},"GNSS_SCAN_MODE")),(0,i.yg)("td",{parentName:"tr",align:null},"Defines the GNSS scan mode (static or mobile) to be used for scan & send sequences."),(0,i.yg)("td",{parentName:"tr",align:null},"Value in ",(0,i.yg)("inlineCode",{parentName:"td"},"gnss_mw_mode_t")),(0,i.yg)("td",{parentName:"tr",align:null},(0,i.yg)("inlineCode",{parentName:"td"},"GNSS_MW_MODE_MOBILE"))))),(0,i.yg)("p",null,"The GNSS scan mode selected by default is ",(0,i.yg)("inlineCode",{parentName:"p"},"GNSS_MW_MODE_MOBILE"),", meaning that this application example targets mobile objects."),(0,i.yg)("h2",{id:"ble"},"BLE"),(0,i.yg)("p",null,"Low Energy Bluetooth (BLE), also known as Bluetooth Low Energy, is a wireless communication technology designed to provide a low-power and low-complexity communication method for devices that require long-term power supply, low data transfer rates, and short communication distances. Optimized based on Bluetooth technology, BLE has lower power consumption and a simpler protocol stack, making it suitable for low-power and Internet of Things (IoT) applications."),(0,i.yg)("p",null,"The Wio-WM1110 has a Low Energy Bluetooth based on the nRF52840 chip."),(0,i.yg)("p",null,(0,i.yg)("strong",{parentName:"p"},"Testing with the Bluetooth routine")),(0,i.yg)("p",null,"There is a 'Bluetooth: Peripheral UART' sample on the SDK. The test requires that you have connected to the sample and have the connected terminal emulator open."),(0,i.yg)("p",null,"The BLE demo located at:\n",(0,i.yg)("inlineCode",{parentName:"p"},"nRF5_SDK_17.1.0_ddde560/examples/ble_peripheral/ble_app_uart/pca10056/s140/ses/")),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("p",{parentName:"li"},(0,i.yg)("a",{parentName:"p",href:"https://infocenter.nordicsemi.com/index.jsp?topic=%2Fug_gsg_ses%2FUG%2Fgsg%2Ftest_mobile.html"},"Testing with a mobile device"))),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("p",{parentName:"li"},(0,i.yg)("a",{parentName:"p",href:"https://infocenter.nordicsemi.com/index.jsp?topic=%2Fug_gsg_ses%2FUG%2Fgsg%2Ftest_desktop.html"},"Testing with a computer")))),(0,i.yg)("h2",{id:"on-board-sensors"},"On-board Sensors"),(0,i.yg)("h3",{id:"th-sensorsht41"},"TH Sensor(SHT41)"),(0,i.yg)("p",null,"SHT41 is a digital humidity and temperature sensor, it communicates with a microcontroller or other digital device through an I2C interface."),(0,i.yg)("p",null,"The SHT41 sensor is commonly used in a wide range of applications, including HVAC systems, weather stations, indoor air quality monitoring, and industrial process control. Its small size, low power consumption, and high accuracy make it a popular choice for many different types of projects."),(0,i.yg)("table",null,(0,i.yg)("thead",{parentName:"table"},(0,i.yg)("tr",{parentName:"thead"},(0,i.yg)("th",{parentName:"tr",align:null}),(0,i.yg)("th",{parentName:"tr",align:null},"Range"),(0,i.yg)("th",{parentName:"tr",align:null},"Accuracy"))),(0,i.yg)("tbody",{parentName:"table"},(0,i.yg)("tr",{parentName:"tbody"},(0,i.yg)("td",{parentName:"tr",align:null},"Temperature"),(0,i.yg)("td",{parentName:"tr",align:null},"-40~125\xb0C"),(0,i.yg)("td",{parentName:"tr",align:null},"0.2\xb0C")),(0,i.yg)("tr",{parentName:"tbody"},(0,i.yg)("td",{parentName:"tr",align:null},"Humidity"),(0,i.yg)("td",{parentName:"tr",align:null},"0~100%RH"),(0,i.yg)("td",{parentName:"tr",align:null},"1.8%RH")))),(0,i.yg)("p",null,(0,i.yg)("strong",{parentName:"p"},"Code:")),(0,i.yg)("p",null,"This example provides functions for initializing the sensor, reading temperature and humidity values, and setting the temperature unit."),(0,i.yg)("p",null,"Here's a brief summary of the functions defined in this code:"),(0,i.yg)("p",null,(0,i.yg)("strong",{parentName:"p"},"SHT41Init"),": a function that initializes the sensor by resetting it and waiting for 1ms before proceeding."),(0,i.yg)("p",null,(0,i.yg)("strong",{parentName:"p"},"SHT41GetTemperature, SHT41GetHumidity, and SHT41GetTempAndHumi"),": functions for reading temperature and/or humidity values from the sensor. These functions convert the raw sensor values to a float value in degrees Celsius or Fahrenheit, depending on the current temperature unit setting."),(0,i.yg)("p",null,(0,i.yg)("strong",{parentName:"p"},"SHT41SetTemperatureUnit and SHT41GetTemperatureUnit"),": functions for setting and getting the temperature unit.\ncrc8: an internal function that calculates the CRC-8 checksum of a byte array."),(0,i.yg)("h3",{id:"3-axis-accelerometerlis3dhtr"},"3-axis Accelerometer(LIS3DHTR)"),(0,i.yg)("p",null,"The LIS3DHTR is a high-performance sensor that measures acceleration in three dimensions and provides accurate and reliable readings."),(0,i.yg)("p",null,"The LIS3DHTR sensor communicates with a microcontroller or other digital device through an I2C or SPI interface. It also includes advanced features such as programmable interrupts and a wide range of power-saving modes to help minimize power consumption."),(0,i.yg)("table",null,(0,i.yg)("thead",{parentName:"table"},(0,i.yg)("tr",{parentName:"thead"},(0,i.yg)("th",{parentName:"tr",align:null},"Range"),(0,i.yg)("th",{parentName:"tr",align:null},"Bandwidth"),(0,i.yg)("th",{parentName:"tr",align:null},"Sensitivity(LSB/g)"))),(0,i.yg)("tbody",{parentName:"table"},(0,i.yg)("tr",{parentName:"tbody"},(0,i.yg)("td",{parentName:"tr",align:null},"\xb12g, 4g, 8g, 16g"),(0,i.yg)("td",{parentName:"tr",align:null},"0.5Hz ~ 625Hz"),(0,i.yg)("td",{parentName:"tr",align:null},"1000 (\xb12g) ~ 83 (\xb116g)")))),(0,i.yg)("h2",{id:"grove"},"Grove"),(0,i.yg)("p",null,"There are 3 Grove interfaces in the DK, which can be connected to 400+ Grove modules, and supports ADC/UART and IIC transmission protocols."),(0,i.yg)("p",{style:{textAlign:"center"}},(0,i.yg)("img",{src:"https://files.seeedstudio.com/wiki/SenseCAP/Wio-WM1110%20Dev%20Kit/grove_pins.png",alt:"pir",width:600,height:"auto"})),(0,i.yg)("h3",{id:"grove-iic"},"Grove IIC"),(0,i.yg)("p",null,"There is a Grove IIC port on the DK, with ",(0,i.yg)("inlineCode",{parentName:"p"},"SDA")," on pin 27 and ",(0,i.yg)("inlineCode",{parentName:"p"},"SCL")," on pin 26. "),(0,i.yg)("p",{style:{textAlign:"center"}},(0,i.yg)("img",{src:"https://files.seeedstudio.com/wiki/SenseCAP/Wio-WM1110%20Dev%20Kit/Grove_iic.png",alt:"pir",width:300,height:"auto"})),(0,i.yg)("p",null,"To connect to a Grove IIC module, the sensor power must be enabled\uff1a",(0,i.yg)("inlineCode",{parentName:"p"},"I2C_PWR")," (pin 7). This pin controls the pull-up voltage on the IIC signal line:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-cpp"},"#define IIC_POWER          7\n")),(0,i.yg)("p",null,"TWI needs to be enabled in the ",(0,i.yg)("inlineCode",{parentName:"p"},"sdk_config.h")," file before usage."),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-cpp"},"// <e> TWI_ENABLED - nrf_drv_twi - TWI/TWIM peripheral driver - legacy layer\n//==========================================================\n#ifndef TWI_ENABLED\n#define TWI_ENABLED 1\n#endif\n// <e> TWI0_ENABLED - Enable TWI0 instance\n//==========================================================\n#ifndef TWI0_ENABLED\n#define TWI0_ENABLED 1\n#endif\n// <q> TWI0_USE_EASY_DMA  - Use EasyDMA (if present)\n#ifndef TWI0_USE_EASY_DMA\n#define TWI0_USE_EASY_DMA 1\n#endif\n// </e>\n// <e> TWI1_ENABLED - Enable TWI1 instance\n//==========================================================\n#ifndef TWI1_ENABLED\n#define TWI1_ENABLED 1\n#endif\n// <q> TWI1_USE_EASY_DMA  - Use EasyDMA (if present)\n #ifndef TWI1_USE_EASY_DMA\n#define TWI1_USE_EASY_DMA 1\n#endif\n")),(0,i.yg)("p",null,(0,i.yg)("strong",{parentName:"p"},"Example code")),(0,i.yg)("p",null,"This example reads the value of the ",(0,i.yg)("a",{parentName:"p",href:"https://wiki.seeedstudio.com/Grove-SHT4x/"},"SHT41 Temperature and Humidity sensor")," through the IIC interface, and prints it to the serial monitor."),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-cpp"},'#include "nrf_gpio.h"\n#include "nrf_gpiote.h"\n#include "nrf_drv_gpiote.h"\n#include "nrf_delay.h"\n#include "app_error.h"\n#include "sht41.h"\n#include "nrf_drv_twi.h"\n\nint main(void)\n{   \n    float   temp = 0;\n    float   humi = 0;\n    hal_i2c_master_init( );\n    hal_gpio_init_out( SENSOR_POWER, HAL_GPIO_SET ); \n    nrf_delay_ms(10);\n\n    SHT41Init();\n    \n    while(1){\n        SHT41GetTempAndHumi(&temp,&humi);\n        nrf_delay_ms(1000);  \n        printf("temperature:%.3f humidity:%.3f\\n",temp,humi);\n    }\n\n}\n')),(0,i.yg)("p",null,"Then you will get the temperature and humidity values:"),(0,i.yg)("p",{style:{textAlign:"center"}},(0,i.yg)("img",{src:"https://files.seeedstudio.com/wiki/SenseCAP/Wio-WM1110%20Dev%20Kit/valueSHT41.png",alt:"pir",width:500,height:"auto"})),(0,i.yg)("h3",{id:"grove-uart"},"Grove UART"),(0,i.yg)("p",null,"The Wio-WM1110 DK has two UART peripherals, namely ",(0,i.yg)("inlineCode",{parentName:"p"},"uart0")," and ",(0,i.yg)("inlineCode",{parentName:"p"},"uart1"),".  ",(0,i.yg)("inlineCode",{parentName:"p"},"uart0")," pins are connected to the CH340C for debugging purposes, while ",(0,i.yg)("inlineCode",{parentName:"p"},"uart1")," serves as a Grove UART Port."),(0,i.yg)("p",{style:{textAlign:"center"}},(0,i.yg)("img",{src:"https://files.seeedstudio.com/wiki/SenseCAP/Wio-WM1110%20Dev%20Kit/Grove_uart.png",alt:"pir",width:300,height:"auto"})),(0,i.yg)("p",null,"Referring to the schematic, TXD is located on pin 8 and RXD is on pin 6. "),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-cpp"},"#define     LED1                      13\n#define     LED2                      14\n#define     TXD                       8\n#define     RXD                       6\n#define     UART_TX_RX_BUF_SIZE       256\n")),(0,i.yg)("admonition",{title:"Note",type:"tip"},(0,i.yg)("p",{parentName:"admonition"},"Except for analog interfaces like ADC, the nRF52840 chip has fixed pins for other digital peripherals. However, other digital peripherals can be remapped to any pin. For example, the RXD and TXD pin configurations can be swapped.")),(0,i.yg)("p",null,"UART needs to be enabled in the ",(0,i.yg)("inlineCode",{parentName:"p"},"sdk_config.h")," file before usage:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-cpp"},"/ <e> NRFX_UARTE_ENABLED - nrfx_uarte - UARTE peripheral driver\n//==========================================================\n#ifndef NRFX_UARTE_ENABLED\n#define NRFX_UARTE_ENABLED 1\n#endif\n// <o> NRFX_UARTE0_ENABLED - Enable UARTE0 instance \n#ifndef NRFX_UARTE0_ENABLED\n#define NRFX_UARTE0_ENABLED 1\n#endif\n\n// <o> NRFX_UARTE1_ENABLED - Enable UARTE1 instance \n#ifndef NRFX_UARTE1_ENABLED\n#define NRFX_UARTE1_ENABLED 1\n#endif\n\n// <e> UART_ENABLED - nrf_drv_uart - UART/UARTE peripheral driver - legacy layer\n//==========================================================\n#ifndef UART_ENABLED\n#define UART_ENABLED 1\n#endif\n")),(0,i.yg)("p",null,(0,i.yg)("strong",{parentName:"p"},"Example code")),(0,i.yg)("p",null,"The following sample code implements the functions of serial port transmission and reception with feedback."),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-cpp"},'#include "nrf_gpio.h"\n#include "nrf_gpiote.h"\n#include "nrf_drv_gpiote.h"\n#include "nrf_delay.h"\n#include "smtc_hal.h"\n#include "app_uart.h"\n#include "app_error.h"\n#include "nrf_uart.h"\n#include "nrf_drv_uart.h"\n\nstatic void uart_handleEvent( app_uart_evt_t *pEvent );\n\nAPP_UART_DEF( uart, 0, UART_TX_RX_BUF_SIZE, uart_handleEvent );\n\nstatic app_uart_comm_params_t const commParams =\n{\n    .rx_pin_no    = RXD,\n    .tx_pin_no    = TXD,\n    .rts_pin_no   = NRF_UART_PSEL_DISCONNECTED,\n    .cts_pin_no   = NRF_UART_PSEL_DISCONNECTED,                    \n    .flow_control = APP_UART_FLOW_CONTROL_DISABLED,\n    .use_parity   = false,\n    .baud_rate    = NRF_UART_BAUDRATE_115200\n};\n\nvoid uart_tx( uint8_t* buff, uint16_t len )\n{\n        for( uint16_t i = 0; i < len; i++ )\n        {\n            app_uart_put( &uart, buff[i] );\n        }\n}\n\n\nint main(void)\n{\n    uint32_t err_code;\n    uart.comm_params = &commParams;\n    uint8_t arr[] = "hello world\\n";\n    nrf_gpio_cfg_output(LED1);\n    nrf_gpio_cfg_output(LED2);\n    nrf_gpio_pin_clear(LED1);\n    nrf_gpio_pin_clear(LED2);\n    app_uart_init( &uart, &uart_buffers, APP_IRQ_PRIORITY_LOWEST );\n    \n    \n    while( 1 )\n    {\n        nrf_delay_ms(1000);\n        nrf_gpio_pin_toggle(LED2);\n        uart_tx(arr,strlen(arr));\n    }\n}\n            \nvoid uart_handleEvent(app_uart_evt_t * p_event)\n{\n    uint8_t dat;\n    if (p_event->evt_type == APP_UART_COMMUNICATION_ERROR)\n    {\n        APP_ERROR_HANDLER(p_event->data.error_communication);\n    }\n    else if (p_event->evt_type == APP_UART_FIFO_ERROR)\n    {\n        APP_ERROR_HANDLER(p_event->data.error_code);\n    }\n    \n    else if (p_event->evt_type == APP_UART_DATA_READY)\n    {\n        app_uart_get(&uart,&dat); \n        app_uart_put(&uart,dat); \n    }\n    else if (p_event->evt_type == APP_UART_TX_EMPTY) \n    {\n        nrf_gpio_pin_toggle(LED1);\n    }\n}\n')),(0,i.yg)("h3",{id:"grove-adc"},"Grove ADC"),(0,i.yg)("p",null,"There are eight ADC peripherals (0~7) on the DK, ",(0,i.yg)("inlineCode",{parentName:"p"},"ADC6")," and ",(0,i.yg)("inlineCode",{parentName:"p"},"ADC7")," are used as the Grove ADCT Port. "),(0,i.yg)("p",{style:{textAlign:"center"}},(0,i.yg)("img",{src:"https://files.seeedstudio.com/wiki/SenseCAP/Wio-WM1110%20Dev%20Kit/Grove_adc.png",alt:"pir",width:300,height:"auto"})),(0,i.yg)("admonition",{title:"Note",type:"tip"},(0,i.yg)("p",{parentName:"admonition"},"ADC pins are fixed and cannot be remapped.")),(0,i.yg)("p",null,"The corresponding relationships for ADC pins are shown in the table below:"),(0,i.yg)("table",null,(0,i.yg)("thead",{parentName:"table"},(0,i.yg)("tr",{parentName:"thead"},(0,i.yg)("th",{parentName:"tr",align:"center"},"ADC0"),(0,i.yg)("th",{parentName:"tr",align:"center"},"ADC1"),(0,i.yg)("th",{parentName:"tr",align:"center"},"ADC2"),(0,i.yg)("th",{parentName:"tr",align:"center"},"ADC3"),(0,i.yg)("th",{parentName:"tr",align:"center"},"ADC4"),(0,i.yg)("th",{parentName:"tr",align:"center"},"ADC5"),(0,i.yg)("th",{parentName:"tr",align:"center"},"ADC6"),(0,i.yg)("th",{parentName:"tr",align:"center"},"ADC7"))),(0,i.yg)("tbody",{parentName:"table"},(0,i.yg)("tr",{parentName:"tbody"},(0,i.yg)("td",{parentName:"tr",align:"center"},"2"),(0,i.yg)("td",{parentName:"tr",align:"center"},"3"),(0,i.yg)("td",{parentName:"tr",align:"center"},"4"),(0,i.yg)("td",{parentName:"tr",align:"center"},"5"),(0,i.yg)("td",{parentName:"tr",align:"center"},"28"),(0,i.yg)("td",{parentName:"tr",align:"center"},"29"),(0,i.yg)("td",{parentName:"tr",align:"center"},"30"),(0,i.yg)("td",{parentName:"tr",align:"center"},"31")))),(0,i.yg)("p",null,"SAADC needs to be enabled in the ",(0,i.yg)("inlineCode",{parentName:"p"},"sdk_config.h")," file before usage:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-cpp"},"// <e> SAADC_ENABLED - nrf_drv_saadc - SAADC peripheral driver - legacy layer\n//==========================================================\n#ifndef SAADC_ENABLED\n#define SAADC_ENABLED 1\n#endif\n// <e> NRFX_SAADC_ENABLED - nrfx_saadc - SAADC peripheral driver\n//==========================================================\n#ifndef NRFX_SAADC_ENABLED\n#define NRFX_SAADC_ENABLED 1\n#endif\n// <o> SAADC_CONFIG_RESOLUTION  - Resolution\n \n// <0=> 8 bit \n// <1=> 10 bit \n// <2=> 12 bit \n// <3=> 14 bit \n\n#ifndef SAADC_CONFIG_RESOLUTION\n#define SAADC_CONFIG_RESOLUTION 2\n#endif\n")),(0,i.yg)("p",null,(0,i.yg)("strong",{parentName:"p"},"Example code")),(0,i.yg)("p",null,"This is an example program for ADC6, which implements the function of reading the analog input value of a single channel of the ADC6 pin and outputting the measured ADC value through the UART:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-cpp"},'#include "nrf_gpio.h"\n#include "nrf_gpiote.h"\n#include "nrf_drv_gpiote.h"\n#include "nrf_delay.h"\n#include "app_uart.h"\n#include "app_error.h"\n#include "nrf_uart.h"\n#include "nrf_drv_uart.h"\n#include "nrf_drv_saadc.h"\n#define     LED1                     13\n#define     LED2                     14\n#define     TXD                       8\n#define     RXD                       6\n#define     UART_TX_RX_BUF_SIZE       256\n\nstatic void uart_handleEvent( app_uart_evt_t *pEvent );\n\nAPP_UART_DEF( uart, 0, UART_TX_RX_BUF_SIZE, uart_handleEvent );\n\nstatic app_uart_comm_params_t const commParams =\n{\n    .rx_pin_no    = RXD,\n    .tx_pin_no    = TXD,\n    .rts_pin_no   = NRF_UART_PSEL_DISCONNECTED,\n    .cts_pin_no   = NRF_UART_PSEL_DISCONNECTED,                    \n    .flow_control = APP_UART_FLOW_CONTROL_DISABLED,\n    .use_parity   = false,\n    .baud_rate    = NRF_UART_BAUDRATE_115200\n};\n\nvoid uart_tx( uint8_t* buff, uint16_t len )\n{\n        for( uint16_t i = 0; i < len; i++ )\n        {\n            app_uart_put( &uart, buff[i] );\n        }\n}\n\nvoid ADC_Interrupt(nrfx_saadc_evt_t const *p_event){\n    \n}\n\nvoid uart_handleEvent(app_uart_evt_t * p_event)\n{\n    uint8_t dat;\n    if (p_event->evt_type == APP_UART_COMMUNICATION_ERROR)\n    {\n        APP_ERROR_HANDLER(p_event->data.error_communication);\n    }\n    else if (p_event->evt_type == APP_UART_FIFO_ERROR)\n    {\n        APP_ERROR_HANDLER(p_event->data.error_code);\n    }\n    \n    else if (p_event->evt_type == APP_UART_DATA_READY)\n    {\n        app_uart_get(&uart,&dat); \n        //app_uart_put(&uart,dat); \n    }\n    else if (p_event->evt_type == APP_UART_TX_EMPTY) \n    {\n        //nrf_gpio_pin_toggle(LED1);\n    }\n}\n\nint main(void)\n{\n    nrf_saadc_value_t  saadc_val = 0; \n    uint8_t arr[32];\n    nrf_saadc_channel_config_t channel_config = \n    {                                                   \n        .resistor_p = NRF_SAADC_RESISTOR_DISABLED,      \n        .resistor_n = NRF_SAADC_RESISTOR_DISABLED,      \n        .gain       = NRF_SAADC_GAIN1_6,                \n        .reference  = NRF_SAADC_REFERENCE_INTERNAL,     \n        .acq_time   = NRF_SAADC_ACQTIME_10US,           \n        .mode       = NRF_SAADC_MODE_SINGLE_ENDED,      \n        .burst      = NRF_SAADC_BURST_DISABLED,         \n        .pin_p      = NRF_SAADC_INPUT_AIN6,       \n        .pin_n      = NRF_SAADC_INPUT_DISABLED          \n    };\n    \n    nrf_drv_saadc_init(NULL, ADC_Interrupt);\n    nrf_drv_saadc_channel_init(0, &channel_config);\n\n    uart.comm_params = &commParams;\n    app_uart_init( &uart, &uart_buffers, APP_IRQ_PRIORITY_LOWEST );\n\n    nrf_gpio_cfg_output(LED2);\n    while( 1 )\n    {\n        nrf_drv_saadc_sample_convert (0,&saadc_val);\n        sprintf(arr,"value:%d\\n",saadc_val);\n        uart_tx(arr,strlen(arr));\n        nrf_delay_ms(1000);\n        nrf_gpio_pin_toggle(LED2);\n    }\n}\n\n')),(0,i.yg)("h2",{id:"resources"},"Resources"),(0,i.yg)("p",null,(0,i.yg)("a",{parentName:"p",href:"https://github.com/Seeed-Studio/Seeed_Wio_WM1110_Dev_Board"},"Seeed_Wio_WM1110_Dev_Board")),(0,i.yg)("p",null,(0,i.yg)("a",{parentName:"p",href:"https://www.nordicsemi.com/Products/Development-software/nRF5-SDK/Download#infotabs"},"nRF5-SDK")),(0,i.yg)("h2",{id:"tech-support"},"Tech Support"),(0,i.yg)("p",null,(0,i.yg)("strong",{parentName:"p"},"Need help with your Wio-WM1110 Dev Kit? We're here to assist you!")),(0,i.yg)("div",{class:"button_tech_support_container"},(0,i.yg)("a",{href:"https://discord.gg/sensecap",class:"button_tech_support_sensecap"}),(0,i.yg)("a",{href:"https://support.sensecapmx.com/portal/en/home",class:"button_tech_support_sensecap3"})),(0,i.yg)("div",{class:"button_tech_support_container"},(0,i.yg)("a",{href:"mailto:support@sensecapmx.com",class:"button_tech_support_sensecap2"}),(0,i.yg)("a",{href:"https://github.com/Seeed-Solution/SenseCAP_Indicator_ESP32/discussions",class:"button_discussion"})))}u.isMDXComponent=!0}}]);