"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[28211],{15680:(e,t,n)=>{n.d(t,{xA:()=>d,yg:()=>m});var a=n(96540);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var s=a.createContext({}),p=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},d=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},c="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},g=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,s=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),c=p(n),g=i,m=c["".concat(s,".").concat(g)]||c[g]||u[g]||r;return n?a.createElement(m,o(o({ref:t},d),{},{components:n})):a.createElement(m,o({ref:t},d))}));function m(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,o=new Array(r);o[0]=g;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[c]="string"==typeof e?e:i,o[1]=l;for(var p=2;p<r;p++)o[p]=n[p];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}g.displayName="MDXCreateElement"},11710:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>o,default:()=>u,frontMatter:()=>r,metadata:()=>l,toc:()=>p});var a=n(58168),i=(n(96540),n(15680));const r={description:"The code of light is used as an example to introduce the development framework of Matter.",title:"Matter Development Framework Overview",keywords:["matter","XIAO","light"],image:"https://files.seeedstudio.com/wiki/seeed_logo/logo_2023.png",slug:"/matter_development_framework",last_update:{date:"05/15/2024",author:"Citric"}},o="Matter Development Framework Overview",l={unversionedId:"Sensor/SeeedStudio_XIAO/Matter/matter_development_framework_overview",id:"Sensor/SeeedStudio_XIAO/Matter/matter_development_framework_overview",title:"Matter Development Framework Overview",description:"The code of light is used as an example to introduce the development framework of Matter.",source:"@site/docs/Sensor/SeeedStudio_XIAO/Matter/matter_development_framework_overview.md",sourceDirName:"Sensor/SeeedStudio_XIAO/Matter",slug:"/matter_development_framework",permalink:"/matter_development_framework",draft:!1,editUrl:"https://github.com/Seeed-Studio/wiki-documents/blob/docusaurus-version/docs/Sensor/SeeedStudio_XIAO/Matter/matter_development_framework_overview.md",tags:[],version:"current",lastUpdatedBy:"Citric",lastUpdatedAt:1715731200,formattedLastUpdatedAt:"May 15, 2024",frontMatter:{description:"The code of light is used as an example to introduce the development framework of Matter.",title:"Matter Development Framework Overview",keywords:["matter","XIAO","light"],image:"https://files.seeedstudio.com/wiki/seeed_logo/logo_2023.png",slug:"/matter_development_framework",last_update:{date:"05/15/2024",author:"Citric"}},sidebar:"ProductSidebar",previous:{title:"Matter Development with XIAO ESP32 Series",permalink:"/xiao_esp32_matter_env"},next:{title:"PCB Design for XIAO",permalink:"/PCB_Design_XIAO"}},s={},p=[{value:"Tutorial Outline",id:"tutorial-outline",level:2},{value:"Understanding the Light Example",id:"understanding-the-light-example",level:2},{value:"Device Initialisation",id:"device-initialisation",level:2},{value:"Create Matter Node",id:"create-matter-node",level:2},{value:"Sets the Attribute of the Endpoint",id:"sets-the-attribute-of-the-endpoint",level:2},{value:"Create Endpoint &amp; Auto Match Cluster",id:"create-endpoint--auto-match-cluster",level:2},{value:"Setting up the Matter device for the first time with default values",id:"setting-up-the-matter-device-for-the-first-time-with-default-values",level:2},{value:"Data updates and deferred persistence",id:"data-updates-and-deferred-persistence",level:2},{value:"Defining your own data model",id:"defining-your-own-data-model",level:2},{value:"Endpoints",id:"endpoints",level:4},{value:"Clusters",id:"clusters",level:3},{value:"Attributes and Commands",id:"attributes-and-commands",level:3},{value:"Features",id:"features",level:3},{value:"Adding custom data model fields",id:"adding-custom-data-model-fields",level:3},{value:"Endpoints",id:"endpoints-1",level:4},{value:"Clusters",id:"clusters-1",level:4},{value:"Attributes and Commands",id:"attributes-and-commands-1",level:4},{value:"Tech Support &amp; Product Discussion",id:"tech-support--product-discussion",level:2}],d={toc:p},c="wrapper";function u(e){let{components:t,...n}=e;return(0,i.yg)(c,(0,a.A)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,i.yg)("h1",{id:"matter-development-framework-overview"},"Matter Development Framework Overview"),(0,i.yg)("admonition",{type:"tip"},(0,i.yg)("p",{parentName:"admonition"},"This article is the fourth tutorial in the Seeed Studio XIAO ESP32 Development Matter series. If you have not read the previous tutorials, we recommend that you read them first to check that your device is and has been configured as required."),(0,i.yg)("ul",{parentName:"admonition"},(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("strong",{parentName:"li"},(0,i.yg)("a",{parentName:"strong",href:"https://wiki.seeedstudio.com/xiao_idf"},"Developed on XIAO using Espressif ESP-IDF"))),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("strong",{parentName:"li"},(0,i.yg)("a",{parentName:"strong",href:"https://wiki.seeedstudio.com/getting_started_with_matter"},"Getting Started with Matter Quickly with XIAO ESP32 Series"))),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("strong",{parentName:"li"},(0,i.yg)("a",{parentName:"strong",href:"https://wiki.seeedstudio.com/xiao_esp32_matter_env/"},"Matter Development with XIAO ESP32 Series"))))),(0,i.yg)("p",null,"Embark on an illuminating journey into the world of Matter development with our comprehensive tutorial. Through the lens of the quintessential light example, we'll shed light on the fundamental concepts and knowledge that form the bedrock of Matter development. From clusters and attributes to commands and beyond, this tutorial will equip you with the tools to navigate the Matter framework with confidence. Get ready to flip the switch on your Matter development skills and let's dive into the brilliant world of connected devices!"),(0,i.yg)("h2",{id:"tutorial-outline"},"Tutorial Outline"),(0,i.yg)("ol",null,(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("strong",{parentName:"li"},(0,i.yg)("a",{parentName:"strong",href:"#understanding-the-light-example"},"Understanding the Light Example"))),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("strong",{parentName:"li"},(0,i.yg)("a",{parentName:"strong",href:"#device-initialisation"},"Device Initialisation"))),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("strong",{parentName:"li"},(0,i.yg)("a",{parentName:"strong",href:"#create-matter-node"},"Create Matter Node"))),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("strong",{parentName:"li"},(0,i.yg)("a",{parentName:"strong",href:"#sets-the-attribute-of-the-endpoint"},"Sets the Attribute of the Endpoint"))),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("strong",{parentName:"li"},(0,i.yg)("a",{parentName:"strong",href:"#create-endpoint--auto-match-cluster"},"Create Endpoint & Auto Match Cluster"))),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("strong",{parentName:"li"},(0,i.yg)("a",{parentName:"strong",href:"#setting-up-the-matter-device-for-the-first-time-with-default-values"},"Setting up the Matter device for the first time with default values"))),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("strong",{parentName:"li"},(0,i.yg)("a",{parentName:"strong",href:"#data-updates-and-deferred-persistence"},"Data updates and deferred persistence")))),(0,i.yg)("p",null,"In this section, we will focus on the ",(0,i.yg)("a",{parentName:"p",href:"https://github.com/espressif/esp-matter/tree/main/examples/light"},"light")," example provided in ESP-Matter, which describes in detail the basic concepts of clusters, attributes and commands in the Matter development framework. By reading this article, you will be able to gain a better understanding of the structure and awareness of the Matter development framework."),(0,i.yg)("h2",{id:"understanding-the-light-example"},"Understanding the Light Example"),(0,i.yg)("p",null,"First, let's look at the file directories in the ESP-Matter environment and what they do."),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre"},"- esp-matter/\n   - components/\n      - esp_matter\n      - esp_matter_bridge\n      - esp_matter_console\n      - esp_matter_controller\n      - esp_matter_rainmaker\n      - esp_matter_thread_br\n   - connectedhomeip/\n   - device_hal/\n      - button_driver\n      - device\n      - led_driver\n   - docs/\n   - examples/\n   - tools/\n      - mfg_tool\n   CMakeLists.txt\n   RELEASE_NOTES.md\n   export.sh\n   install.sh\n   requirements.txt\n   ...\n")),(0,i.yg)("p",null,(0,i.yg)("strong",{parentName:"p"},"esp-matter"),": This is the root directory of the entire Matter development framework."),(0,i.yg)("p",null,(0,i.yg)("strong",{parentName:"p"},"components"),": This directory contains various components and is the core of the Matter framework."),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"esp_matter: This is the implementation of the Matter protocol stack on ESP32, including the data model, application layer logic, etc."),(0,i.yg)("li",{parentName:"ul"},"esp_matter_bridge: This component is responsible for bridging ESP devices to other non-ESP devices, achieving interoperability."),(0,i.yg)("li",{parentName:"ul"},"esp_matter_console: This is an interactive console based on REPL, used for debugging and controlling Matter devices."),(0,i.yg)("li",{parentName:"ul"},"esp_matter_controller: This component implements the functionality of a Matter controller, capable of controlling other Matter devices."),(0,i.yg)("li",{parentName:"ul"},"esp_matter_rainmaker: This component integrates with Espressif's RainMaker cloud platform, enabling cloud control."),(0,i.yg)("li",{parentName:"ul"},"esp_matter_thread_br: This component implements the Thread Border Router functionality, used for creating Thread networks.")),(0,i.yg)("p",null,(0,i.yg)("strong",{parentName:"p"},"connectedhomeip"),": This is the upstream open-source project of the Matter protocol stack, from which ESP Matter syncs its code."),(0,i.yg)("p",null,(0,i.yg)("strong",{parentName:"p"},"device_hal"),": This directory contains the hardware abstraction layer drivers."),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"button_driver: Button driver."),(0,i.yg)("li",{parentName:"ul"},"device: Device abstraction, defining generic device interfaces."),(0,i.yg)("li",{parentName:"ul"},"led_driver: LED driver.")),(0,i.yg)("p",null,(0,i.yg)("strong",{parentName:"p"},"docs"),": This is where ESP-Matter development documents and API reference manuals are stored."),(0,i.yg)("p",null,(0,i.yg)("strong",{parentName:"p"},"examples"),": Various example codes demonstrating how to use the Matter framework for development."),(0,i.yg)("p",null,(0,i.yg)("strong",{parentName:"p"},"tools"),": Contains various development tool scripts."),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"mfg_tool: Tool for generating manufacturer certificates.")),(0,i.yg)("p",null,(0,i.yg)("strong",{parentName:"p"},"CMakeLists.txt"),": CMake build script, defining the compilation rules for the project."),(0,i.yg)("p",null,(0,i.yg)("strong",{parentName:"p"},"RELEASE_NOTES.md"),": Release notes, recording the changes in each version."),(0,i.yg)("p",null,(0,i.yg)("strong",{parentName:"p"},"export.sh"),": Export script, used to export Matter-related environment variables."),(0,i.yg)("p",null,(0,i.yg)("strong",{parentName:"p"},"install.sh"),": Installation script, used to install the dependencies and toolchains required for Matter development."),(0,i.yg)("p",null,(0,i.yg)("strong",{parentName:"p"},"requirements.txt"),": Python dependencies list, specifying the Python libraries needed to run the Matter development framework."),(0,i.yg)("p",null,"This directory structure reflects the modular design philosophy of the Matter development framework. The core protocol stack, hardware abstraction, application components, auxiliary tools, and other parts each have their own responsibilities while being organically combined, providing developers with a complete Matter development environment."),(0,i.yg)("p",null,"Taking ",(0,i.yg)("strong",{parentName:"p"},"examples/light")," as an example, the structure of the example provided by ESP-Matter is as follows:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre"},"- light/\n   - main/\n      - CMakeLists.txt\n      - app_driver.cpp\n      - app_main.cpp\n      - app_priv.h\n      - idf_components.yml\n   CMakeLists.txt\n   README.md\n   partitions.csv\n   sdkconfig.defaults\n   ...\n")),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("p",{parentName:"li"},(0,i.yg)("strong",{parentName:"p"},"main"),": This subdirectory contains the main application code and configuration files."),(0,i.yg)("ul",{parentName:"li"},(0,i.yg)("li",{parentName:"ul"},"CMakeLists.txt: The CMake build script for the main application."),(0,i.yg)("li",{parentName:"ul"},"app_driver.cpp: The driver code for the light application."),(0,i.yg)("li",{parentName:"ul"},"app_main.cpp: The main entry point of the light application."),(0,i.yg)("li",{parentName:"ul"},"app_priv.h: A header file containing private declarations for the light application."),(0,i.yg)("li",{parentName:"ul"},"idf_components.yml: A configuration file for the ESP-IDF components used in the light application."))),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("p",{parentName:"li"},(0,i.yg)("strong",{parentName:"p"},"CMakeLists.txt"),": The top-level CMake build script for the light example.")),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("p",{parentName:"li"},(0,i.yg)("strong",{parentName:"p"},"README.md"),": A readme file providing information and instructions for the light example.")),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("p",{parentName:"li"},(0,i.yg)("strong",{parentName:"p"},"partitions.csv"),": A file defining the partition table for the light example.")),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("p",{parentName:"li"},(0,i.yg)("strong",{parentName:"p"},"sdkconfig.defaults"),": Default configuration settings for the light example."))),(0,i.yg)("h2",{id:"device-initialisation"},"Device Initialisation"),(0,i.yg)("p",null,"Next, we go into light's code to deepen our understanding of Matter's development process through a combination of code analysis and theory. The following code is in ",(0,i.yg)("a",{parentName:"p",href:"https://github.com/espressif/esp-matter/blob/main/examples/light/main/app_main.cpp"},"manin/app_main.cpp"),"."),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-cpp"},"app_driver_handle_t light_handle = app_driver_light_init();\napp_driver_handle_t button_handle = app_driver_button_init();\napp_reset_button_register(button_handle);\n")),(0,i.yg)("p",null,(0,i.yg)("inlineCode",{parentName:"p"},"app_driver_handle_t light_handle = app_driver_light_init();"),": This line initializes the light driver and returns a handle to the light driver instance."),(0,i.yg)("p",null,(0,i.yg)("inlineCode",{parentName:"p"},"app_driver_handle_t button_handle = app_driver_button_init();"),": Similar to the light initialization, this line initializes the button driver."),(0,i.yg)("p",null,(0,i.yg)("inlineCode",{parentName:"p"},"app_reset_button_register(button_handle);"),": This line registers the button for a specific functionality, to handle reset operations."),(0,i.yg)("p",null,"Take the ",(0,i.yg)("inlineCode",{parentName:"p"},"app_driver_light_init()")," function as an example, the following program initialises all the light bulbs, but only uses the first one (set to the default colour and brightness values). This is also the reason why the example programme can only use one light bulb."),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-cpp"},"// app_driver.cpp\napp_driver_handle_t app_driver_light_init()\n{\n#if CONFIG_BSP_LEDS_NUM > 0\n    /* Initialize led */\n    led_indicator_handle_t leds[CONFIG_BSP_LEDS_NUM];\n    ESP_ERROR_CHECK(bsp_led_indicator_create(leds, NULL, CONFIG_BSP_LEDS_NUM));\n    led_indicator_set_hsv(leds[0], SET_HSV(DEFAULT_HUE, DEFAULT_SATURATION, DEFAULT_BRIGHTNESS));\n    \n    return (app_driver_handle_t)leds[0];\n#else\n    return NULL;\n#endif\n}\n")),(0,i.yg)("h2",{id:"create-matter-node"},"Create Matter Node"),(0,i.yg)("p",null,"The next step in the main line of code for Matter device configuration is to create a Matter Node. the code is as follows:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-cpp"},'node::config_t node_config;\n\n// node handle can be used to add/modify other endpoints.\nnode_t *node = node::create(&node_config, app_attribute_update_cb, app_identification_cb);\nABORT_APP_ON_FAILURE(node != nullptr, ESP_LOGE(TAG, "Failed to create Matter node"));\n')),(0,i.yg)("p",null,"The Matter data model is a standardized way of representing and organizing data within the Matter ecosystem. It defines a common language and structure for devices, attributes, and interactions, enabling interoperability and seamless communication among Matter-compatible devices."),(0,i.yg)("p",null,"The following diagram shows a simplistic view of how this can be represented in the Matter\u2019s data model."),(0,i.yg)("div",{style:{textAlign:"center"}},(0,i.yg)("img",{src:"https://files.seeedstudio.com/wiki/xiaoc6-matter/34.png",style:{width:600,height:"auto"}})),(0,i.yg)("p",null,(0,i.yg)("strong",{parentName:"p"},"Matter Node"),":\nA Matter Node represents a physical device or a logical entity within the Matter ecosystem. It is the top-level component of the Matter data model. Each Matter Node has a unique identifier and can contain one or more Endpoints."),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"A Matter Node represents ",(0,i.yg)("strong",{parentName:"li"},"a physical device")," in the Matter ecosystem."),(0,i.yg)("li",{parentName:"ul"},"It's like a house that can contain multiple Endpoints (rooms)."),(0,i.yg)("li",{parentName:"ul"},"Each Matter Node has its own unique identifier for recognition and addressing within the network.")),(0,i.yg)("h2",{id:"sets-the-attribute-of-the-endpoint"},"Sets the Attribute of the Endpoint"),(0,i.yg)("p",null,"Once the Matter Node has been created, it is necessary to set default values for the properties of the Endpoints."),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-cpp"},"extended_color_light::config_t light_config;\nlight_config.on_off.on_off = DEFAULT_POWER;\nlight_config.on_off.lighting.start_up_on_off = nullptr;\nlight_config.level_control.current_level = DEFAULT_BRIGHTNESS;\nlight_config.level_control.lighting.start_up_current_level = DEFAULT_BRIGHTNESS;\nlight_config.color_control.color_mode = (uint8_t)ColorControl::ColorMode::kColorTemperature;\nlight_config.color_control.enhanced_color_mode = (uint8_t)ColorControl::ColorMode::kColorTemperature;\nlight_config.color_control.color_temperature.startup_color_temperature_mireds = nullptr;\n")),(0,i.yg)("ol",null,(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},(0,i.yg)("inlineCode",{parentName:"p"},"light_config.on_off.on_off = DEFAULT_POWER;")),(0,i.yg)("ul",{parentName:"li"},(0,i.yg)("li",{parentName:"ul"},"Sets the initial on/off state of the endpoint to ",(0,i.yg)("inlineCode",{parentName:"li"},"DEFAULT_POWER"),"."),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"DEFAULT_POWER")," is a predefined constant representing the default power state (e.g., ",(0,i.yg)("inlineCode",{parentName:"li"},"true")," for on, ",(0,i.yg)("inlineCode",{parentName:"li"},"false")," for off)."))),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},(0,i.yg)("inlineCode",{parentName:"p"},"light_config.on_off.lighting.start_up_on_off = nullptr;")),(0,i.yg)("ul",{parentName:"li"},(0,i.yg)("li",{parentName:"ul"},"Sets the start-up on/off state of the endpoint to ",(0,i.yg)("inlineCode",{parentName:"li"},"nullptr"),"."),(0,i.yg)("li",{parentName:"ul"},"When the device restarts or power cycles, if this value is ",(0,i.yg)("inlineCode",{parentName:"li"},"nullptr"),", it means to use the last on/off state."),(0,i.yg)("li",{parentName:"ul"},"If set to a non-",(0,i.yg)("inlineCode",{parentName:"li"},"nullptr")," value, it indicates to use the specified on/off state."))),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},(0,i.yg)("inlineCode",{parentName:"p"},"light_config.level_control.current_level = DEFAULT_BRIGHTNESS;")),(0,i.yg)("ul",{parentName:"li"},(0,i.yg)("li",{parentName:"ul"},"Sets the initial brightness level of the endpoint to ",(0,i.yg)("inlineCode",{parentName:"li"},"DEFAULT_BRIGHTNESS")," (64)."),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"DEFAULT_BRIGHTNESS")," is a predefined constant representing the default brightness level (e.g., a value between 0 and 254)."))),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},(0,i.yg)("inlineCode",{parentName:"p"},"light_config.level_control.lighting.start_up_current_level = DEFAULT_BRIGHTNESS;")),(0,i.yg)("ul",{parentName:"li"},(0,i.yg)("li",{parentName:"ul"},"Sets the start-up brightness level of the endpoint to ",(0,i.yg)("inlineCode",{parentName:"li"},"DEFAULT_BRIGHTNESS")," (64)."),(0,i.yg)("li",{parentName:"ul"},"When the device restarts or power cycles, if this value is non-",(0,i.yg)("inlineCode",{parentName:"li"},"nullptr"),", it means to use the specified brightness level."),(0,i.yg)("li",{parentName:"ul"},"If set to ",(0,i.yg)("inlineCode",{parentName:"li"},"nullptr"),", it indicates to use the last brightness level."))),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},(0,i.yg)("inlineCode",{parentName:"p"},"light_config.color_control.color_mode = (uint8_t)ColorControl::ColorMode::kColorTemperature;")),(0,i.yg)("ul",{parentName:"li"},(0,i.yg)("li",{parentName:"ul"},"Sets the color mode of the endpoint to ",(0,i.yg)("inlineCode",{parentName:"li"},"ColorControl::ColorMode::kColorTemperature"),"."),(0,i.yg)("li",{parentName:"ul"},"This means the endpoint uses color temperature mode, where the color of the light is controlled by adjusting the color temperature."),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"(uint8_t)")," is a type cast that converts the enum value to an unsigned 8-bit integer."))),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},(0,i.yg)("inlineCode",{parentName:"p"},"light_config.color_control.enhanced_color_mode = (uint8_t)ColorControl::ColorMode::kColorTemperature;")),(0,i.yg)("ul",{parentName:"li"},(0,i.yg)("li",{parentName:"ul"},"Sets the enhanced color mode of the endpoint to ",(0,i.yg)("inlineCode",{parentName:"li"},"ColorControl::ColorMode::kColorTemperature"),"."),(0,i.yg)("li",{parentName:"ul"},"The enhanced color mode provides more color control options, but here it is also set to color temperature mode."))),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},(0,i.yg)("inlineCode",{parentName:"p"},"light_config.color_control.color_temperature.startup_color_temperature_mireds = nullptr;")),(0,i.yg)("ul",{parentName:"li"},(0,i.yg)("li",{parentName:"ul"},"Sets the start-up color temperature of the endpoint to ",(0,i.yg)("inlineCode",{parentName:"li"},"nullptr"),"."),(0,i.yg)("li",{parentName:"ul"},"When the device restarts or power cycles, if this value is ",(0,i.yg)("inlineCode",{parentName:"li"},"nullptr"),", it means to use the last color temperature setting."),(0,i.yg)("li",{parentName:"ul"},"If set to a non-",(0,i.yg)("inlineCode",{parentName:"li"},"nullptr")," value, it indicates to use the specified color temperature value.")))),(0,i.yg)("p",null,"Attributes in Matter are like properties or characteristics of a device. They store information about the device's state, such as whether it's on or off, its brightness level, or its color temperature. These attributes are organized into groups called Clusters, which are related to specific functions of the device."),(0,i.yg)("p",null,"Attributes make it easier for different devices and apps to communicate and work together seamlessly. By having a standard way to represent and access device properties, Matter simplifies the development of smart home systems and ensures that devices from various brands can interact with each other efficiently."),(0,i.yg)("p",null,(0,i.yg)("inlineCode",{parentName:"p"},"esp_matter_endpoint.h")," is an important header file in the ESP Matter SDK that defines constants, data types, and functions related to endpoints. In Matter, endpoints represent the logical interfaces of a device, and each endpoint contains a set of attributes and commands that describe and control specific functionalities of the device."),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-cpp"},"namespace extended_color_light {\ntypedef struct config {\n    cluster::descriptor::config_t descriptor;\n    cluster::identify::config_t identify;\n    cluster::groups::config_t groups;\n    cluster::scenes_management::config_t scenes_management;\n    cluster::on_off::config_t on_off;\n    cluster::level_control::config_t level_control;\n    cluster::color_control::config_t color_control;\n} config_t;\n\nuint32_t get_device_type_id();\nuint8_t get_device_type_version();\nendpoint_t *create(node_t *node, config_t *config, uint8_t flags, void *priv_data);\nesp_err_t add(endpoint_t *endpoint, config_t *config);\n} /* extended_color_light */\n")),(0,i.yg)("h2",{id:"create-endpoint--auto-match-cluster"},"Create Endpoint & Auto Match Cluster"),(0,i.yg)("p",null,"In the above, we first mentioned two terms that are important in Matter, Endpoints and Clusters."),(0,i.yg)("div",{style:{textAlign:"center"}},(0,i.yg)("img",{src:"https://files.seeedstudio.com/wiki/xiaoc6-matter/35.png",style:{width:500,height:"auto"}})),(0,i.yg)("p",null,(0,i.yg)("strong",{parentName:"p"},"Endpoint(s) ","[Device-Type(s)]"),":\nAn Endpoint is a logical representation of a specific functionality or service within a Matter Node. It encapsulates a set of capabilities and behaviors related to a particular device type. A Matter Node can have multiple Endpoints, each representing a different device type. Device-Type(s) define the specific characteristics and functionality of an Endpoint. Matter defines a set of standard device types, such as light bulbs, thermostats, door locks, and more. Each device type has a unique identifier and a predefined set of clusters, attributes, and commands associated with it."),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"An Endpoint is a logical component within a Matter Node, representing a specific functionality or service of the device."),(0,i.yg)("li",{parentName:"ul"},"Just like rooms in a house, each Endpoint has its own dedicated purpose, such as a bedroom, kitchen, or living room."),(0,i.yg)("li",{parentName:"ul"},"Each Endpoint is associated with a specific device type, like a light bulb, thermostat, or door lock."),(0,i.yg)("li",{parentName:"ul"},"A Matter Node can have multiple Endpoints, each representing a different device type and functionality.")),(0,i.yg)("p",null,(0,i.yg)("strong",{parentName:"p"},"Cluster(s)"),':\nClusters are logical groupings of related attributes and commands within an Endpoint. They represent a specific functionality or feature of a device. Clusters provide a way to organize and categorize the capabilities of an Endpoint. For example, the "On/Off Cluster" contains attributes and commands related to turning a device on or off, while the "Level Control Cluster" deals with controlling the brightness or level of a device.'),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"A Cluster is a logical grouping within an Endpoint, containing related attributes and commands."),(0,i.yg)("li",{parentName:"ul"},"It's like the furniture or devices in a room, such as lights, televisions, or air conditioners, each with their own attributes and operations."),(0,i.yg)("li",{parentName:"ul"},"Each Cluster represents a specific functionality or feature of the device."),(0,i.yg)("li",{parentName:"ul"},'For example, the "On/Off Cluster" contains attributes and commands related to the on/off state of the device, while the "Level Control Cluster" contains attributes and commands for adjusting the brightness or level of the device.'),(0,i.yg)("li",{parentName:"ul"},"An Endpoint can have multiple Clusters, each responsible for different functionalities.")),(0,i.yg)("p",null,"In summary, a Matter Node is like a house, containing multiple Endpoints (rooms). Each Endpoint is like a room, representing a specific functionality or service of the device. Clusters are like the furniture or devices in each room, containing related attributes and commands for control and interaction."),(0,i.yg)("p",null,"This hierarchical organization allows devices to clearly describe their functionalities and characteristics, making it easier for applications and other devices to interact with and control them. By standardizing device types, Clusters, attributes, and commands, Matter enables interoperability and compatibility between devices from different manufacturers."),(0,i.yg)("p",null,"In the code, after setting the Attributes, an Endpoint is finally created by the following snippet. And it automatically matches the Cluster of the set attribute."),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-cpp"},'endpoint_t *endpoint = extended_color_light::create(node, &light_config, ENDPOINT_FLAG_NONE, light_handle);\nABORT_APP_ON_FAILURE(endpoint != nullptr, ESP_LOGE(TAG, "Failed to create extended color light endpoint"));\n')),(0,i.yg)("p",null,"How is auto-matching clustering achieved? Let's take an example of a snippet that sets an attribute."),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-cpp"},"light_config.level_control.lighting.start_up_current_level = DEFAULT_BRIGHTNESS;\n")),(0,i.yg)("p",null,(0,i.yg)("inlineCode",{parentName:"p"},"light_config.level_control")," is an Attribute defined in Endpoint (esp_matter_endpoint.h). And ",(0,i.yg)("inlineCode",{parentName:"p"},"light_config.level_control.lighting")," is a Attribute defined in Cluster (esp_matter_cluster). With this setting, the system can automatically match the Cluster corresponding to the Attribute without the need for developers to set them manually."),(0,i.yg)("h2",{id:"setting-up-the-matter-device-for-the-first-time-with-default-values"},"Setting up the Matter device for the first time with default values"),(0,i.yg)("p",null,"Once the above Attributes, Clusters and Endpoints have been configured, we can start booting the Matter appliance. The steps and methodology for startup are as follows."),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-cpp"},'light_endpoint_id = endpoint::get_id(endpoint);\nESP_LOGI(TAG, "Light created with endpoint_id %d", light_endpoint_id);\n\n/* Matter start */\nerr = esp_matter::start(app_event_cb);\nABORT_APP_ON_FAILURE(err == ESP_OK, ESP_LOGE(TAG, "Failed to start Matter, err:%d", err));\n\n/* Starting driver with default values \u4f7f\u7528\u9ed8\u8ba4\u503c\u542f\u52a8\u9a71\u52a8\u7a0b\u5e8f */\napp_driver_light_set_defaults(light_endpoint_id);\n')),(0,i.yg)("p",null,"As you can see, the function to set the defaults is ",(0,i.yg)("inlineCode",{parentName:"p"},"app_driver_light_set_defaults()"),", and we need to pass in an endpoint ID as a parameter. And we need to be concerned about how to get the value of a certain cluster, a certain attribute, and how to set the default cluster, attribute value. The secrets are shown in the ",(0,i.yg)("inlineCode",{parentName:"p"},"app_driver.cpp"),"."),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-cpp"},"esp_err_t err = ESP_OK;\nvoid *priv_data = endpoint::get_priv_data(endpoint_id);\nled_indicator_handle_t handle = (led_indicator_handle_t)priv_data;\nnode_t *node = node::get();\nendpoint_t *endpoint = endpoint::get(node, endpoint_id);\ncluster_t *cluster = NULL;\nattribute_t *attribute = NULL;\nesp_matter_attr_val_t val = esp_matter_invalid(NULL);\n\n/* Setting brightness */\ncluster = cluster::get(endpoint, LevelControl::Id);\nattribute = attribute::get(cluster, LevelControl::Attributes::CurrentLevel::Id);\nattribute::get_val(attribute, &val);\nerr |= app_driver_light_set_brightness(handle, &val);\n")),(0,i.yg)("ol",null,(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"Obtaining a Cluster:"),(0,i.yg)("ul",{parentName:"li"},(0,i.yg)("li",{parentName:"ul"},"To obtain a cluster, you first need to get a pointer to the endpoint using the ",(0,i.yg)("inlineCode",{parentName:"li"},"endpoint::get(node, endpoint_id)")," function, where ",(0,i.yg)("inlineCode",{parentName:"li"},"node")," is a pointer to the node and ",(0,i.yg)("inlineCode",{parentName:"li"},"endpoint_id")," is the ID of the endpoint."),(0,i.yg)("li",{parentName:"ul"},"Once you have the endpoint pointer, you can get a pointer to the desired cluster using the ",(0,i.yg)("inlineCode",{parentName:"li"},"cluster::get(endpoint, LevelControl::Id)")," function, specifying the endpoint and the cluster ID (",(0,i.yg)("inlineCode",{parentName:"li"},"LevelControl::Id")," in this case)."))),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"Getting a Specific Attribute:"),(0,i.yg)("ul",{parentName:"li"},(0,i.yg)("li",{parentName:"ul"},"After obtaining the cluster pointer, you can get a pointer to a specific attribute within that cluster using the ",(0,i.yg)("inlineCode",{parentName:"li"},"attribute::get(cluster, LevelControl::Attributes::CurrentLevel::Id)")," function."),(0,i.yg)("li",{parentName:"ul"},"In this example, we are retrieving the ",(0,i.yg)("inlineCode",{parentName:"li"},"CurrentLevel")," attribute from the ",(0,i.yg)("inlineCode",{parentName:"li"},"LevelControl")," cluster."))),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"Retrieving the Attribute's Value:"),(0,i.yg)("ul",{parentName:"li"},(0,i.yg)("li",{parentName:"ul"},"To retrieve the current value of an attribute, you need to declare a variable of type ",(0,i.yg)("inlineCode",{parentName:"li"},"esp_matter_attr_val_t")," to store the attribute value."),(0,i.yg)("li",{parentName:"ul"},"In the code snippet, the variable ",(0,i.yg)("inlineCode",{parentName:"li"},"val")," is initialized with ",(0,i.yg)("inlineCode",{parentName:"li"},"esp_matter_invalid(NULL)"),"."),(0,i.yg)("li",{parentName:"ul"},"Then, you can use the ",(0,i.yg)("inlineCode",{parentName:"li"},"attribute::get_val(attribute, &val)")," function to fetch the current value of the attribute and store it in the ",(0,i.yg)("inlineCode",{parentName:"li"},"val")," variable."))),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"Setting the Brightness of a Light:"),(0,i.yg)("ul",{parentName:"li"},(0,i.yg)("li",{parentName:"ul"},"To set the brightness of a light, you need to have a handle to the LED indicator associated with the endpoint."),(0,i.yg)("li",{parentName:"ul"},"In the code snippet, the LED indicator handle is obtained by casting the private data pointer (",(0,i.yg)("inlineCode",{parentName:"li"},"priv_data"),") to the appropriate type (",(0,i.yg)("inlineCode",{parentName:"li"},"led_indicator_handle_t"),")."),(0,i.yg)("li",{parentName:"ul"},"Finally, you can call the ",(0,i.yg)("inlineCode",{parentName:"li"},"app_driver_light_set_brightness(handle, &val)")," function to set the brightness of the LED indicator."),(0,i.yg)("li",{parentName:"ul"},"The ",(0,i.yg)("inlineCode",{parentName:"li"},"handle")," parameter is the LED indicator handle, and ",(0,i.yg)("inlineCode",{parentName:"li"},"&val")," is a pointer to the ",(0,i.yg)("inlineCode",{parentName:"li"},"esp_matter_attr_val_t")," variable containing the desired brightness value.")))),(0,i.yg)("p",null,"Here's a summary of the steps:"),(0,i.yg)("ol",null,(0,i.yg)("li",{parentName:"ol"},"Get the endpoint pointer using ",(0,i.yg)("inlineCode",{parentName:"li"},"endpoint::get(node, endpoint_id)"),"."),(0,i.yg)("li",{parentName:"ol"},"Get the cluster pointer using ",(0,i.yg)("inlineCode",{parentName:"li"},"cluster::get(endpoint, LevelControl::Id)"),"."),(0,i.yg)("li",{parentName:"ol"},"Get the attribute pointer using ",(0,i.yg)("inlineCode",{parentName:"li"},"attribute::get(cluster, LevelControl::Attributes::CurrentLevel::Id)"),"."),(0,i.yg)("li",{parentName:"ol"},"Retrieve the attribute's current value using ",(0,i.yg)("inlineCode",{parentName:"li"},"attribute::get_val(attribute, &val)"),"."),(0,i.yg)("li",{parentName:"ol"},"Set the brightness of the light using ",(0,i.yg)("inlineCode",{parentName:"li"},"app_driver_light_set_brightness(handle, &val)"),", where ",(0,i.yg)("inlineCode",{parentName:"li"},"handle")," is the LED indicator handle associated with the endpoint.")),(0,i.yg)("p",null,"By following these steps, you can obtain the necessary pointers to the cluster and attribute, retrieve the current value of the attribute, and set the brightness of the light accordingly."),(0,i.yg)("h2",{id:"data-updates-and-deferred-persistence"},"Data updates and deferred persistence"),(0,i.yg)("p",null,"In the code of ",(0,i.yg)("inlineCode",{parentName:"p"},"app_driver.cpp"),", the values of the attributes are updated by using the ",(0,i.yg)("inlineCode",{parentName:"p"},"app_driver_attribute_update()")," function."),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-cpp"},"if (endpoint_id == light_endpoint_id) {\n   led_indicator_handle_t handle = (led_indicator_handle_t)driver_handle;\n   if (cluster_id == OnOff::Id) {\n      if (attribute_id == OnOff::Attributes::OnOff::Id) {\n            err = app_driver_light_set_power(handle, val);\n      }\n   } else if (cluster_id == LevelControl::Id) {\n      if (attribute_id == LevelControl::Attributes::CurrentLevel::Id) {\n            err = app_driver_light_set_brightness(handle, val);\n      }\n   } else if (cluster_id == ColorControl::Id) {\n      if (attribute_id == ColorControl::Attributes::CurrentHue::Id) {\n            err = app_driver_light_set_hue(handle, val);\n      } else if (attribute_id == ColorControl::Attributes::CurrentSaturation::Id) {\n            err = app_driver_light_set_saturation(handle, val);\n      } else if (attribute_id == ColorControl::Attributes::ColorTemperatureMireds::Id) {\n            err = app_driver_light_set_temperature(handle, val);\n      }\n   }\n}\n")),(0,i.yg)("p",null,"The code snippet defines a function named ",(0,i.yg)("inlineCode",{parentName:"p"},"app_driver_attribute_update")," that takes several parameters, including the driver handle (",(0,i.yg)("inlineCode",{parentName:"p"},"driver_handle"),"), endpoint ID (",(0,i.yg)("inlineCode",{parentName:"p"},"endpoint_id"),"), cluster ID (",(0,i.yg)("inlineCode",{parentName:"p"},"cluster_id"),"), attribute ID (",(0,i.yg)("inlineCode",{parentName:"p"},"attribute_id"),"), and a pointer to the attribute value (",(0,i.yg)("inlineCode",{parentName:"p"},"val"),")."),(0,i.yg)("p",null,"The purpose of this function is to update the attribute values of a light endpoint based on the received data. It follows a specific logic to determine which attribute of the light endpoint needs to be updated."),(0,i.yg)("p",null,"Here's a step-by-step breakdown of the data update logic:"),(0,i.yg)("ol",null,(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"The function first checks if the ",(0,i.yg)("inlineCode",{parentName:"p"},"endpoint_id")," matches the ",(0,i.yg)("inlineCode",{parentName:"p"},"light_endpoint_id"),". This ensures that the update is intended for the light endpoint.")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"If the ",(0,i.yg)("inlineCode",{parentName:"p"},"endpoint_id")," matches, the function casts the ",(0,i.yg)("inlineCode",{parentName:"p"},"driver_handle")," to the appropriate type (",(0,i.yg)("inlineCode",{parentName:"p"},"led_indicator_handle_t"),") to obtain the handle for the LED indicator associated with the light endpoint.")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"The function then checks the ",(0,i.yg)("inlineCode",{parentName:"p"},"cluster_id")," to determine which cluster the attribute belongs to. It supports three clusters: ",(0,i.yg)("inlineCode",{parentName:"p"},"OnOff"),", ",(0,i.yg)("inlineCode",{parentName:"p"},"LevelControl"),", and ",(0,i.yg)("inlineCode",{parentName:"p"},"ColorControl"),".")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"Depending on the ",(0,i.yg)("inlineCode",{parentName:"p"},"cluster_id"),", the function further checks the ",(0,i.yg)("inlineCode",{parentName:"p"},"attribute_id")," to identify the specific attribute within that cluster.")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"Based on the ",(0,i.yg)("inlineCode",{parentName:"p"},"cluster_id")," and ",(0,i.yg)("inlineCode",{parentName:"p"},"attribute_id"),", the function calls the corresponding setter function to update the attribute value:"),(0,i.yg)("ul",{parentName:"li"},(0,i.yg)("li",{parentName:"ul"},"If the ",(0,i.yg)("inlineCode",{parentName:"li"},"cluster_id")," is ",(0,i.yg)("inlineCode",{parentName:"li"},"OnOff::Id")," and the ",(0,i.yg)("inlineCode",{parentName:"li"},"attribute_id")," is ",(0,i.yg)("inlineCode",{parentName:"li"},"OnOff::Attributes::OnOff::Id"),", it calls ",(0,i.yg)("inlineCode",{parentName:"li"},"app_driver_light_set_power(handle, val)")," to set the power state of the light."),(0,i.yg)("li",{parentName:"ul"},"If the ",(0,i.yg)("inlineCode",{parentName:"li"},"cluster_id")," is ",(0,i.yg)("inlineCode",{parentName:"li"},"LevelControl::Id")," and the ",(0,i.yg)("inlineCode",{parentName:"li"},"attribute_id")," is ",(0,i.yg)("inlineCode",{parentName:"li"},"LevelControl::Attributes::CurrentLevel::Id"),", it calls ",(0,i.yg)("inlineCode",{parentName:"li"},"app_driver_light_set_brightness(handle, val)")," to set the brightness level of the light."),(0,i.yg)("li",{parentName:"ul"},"If the ",(0,i.yg)("inlineCode",{parentName:"li"},"cluster_id")," is ",(0,i.yg)("inlineCode",{parentName:"li"},"ColorControl::Id"),", it checks the ",(0,i.yg)("inlineCode",{parentName:"li"},"attribute_id")," further:",(0,i.yg)("ul",{parentName:"li"},(0,i.yg)("li",{parentName:"ul"},"If the ",(0,i.yg)("inlineCode",{parentName:"li"},"attribute_id")," is ",(0,i.yg)("inlineCode",{parentName:"li"},"ColorControl::Attributes::CurrentHue::Id"),", it calls ",(0,i.yg)("inlineCode",{parentName:"li"},"app_driver_light_set_hue(handle, val)")," to set the hue of the light."),(0,i.yg)("li",{parentName:"ul"},"If the ",(0,i.yg)("inlineCode",{parentName:"li"},"attribute_id")," is ",(0,i.yg)("inlineCode",{parentName:"li"},"ColorControl::Attributes::CurrentSaturation::Id"),", it calls ",(0,i.yg)("inlineCode",{parentName:"li"},"app_driver_light_set_saturation(handle, val)")," to set the saturation of the light."),(0,i.yg)("li",{parentName:"ul"},"If the ",(0,i.yg)("inlineCode",{parentName:"li"},"attribute_id")," is ",(0,i.yg)("inlineCode",{parentName:"li"},"ColorControl::Attributes::ColorTemperatureMireds::Id"),", it calls ",(0,i.yg)("inlineCode",{parentName:"li"},"app_driver_light_set_temperature(handle, val)")," to set the color temperature of the light.")))))),(0,i.yg)("p",null,"Overall, this function acts as a central point for updating the attribute values of a light endpoint. It receives the necessary information (endpoint ID, cluster ID, attribute ID, and attribute value) and dispatches the update to the appropriate setter function based on the cluster and attribute IDs."),(0,i.yg)("p",null,"By organizing the logic in this way, the code becomes more modular and easier to maintain. It allows for updating different attributes of the light endpoint (power state, brightness, hue, saturation, color temperature) through a single function, simplifying the process of updating the light's characteristics based on the received data."),(0,i.yg)("p",null,"But not all attributes are updated in real time. Code that marks those attributes that are likely to change frequently, as deferred persistence, can improve performance, as well as reduce the number of writes to non-volatile memory and extend the life of the device."),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-cpp"},"/* Mark deferred persistence for some attributes that might be changed rapidly */\ncluster_t *level_control_cluster = cluster::get(endpoint, LevelControl::Id);\nattribute_t *current_level_attribute = attribute::get(level_control_cluster, LevelControl::Attributes::CurrentLevel::Id);\nattribute::set_deferred_persistence(current_level_attribute);\n\ncluster_t *color_control_cluster = cluster::get(endpoint, ColorControl::Id);\nattribute_t *current_x_attribute = attribute::get(color_control_cluster, ColorControl::Attributes::CurrentX::Id);\nattribute::set_deferred_persistence(current_x_attribute);\n")),(0,i.yg)("h2",{id:"defining-your-own-data-model"},"Defining your own data model"),(0,i.yg)("p",null,"This section demonstrates creating standard endpoints, clusters, attributes, and commands that are defined in the Matter specification."),(0,i.yg)("h4",{id:"endpoints"},"Endpoints"),(0,i.yg)("p",null,"The device can be customized by editing the endpoint/device_type creating in the ",(0,i.yg)("em",{parentName:"p"},"app_main.cpp")," of the example. Examples:"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"on_off_light:")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-cpp"},"   on_off_light::config_t light_config;\n   endpoint_t *endpoint = on_off_light::create(node, &light_config, ENDPOINT_FLAG_NONE);\n")),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"fan:")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-cpp"},"   fan::config_t fan_config;\n   endpoint_t *endpoint = fan::create(node, &fan_config, ENDPOINT_FLAG_NONE);\n")),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"door_lock:")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-cpp"},"   door_lock::config_t door_lock_config;\n   endpoint_t *endpoint = door_lock::create(node, &door_lock_config, ENDPOINT_FLAG_NONE);\n")),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"window_covering_device:")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-cpp"},"   window_covering_device::config_t window_covering_device_config(static_cast<uint8_t>(chip::app::Clusters::WindowCovering::EndProductType::kTiltOnlyInteriorBlind));\n   endpoint_t *endpoint = window_covering_device::create(node, &window_covering_config, ENDPOINT_FLAG_NONE);\n")),(0,i.yg)("p",null,"   The ",(0,i.yg)("inlineCode",{parentName:"p"},"window_covering_device")," ",(0,i.yg)("inlineCode",{parentName:"p"},"config_t"),' structure includes a constructor that allows specifying\nan end product type different than the default one, which is "Roller shade".\nOnce a ',(0,i.yg)("inlineCode",{parentName:"p"},"config_t")," instance has been instantiated, its end product type cannot be modified."),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"pump")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-cpp"},"   pump::config_t pump_config(1, 10, 20);\n   endpoint_t *endpoint = pump::create(node, &pump_config, ENDPOINT_FLAG_NONE);\n")),(0,i.yg)("p",null,"   The ",(0,i.yg)("inlineCode",{parentName:"p"},"pump")," ",(0,i.yg)("inlineCode",{parentName:"p"},"config_t")," structure includes a constructor that allows specifying\nmaximum pressure, maximum speed and maximum flow values. If they aren't set, they will be set to null by default.\nOnce a ",(0,i.yg)("inlineCode",{parentName:"p"},"config_t")," instance has been instantiated, these three values cannot be modified."),(0,i.yg)("h3",{id:"clusters"},"Clusters"),(0,i.yg)("p",null,"Additional clusters can also be added to an endpoint. Examples:"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"on_off:")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-cpp"},"   on_off::config_t on_off_config;\n   cluster_t *cluster = on_off::create(endpoint, &on_off_config, CLUSTER_FLAG_SERVER, on_off::feature::lighting::get_id());\n")),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"temperature_measurement:")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-cpp"},"   temperature_measurement::config_t temperature_measurement_config;\n   cluster_t *cluster = temperature_measurement::create(endpoint, &temperature_measurement_config, CLUSTER_FLAG_SERVER);\n")),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"window_covering:")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-cpp"},"   window_covering::config_t window_covering_config(static_cast<uint8_t>(chip::app::Clusters::WindowCovering::EndProductType::kTiltOnlyInteriorBlind));\n   cluster_t *cluster = window_covering::create(endpoint, &window_covering_config, CLUSTER_FLAG_SERVER);\n")),(0,i.yg)("p",null,"   The ",(0,i.yg)("inlineCode",{parentName:"p"},"window_covering")," ",(0,i.yg)("inlineCode",{parentName:"p"},"config_t"),' structure includes a constructor that allows specifying\nan end product type different than the default one, which is "Roller shade".\nOnce a ',(0,i.yg)("inlineCode",{parentName:"p"},"config_t")," instance has been instantiated, its end product type cannot be modified."),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"pump_configuration_and_control:")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-cpp"},"   pump_configuration_and_control::config_t pump_configuration_and_control_config(1, 10, 20);\n   cluster_t *cluster = pump_configuration_and_control::create(endpoint, &pump_configuration_and_control_config, CLUSTER_FLAG_SERVER);\n")),(0,i.yg)("p",null,"   The ",(0,i.yg)("inlineCode",{parentName:"p"},"pump_configuration_and_control")," ",(0,i.yg)("inlineCode",{parentName:"p"},"config_t")," structure includes a constructor that allows specifying\nmaximum pressure, maximum speed and maximum flow values. If they aren't set, they will be set to null by default.\nOnce a ",(0,i.yg)("inlineCode",{parentName:"p"},"config_t")," instance has been instantiated, these three values cannot be modified."),(0,i.yg)("h3",{id:"attributes-and-commands"},"Attributes and Commands"),(0,i.yg)("p",null,"Additional attributes and commands can also be added to a cluster.\nExamples:"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"attribute: on_off:")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-cpp"},"   bool default_on_off = true;\n   attribute_t *attribute = on_off::attribute::create_on_off(cluster, default_on_off);\n")),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"attribute: cluster_revision:")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-cpp"},"   uint16_t default_cluster_revision = 1;\n   attribute_t *attribute = global::attribute::create_cluster_revision(cluster, default_cluster_revision);\n")),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"command: toggle:")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-cpp"},"   command_t *command = on_off::command::create_toggle(cluster);\n")),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"command: move_to_level:")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-cpp"},"   command_t *command = level_control::command::create_move_to_level(cluster);\n")),(0,i.yg)("h3",{id:"features"},"Features"),(0,i.yg)("p",null,"Optional features which are applicable to a cluster can also be added."),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"feature: taglist: Descriptor cluster:")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-cpp"},"   cluster_t* cluster = cluster::get(endpoint, Descriptor::Id);\n   descriptor::feature::taglist::add(cluster);\n")),(0,i.yg)("h3",{id:"adding-custom-data-model-fields"},"Adding custom data model fields"),(0,i.yg)("p",null,"This section demonstrates creating custom endpoints, clusters, attributes, and commands that are not defined in the Matter specification and can be\nspecific to the vendor."),(0,i.yg)("h4",{id:"endpoints-1"},"Endpoints"),(0,i.yg)("p",null,"Non-Standard endpoint can be created, without any clusters."),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Endpoint create:")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-cpp"},"   endpoint_t *endpoint = endpoint::create(node, ENDPOINT_FLAG_NONE);\n")),(0,i.yg)("h4",{id:"clusters-1"},"Clusters"),(0,i.yg)("p",null,"Non-Standard/Custom clusters can also be created:"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Cluster create:")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-cpp"},"   uint32_t custom_cluster_id = 0x131bfc00;\n   cluster_t *cluster = cluster::create(endpoint, custom_cluster_id, CLUSTER_FLAG_SERVER);\n")),(0,i.yg)("h4",{id:"attributes-and-commands-1"},"Attributes and Commands"),(0,i.yg)("p",null,"Non-Standard/Custom attributes can also be created on any cluster:"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Attribute create:")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-cpp"},"   uint32_t custom_attribute_id = 0x0;\n   uint16_t default_value = 100;\n   attribute_t *attribute = attribute::create(cluster, custom_attribute_id, ATTRIBUTE_FLAG_NONE, esp_matter_uint16(default_value);\n")),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Command create:")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-cpp"},'   static esp_err_t command_callback(const ConcreteCommandPath &command_path, TLVReader &tlv_data, void\n   *opaque_ptr)\n   {\n      ESP_LOGI(TAG, "Custom command callback");\n      return ESP_OK;\n   }\n\n   uint32_t custom_command_id = 0x0;\n   command_t *command = command::create(cluster, custom_command_id, COMMAND_FLAG_ACCEPTED, command_callback);\n')),(0,i.yg)("p",null,"The Matter data model organizes these components in a hierarchical manner. A Matter Node contains one or more Endpoints, each representing a specific device type. Each Endpoint consists of multiple Clusters, which group related attributes and commands. Attributes store the state and configuration of a cluster, while commands are used to interact with and control the device."),(0,i.yg)("p",null,"By structuring the data model in this way, Matter enables interoperability and standardization across devices from different manufacturers. Developers can use the defined device types, clusters, attributes, and commands to create applications that can seamlessly control and communicate with Matter-compatible devices."),(0,i.yg)("p",null,"The Matter data model provides a common language and framework for devices to describe their capabilities and interact with each other, allowing for a more unified and consistent smart home experience."),(0,i.yg)("h2",{id:"tech-support--product-discussion"},"Tech Support & Product Discussion"),(0,i.yg)("p",null,"Thank you for choosing our products! We are here to provide you with different support to ensure that your experience with our products is as smooth as possible. We offer several communication channels to cater to different preferences and needs."),(0,i.yg)("div",{class:"table-center"},(0,i.yg)("div",{class:"button_tech_support_container"},(0,i.yg)("a",{href:"https://forum.seeedstudio.com/",class:"button_forum"}),(0,i.yg)("a",{href:"https://www.seeedstudio.com/contacts",class:"button_email"})),(0,i.yg)("div",{class:"button_tech_support_container"},(0,i.yg)("a",{href:"https://discord.gg/eWkprNDMU7",class:"button_discord"}),(0,i.yg)("a",{href:"https://github.com/Seeed-Studio/wiki-documents/discussions/69",class:"button_discussion"}))))}u.isMDXComponent=!0}}]);