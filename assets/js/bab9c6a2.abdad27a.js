"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[79489],{15680:(e,t,o)=>{o.d(t,{xA:()=>u,yg:()=>c});var n=o(96540);function r(e,t,o){return t in e?Object.defineProperty(e,t,{value:o,enumerable:!0,configurable:!0,writable:!0}):e[t]=o,e}function a(e,t){var o=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),o.push.apply(o,n)}return o}function s(e){for(var t=1;t<arguments.length;t++){var o=null!=arguments[t]?arguments[t]:{};t%2?a(Object(o),!0).forEach((function(t){r(e,t,o[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(o)):a(Object(o)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(o,t))}))}return e}function i(e,t){if(null==e)return{};var o,n,r=function(e,t){if(null==e)return{};var o,n,r={},a=Object.keys(e);for(n=0;n<a.length;n++)o=a[n],t.indexOf(o)>=0||(r[o]=e[o]);return r}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(n=0;n<a.length;n++)o=a[n],t.indexOf(o)>=0||Object.prototype.propertyIsEnumerable.call(e,o)&&(r[o]=e[o])}return r}var l=n.createContext({}),d=function(e){var t=n.useContext(l),o=t;return e&&(o="function"==typeof e?e(t):s(s({},t),e)),o},u=function(e){var t=d(e.components);return n.createElement(l.Provider,{value:t},e.children)},p="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},g=n.forwardRef((function(e,t){var o=e.components,r=e.mdxType,a=e.originalType,l=e.parentName,u=i(e,["components","mdxType","originalType","parentName"]),p=d(o),g=r,c=p["".concat(l,".").concat(g)]||p[g]||m[g]||a;return o?n.createElement(c,s(s({ref:t},u),{},{components:o})):n.createElement(c,s({ref:t},u))}));function c(e,t){var o=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var a=o.length,s=new Array(a);s[0]=g;var i={};for(var l in t)hasOwnProperty.call(t,l)&&(i[l]=t[l]);i.originalType=e,i[p]="string"==typeof e?e:r,s[1]=i;for(var d=2;d<a;d++)s[d]=o[d];return n.createElement.apply(null,s)}return n.createElement.apply(null,o)}g.displayName="MDXCreateElement"},84147:(e,t,o)=>{o.r(t),o.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>m,frontMatter:()=>a,metadata:()=>i,toc:()=>d});var n=o(58168),r=(o(96540),o(15680));const a={description:"ODYSSEY, STM32MP135D",title:"Getting Started with ODYSSEY \u2013 STM32MP135D",image:"https://files.seeedstudio.com/wiki/wiki-platform/S-tempor.png",slug:"/ODYSSEY-STM32MP135D",last_update:{date:"10/13/2023",author:"Xogium"}},s="Getting Started with ODYSSEY \u2013 STM32MP135D",i={unversionedId:"Edge/ODYSSEY/ODYSSEY_STM32MP135D/ODYSSEY STM32MP135D",id:"Edge/ODYSSEY/ODYSSEY_STM32MP135D/ODYSSEY STM32MP135D",title:"Getting Started with ODYSSEY \u2013 STM32MP135D",description:"ODYSSEY, STM32MP135D",source:"@site/docs/Edge/ODYSSEY/ODYSSEY_STM32MP135D/ODYSSEY STM32MP135D.md",sourceDirName:"Edge/ODYSSEY/ODYSSEY_STM32MP135D",slug:"/ODYSSEY-STM32MP135D",permalink:"/ODYSSEY-STM32MP135D",draft:!1,editUrl:"https://github.com/Seeed-Studio/wiki-documents/blob/docusaurus-version/docs/Edge/ODYSSEY/ODYSSEY_STM32MP135D/ODYSSEY STM32MP135D.md",tags:[],version:"current",lastUpdatedBy:"Xogium",lastUpdatedAt:1697155200,formattedLastUpdatedAt:"Oct 13, 2023",frontMatter:{description:"ODYSSEY, STM32MP135D",title:"Getting Started with ODYSSEY \u2013 STM32MP135D",image:"https://files.seeedstudio.com/wiki/wiki-platform/S-tempor.png",slug:"/ODYSSEY-STM32MP135D",last_update:{date:"10/13/2023",author:"Xogium"}},sidebar:"ProductSidebar",previous:{title:"ODYSSEY Guide",permalink:"/ODYSSEY_Intro"},next:{title:"Getting Started with ODYSSEY - X86J41x5",permalink:"/ODYSSEY-X86J4105"}},l={},d=[{value:"Hardware",id:"hardware",level:2},{value:"Getting started",id:"getting-started",level:2},{value:"Hardware",id:"hardware-1",level:3},{value:"Software",id:"software",level:3},{value:"Features",id:"features",level:4},{value:"Getting the softwares",id:"getting-the-softwares",level:4},{value:"Building",id:"building",level:4},{value:"How to use the system",id:"how-to-use-the-system",level:4},{value:"eMMC boot",id:"emmc-boot",level:5},{value:"Micro sd card boot",id:"micro-sd-card-boot",level:5},{value:"Nfs boot",id:"nfs-boot",level:5},{value:"EEPROM",id:"eeprom",level:2},{value:"Layout",id:"layout",level:3},{value:"How to use the EEPROM",id:"how-to-use-the-eeprom",level:3},{value:"How to connect and use grove sensors",id:"how-to-connect-and-use-grove-sensors",level:2},{value:"\u2728 Contributor Project",id:"-contributor-project",level:2},{value:"Resources",id:"resources",level:2}],u={toc:d},p="wrapper";function m(e){let{components:t,...o}=e;return(0,r.yg)(p,(0,n.A)({},u,o,{components:t,mdxType:"MDXLayout"}),(0,r.yg)("h1",{id:"getting-started-with-odyssey--stm32mp135d"},"Getting Started with ODYSSEY \u2013 STM32MP135D"),(0,r.yg)("p",null,"ODYSSEY STM32MP135D is a compact STM32 MPU based single-board computer that\noffers powerful hardware in a small form factor designed for a variety of uses\nranging from smart home, to vending machines, to IP Camera, etc. It offers a\nwide range of connectivity options designed to make it easy to prototype with.\nThe hardware is available in two different variants:"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("a",{parentName:"li",href:"https://www.seeedstudio.com/Odyssey-MP135D-p-5727.html"},"ODYSSEY STM32MP135D"),", which\noffers all the connectivity with only basic micro sd as storage option"),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("a",{parentName:"li",href:"https://www.seeedstudio.com/Odyssey-MP135D-eMMC-p-5728.html"},"ODYSSEY STM32MP135D with\neMMC"),", which adds\na 4 GB eMMC for storage")),(0,r.yg)("p",null,"Currently, only buildroot is supported as operating system."),(0,r.yg)("h2",{id:"hardware"},"Hardware"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},"SoC: STM32MP135D",(0,r.yg)("ul",{parentName:"li"},(0,r.yg)("li",{parentName:"ul"},"32-bit Arm\xae Cortex\xae-A7",(0,r.yg)("ul",{parentName:"li"},(0,r.yg)("li",{parentName:"ul"},"L1 32-Kbyte I / 32-Kbyte D"),(0,r.yg)("li",{parentName:"ul"},"128-Kbyte unified level 2 cache"),(0,r.yg)("li",{parentName:"ul"},"Arm\xae NEON\u2122 and Arm\xae TrustZone\xae"))))),(0,r.yg)("li",{parentName:"ul"},"Supports buildroot operating system."),(0,r.yg)("li",{parentName:"ul"},"Connectivity:",(0,r.yg)("ul",{parentName:"li"},(0,r.yg)("li",{parentName:"ul"},"2x 10/100 mbit/s ethernet ports,",(0,r.yg)("ul",{parentName:"li"},(0,r.yg)("li",{parentName:"ul"},"eth1 supports PoE and WOL."))),(0,r.yg)("li",{parentName:"ul"},"1x usb-a port,"),(0,r.yg)("li",{parentName:"ul"},"1x CSI 30p FPC Connector,"),(0,r.yg)("li",{parentName:"ul"},"1x LCD 40p FPC Connector,"),(0,r.yg)("li",{parentName:"ul"},"40 pins GPIO in raspberry pi compatible pinout."))),(0,r.yg)("li",{parentName:"ul"},"Storage / memories:",(0,r.yg)("ul",{parentName:"li"},(0,r.yg)("li",{parentName:"ul"},"4 gbits DRAM,"),(0,r.yg)("li",{parentName:"ul"},"256 kbits EEPROM with a 64 bytes pagesize,"),(0,r.yg)("li",{parentName:"ul"},"Micro sd card slot supporting sd, sdhc and sdxc cards,"),(0,r.yg)("li",{parentName:"ul"},"4 gbytes eMMC (only on the variant with eMMC storage)"))),(0,r.yg)("li",{parentName:"ul"},"Power supply options:",(0,r.yg)("ul",{parentName:"li"},(0,r.yg)("li",{parentName:"ul"},"PoE through eth1 port,"),(0,r.yg)("li",{parentName:"ul"},"5v in via usb-c connector."))),(0,r.yg)("li",{parentName:"ul"},"Bare board dimentions: 85x56x17mm"),(0,r.yg)("li",{parentName:"ul"},"Bare board weight: 36g")),(0,r.yg)("h2",{id:"getting-started"},"Getting started"),(0,r.yg)("h3",{id:"hardware-1"},"Hardware"),(0,r.yg)("p",null,"To get started with the hardware, you will need the following:"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},"1x ODYSSEY STM32MP135D,"),(0,r.yg)("li",{parentName:"ul"},"1x usb-c to usb-a cable OR usb-c to usb-c cable,"),(0,r.yg)("li",{parentName:"ul"},"1x ethernet cable,"),(0,r.yg)("li",{parentName:"ul"},"1x usb to uart cable such as ",(0,r.yg)("a",{parentName:"li",href:"https://ftdichip.com/products/ttl-232r-rpi/"},"this\none"),".")),(0,r.yg)("p",null,"First, carefully connect the usb to uart cable so you get access to the serial\nconsole. Refer to the following image to help you connect the pins\nproperly.\n",(0,r.yg)("img",{parentName:"p",src:"https://wdcdn.qpic.cn/MTY4ODg1NTkyNTI4NTEyMg_558688_ff47Pijnl_CdTY5i_1689582643?w=1201&h=801&type=image/png",alt:"Top down view of STM32MP135D ODYSSEY board with debug pins next to the boot\njumper circled. Pins listed in order of closeness to boot jumpers: WAKE, GND,\nTX, RX",title:"highlighted uart0 pins"})),(0,r.yg)("p",null,"We will use the usb-c for power in this guide. Connect one end of the usb-c\ncable to the board, then connect the other end to your computer. Plug the\nethernet cable into eth1 port of the ODYSSEY, and the other end into your\nrouter or network switch."),(0,r.yg)("h3",{id:"software"},"Software"),(0,r.yg)("p",null,"This guide will use the following software components:"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("a",{parentName:"li",href:"https://buildroot.org/download.html"},"buildroot version 2023.02 or later"),"."),(0,r.yg)("li",{parentName:"ul"},"The ",(0,r.yg)("a",{parentName:"li",href:"https://github.com/xogium/buildroot-stm32mp135d-odyssey"},"buildroot external\ntree")," to be used in\nconjunction with upstream buildroot."),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("a",{parentName:"li",href:"https://github.com/bootlin/snagboot"},"snagboot"),", which is a set of utilities\nthat helps with easier operation of DFU and usb mass storage. It consists of\nsnagrecover which is intended to upload the fsbl and ssbl into the board's\nDRAM, and of snagflash which is designed to actually flash data onto persistent\nstorage.")),(0,r.yg)("p",null,"Note: please follow the instructions in the snagboot repository in order to set\nit up properly, this is out of scope for this guide."),(0,r.yg)("h4",{id:"features"},"Features"),(0,r.yg)("p",null,"The external tree provides the following:"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},"A single stm32mp135d_odyssey_defconfig which builds a minimal and generic\nsystem consisting of tf-a, optee, u-boot, and the linux kernel for the boot\nchain. The userspace is minimal and consists of a simple busybox init system\nand shell.",(0,r.yg)("pre",{parentName:"li"},(0,r.yg)("code",{parentName:"pre"},"* This system can be used in the following ways:\n    * Written and booted from the eMMC (if your hardware \n    has it)\n    * Written and booted from a micro sd card.\n    * Booted over NFS.\n"))),(0,r.yg)("li",{parentName:"ul"},"A post-build script is used to provide an easily writable bootloader image\nfor the eMMC. It combines -tf-a and FIP image together in a single file, meant\nto be written using DFU, into the boot regions of said eMMC."),(0,r.yg)("li",{parentName:"ul"},"A genimage configuration generates two disk images:",(0,r.yg)("pre",{parentName:"li"},(0,r.yg)("code",{parentName:"pre"},"* emmc.img contains an u-boot-env partition to easily store the u-boot \n")),"environment into, along with the rootfs. It is expected that the bootloader be\nstored into the eMMC boot regions via DFU.",(0,r.yg)("pre",{parentName:"li"},(0,r.yg)("code",{parentName:"pre"},"* sdcard.img is comprised of two copies of tf-a into fsbl1 and fsbl2 \n")),"partitions, respectively, along with one single fip partition which contains\nthe FIP image. There is also an u-boot-env partition the same as in emmc.img,\nalong with a single rootfs."),(0,r.yg)("li",{parentName:"ul"},"The external tree provides an empty external.mk, Config.in and a\npackages directory to be used, should you wish to add additional options\nand content. Please refer to the corresponding section in the buildroot\nmanual to learn more.")),(0,r.yg)("h4",{id:"getting-the-softwares"},"Getting the softwares"),(0,r.yg)("p",null,"This example demonstrates getting buildroot and the required external tree,\nthen setting them up to be used:"),(0,r.yg)("p",null,"First install Buildroot's required dependencies. See:\n",(0,r.yg)("a",{parentName:"p",href:"https://buildroot.org/downloads/manual/manual.html#requirement"},"The buildroot user manual, chapter 2: System\nrequirements"),".\nThen, set up the source code:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre"},"wget https://buildroot.org/downloads/buildroot-2023.02.5.tar.gz\ntar -xf buildroot-2023.02.5.tar.gz\nmv buildroot-2023.02.5 buildroot\ngit clone https://github.com/xogium/buildroot-stm32mp135d-odyssey\n")),(0,r.yg)("h4",{id:"building"},"Building"),(0,r.yg)("p",null,"Once the source code has been set up correctly, you can proceed with the\nbuild:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre"},"cd buildroot\nmake BR2_EXTERNAL=/absolute/path/to/buildroot-stm32mp135d-odyssey stm32mp135d_odyssey_defconfig\nmake\n")),(0,r.yg)("p",null,"If everything goes well, you should now have a successfully built\nsystem in the output/images directory of your buildroot tree."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre"},"ls -1 output/images\ncombined-tf-a-and-fip.img\nemmc.img\nfip.bin\nrootfs.ext2\nrootfs.ext4\nrootfs.tar\nsdcard.img\nstm32mp135d-odyssey.dtb\ntee.bin\ntee-header_v2.bin\ntee-pageable_v2.bin\ntee-pager_v2.bin\ntf-a-stm32mp135d-odyssey.stm32\nu-boot.dtb\nu-boot-nodtb.bin\nzImage\n")),(0,r.yg)("h4",{id:"how-to-use-the-system"},"How to use the system"),(0,r.yg)("h5",{id:"emmc-boot"},"eMMC boot"),(0,r.yg)("p",null,"Remove the middle boot jumper on the board to be sure DFU mode is active. Make\nsure to open the serial console using minicom or another similar program, you\nwill need it."),(0,r.yg)("p",null,"As an example, here is how to use gnu screen to access a serial console\nnamed ttyUSB0. The baud rate is expected to be 115200n8."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre"},"sudo screen /dev/ttyUSB0 115200n8\n")),(0,r.yg)("p",null,"Then, execute the following command from the snagboot package and be\nprepared to interrupt the boot sequence when reaching u-boot, by\npressing any key in the serial console window:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre"},"cd output/images\nsnagrecover -s stm32mp13 -f ../../board/stm32mp135d-odyssey/utilities/stm32mp1-stm32mp135d-odyssey.yaml\n")),(0,r.yg)("p",null,"Once at the u-boot prompt, type the following to enable the eMMC boot\npartition: ",(0,r.yg)("inlineCode",{parentName:"p"},"mmc partconf 1 1 1 1"),". This enables the first eMMC boot\npartition and ensure it is possible to boot from it, by modifying ext\ncsd register 179. Then, type ",(0,r.yg)("inlineCode",{parentName:"p"},"dfu 0")," to expose all the DFU alt\nsettings to your host machine, including the eMMC boot regions. They can\nbe listed using the dfu-util command:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre"},'dfu-util -l\nFound DFU: [0483:df11] ver=0200, devnum=7, cfg=1, intf=0, path="3-3", alt=4, name="mmc1_boot2", serial="0021001A3232510937393835"\nFound DFU: [0483:df11] ver=0200, devnum=7, cfg=1, intf=0, path="3-3", alt=3, name="mmc1_boot1", serial="0021001A3232510937393835"\n...\n')),(0,r.yg)("p",null,"Then, use the snagflash tool to write the combined bootloader image into\nboth boot regions:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre"},"snagflash -P dfu -p 0483:df11 --dfu-keep -D 3:combined-tf-a-and-fip.img\nsnagflash -P dfu -p 0483:df11 -D 4:combined-tf-a-and-fip.img\n")),(0,r.yg)("p",null,"Once this is done, reset the board and confirm that the eMMC boot now\nworks as expected by putting the middle boot jumper back onto the board.\nIt will error out at booting from mmc1 partition 0 given the user area\nis blank, but this is normal at this stage."),(0,r.yg)("p",null,"When you're back at the u-boot prompt again, type ",(0,r.yg)("inlineCode",{parentName:"p"},"ums 0 1")," to\nexpose the user area of the eMMC as a usb mass storage device to your\nhost machine. Use lsblk to determine which device node it was assigned,\nand replace sdX in the following command with the appropriate device\nnode. Double check to ensure you will write on the correct device as it\nwill be wiped entirely!"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre"},"snagflash -P ums -s emmc.img -b /dev/sdX\n")),(0,r.yg)("p",null,"When the writing has completed, press ctrl+c at the u-boot prompt to\nterminate the usb mass storage mode. Then, reset your board again, and\nconfirm that it is now booting linux and that you get a login prompt.\nLog in with the root user and no password."),(0,r.yg)("h5",{id:"micro-sd-card-boot"},"Micro sd card boot"),(0,r.yg)("p",null,"If you wish to burn the system onto a micro sd card, please proceed as\nfollows, replacing sdX with the appropriate device node:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre"},"sudo dd if=output/images/sdcard.img of=/dev/sdX bs=4M conv=fsync\n")),(0,r.yg)("p",null,"Where sdX corresponds to the micro sd card device node. Refers to\nthe output of lsblk command to make sure you get the correct device\nnode! Otherwise, data loss will occure, as this erases the entire content of\nthe target device."),(0,r.yg)("p",null,"Please use minicom or similar program to attach to the serial console of\nthe board. As an example, here is how to use gnu screen to access a\nserial console named ttyUSB0. The baud rate is expected to be 115200n8."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre"},"sudo screen /dev/ttyUSB0 115200n8\n")),(0,r.yg)("p",null,"When the micro sd card has been successfully written to, insert it into\nthe micro sd socket of the STM32MP135D ODYSSEY board, and adjust the boot\njumpers to boot from micro sd (all jumpers removed). If required, reset the\nboard. Log in with the user root and no password once you get the buildroot\nlogin prompt."),(0,r.yg)("h5",{id:"nfs-boot"},"Nfs boot"),(0,r.yg)("p",null,"To boot the system via NFS, please ensure to set up your /etc/exports as\ndemonstrated, replacing the subnet / allowed ip addresses as needed,\ndoing the same for the exported paths:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre"},"/srv/nfs 192.168.1.0/24(rw,sync,crossmnt,fsid=0)\n/srv/nfs/stm32mp135d 192.168.1.0/24(rw,nohide,insecure,no_subtree_check,async,no_root_squash)\n")),(0,r.yg)("p",null,"Also make sure your nfs server configuration enables UDP mode, like so:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre"},"/etc/nfs.conf\n[nfsd]\n...\nudp=y\n")),(0,r.yg)("p",null,"Extract the generated rootfs tarball in the appropriate directory, in this case\n/srv/nfs/stm32mp135d:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre"},"cd output/images\nsudo mkdir srv/nfs/stm32mp135d\nsudo bsdtar -xpf rootfs.tar -C /srv/nfs/stm32mp135d\n")),(0,r.yg)("p",null,"Remove the middle boot jumper to be sure DFU mode is active. Make sure to open\nthe serial console using minicom or another similar program, you will need it.\nAs an example, here is how to use gnu screen to access a serial console\nnamed ttyUSB0. The baud rate is expected to be 115200n8."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre"},"sudo screen /dev/ttyUSB0 115200n8\n")),(0,r.yg)("p",null,"Then, execute the following command from the snagboot package and be prepared\nto interrupt the boot sequence when reaching u-boot, by pressing any key in the\nserial console window:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre"},"cd output/images\nsnagrecover -s stm32mp13 -f ../../board/stm32mp135d-odyssey/utilities/stm32mp1-stm32mp135d-odyssey.yaml\n")),(0,r.yg)("p",null,"Once you're at the u-boot prompt, you can boot over nfs by doing the\nfollowing:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre"},"setenv eth1addr 2c:f7:f1:30:2b:62\nsetenv ethaddr 2c:f7:f1:30:2b:62\ndhcp\nnfs ${kernel_addr_r} 192.168.1.92:/srv/nfs/stm32mp135d/boot/zImage\nnfs ${fdt_addr_r} 192.168.1.92:/srv/nfs/stm32mp135d/boot/stm32mp135d-odyssey.dtb\nsetenv bootargs root=/dev/nfs rootfstype=nfs ip=dhcp nfsroot=192.168.1.92:/srv/nfs/stm32mp135d,tcp,v3 rw quiet console=ttySTM0,115200n8 earlycon\nbootz ${kernel_addr_r} - ${fdt_addr_r}\n")),(0,r.yg)("p",null,"Where 192.168.1.92 in this example is the machine hosting the nfs\nserver. The MAC address set is also an example and not to be used in the\nreal world. It is required due to having no MAC addresses defined in the\nOTP of the board, but can be stored semi-permanently in the EEPROM (see below).\nLog in with the user root and no password."),(0,r.yg)("h2",{id:"eeprom"},"EEPROM"),(0,r.yg)("h3",{id:"layout"},"Layout"),(0,r.yg)("p",null,"The current implementation to read MAC addresses from the EEPROM is\nexpecting the first one to start at offset 0 and have a length of 6\nbytes. The second MAC must be stored at offset 0x10, and also have a\nlength of 6 bytes."),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},"Tip: to generate random MAC, use a generator such as\n",(0,r.yg)("a",{parentName:"li",href:"https://www.hellion.org.uk/cgi-bin/randmac.pl"},"this one"),".")),(0,r.yg)("p",null,"For storing the u-boot environment into the EEPROM if you wish to do so,\nplease ensure that the environment begins on a new page boundary. Pages\nare 64 bytes in size. For example, you could set the environment offset\nto 0x40, the size remaining at 0x2000, and redundant offset to 0x2080.\nHere's an example u-boot config fragment:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre"},"CONFIG_ENV_IS_IN_EEPROM=y\nCONFIG_ENV_OFFSET=0x40\nCONFIG_ENV_OFFSET_REDUND=0x2080\nCONFIG_I2C_EEPROM=y\nCONFIG_SYS_I2C_EEPROM_ADDR=0x50\nCONFIG_NVMEM=y\n")),(0,r.yg)("p",null,"To apply it, run ",(0,r.yg)("inlineCode",{parentName:"p"},"make menuconfig")," in the toplevel buildroot\ndirectory. Go to the bootloaders menu, scroll down to u-boot and modify\nthe additional config fragments path, for example by inputting\n",(0,r.yg)("inlineCode",{parentName:"p"},"$(BR2_EXTERNAL_STM32MP135D_ODYSSEY_PATH)/board/stm32mp135d-odyssey/configs/uboot.config"),"."),(0,r.yg)("p",null,"Then, please do a rebuild using ",(0,r.yg)("inlineCode",{parentName:"p"},"make clean && make"),"."),(0,r.yg)("p",null,"Ultimately the layout is free for you to use, except for the MAC\naddresses location and length."),(0,r.yg)("h3",{id:"how-to-use-the-eeprom"},"How to use the EEPROM"),(0,r.yg)("p",null,"To make use of the EEPROM on your board, you get access to it as a nvmem\ndevice, in both u-boot and linux. For example, lets write a MAC address\nin it:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre"},"printf '\\x2c\\xf7\\xf1\\30\\x2b\\x62'|dd of=/sys/bus/nvmem/devices/0-00501/nvmem bs=1\n")),(0,r.yg)("p",null,"To store a second MAC address, do like so:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre"},"printf '\\x2c\\xf7\\xf1\\30\\x2b\\x63'|dd of=/sys/bus/nvmem/devices/0-00501/nvmem bs=1 seek=16\n")),(0,r.yg)("h2",{id:"how-to-connect-and-use-grove-sensors"},"How to connect and use grove sensors"),(0,r.yg)("p",null,"TODO"),(0,r.yg)("h2",{id:"-contributor-project"},"\u2728 Contributor Project"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},"This project is supported by the Seeed Studio ",(0,r.yg)("a",{parentName:"li",href:"https://github.com/orgs/Seeed-Studio/projects/6/views/1?pane=issue&itemId=30957479"},"Contributor Project"),"."),(0,r.yg)("li",{parentName:"ul"},"Thanks ",(0,r.yg)("a",{parentName:"li",href:"https://github.com/orgs/Seeed-Studio/projects/6/views/1?pane=issue&itemId=34112514"},"Casey's efforts")," and your work will be ",(0,r.yg)("a",{parentName:"li",href:"https://wiki.seeedstudio.com/Honorary-Contributors/"},"exhibited"),".")),(0,r.yg)("h2",{id:"resources"},"Resources"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("a",{parentName:"li",href:"https://git.xogium.me/xogium/st-arm-trusted-firmware/tree/v2.8-stm32mp-odyssey-r2"},"Fork of ARM trusted firmware used in the external buildroot\ntree")),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("a",{parentName:"li",href:"https://git.xogium.me/xogium/st-optee_os/tree/3.19.0-stm32mp-odyssey-r2"},"Fork of\nOP-TEE")),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("a",{parentName:"li",href:"https://git.xogium.me/xogium/st-u-boot/tree/v2022.10-stm32mp-odyssey-r2"},"Fork of\nU-Boot")),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("a",{parentName:"li",href:"https://github.com/xogium/st-linux/releases/tag/v6.1-stm32mp-odyssey-r3"},"Fork of the Linux\nkernel"))))}m.isMDXComponent=!0}}]);