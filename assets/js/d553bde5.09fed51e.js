"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[87166],{15680:(e,n,t)=>{t.d(n,{xA:()=>l,yg:()=>I});var i=t(96540);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function a(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);n&&(i=i.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,i)}return t}function s(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?a(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):a(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function o(e,n){if(null==e)return{};var t,i,r=function(e,n){if(null==e)return{};var t,i,r={},a=Object.keys(e);for(i=0;i<a.length;i++)t=a[i],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(i=0;i<a.length;i++)t=a[i],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var _=i.createContext({}),S=function(e){var n=i.useContext(_),t=n;return e&&(t="function"==typeof e?e(n):s(s({},n),e)),t},l=function(e){var n=S(e.components);return i.createElement(_.Provider,{value:n},e.children)},p="mdxType",d={inlineCode:"code",wrapper:function(e){var n=e.children;return i.createElement(i.Fragment,{},n)}},u=i.forwardRef((function(e,n){var t=e.components,r=e.mdxType,a=e.originalType,_=e.parentName,l=o(e,["components","mdxType","originalType","parentName"]),p=S(t),u=r,I=p["".concat(_,".").concat(u)]||p[u]||d[u]||a;return t?i.createElement(I,s(s({ref:n},l),{},{components:t})):i.createElement(I,s({ref:n},l))}));function I(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var a=t.length,s=new Array(a);s[0]=u;var o={};for(var _ in n)hasOwnProperty.call(n,_)&&(o[_]=n[_]);o.originalType=e,o[p]="string"==typeof e?e:r,s[1]=o;for(var S=2;S<a;S++)s[S]=t[S];return i.createElement.apply(null,s)}return i.createElement.apply(null,t)}u.displayName="MDXCreateElement"},69680:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>_,contentTitle:()=>s,default:()=>d,frontMatter:()=>a,metadata:()=>o,toc:()=>S});var i=t(58168),r=(t(96540),t(15680));const a={description:"This article describes how to use the QSPI Flash on the XIAO nRF52840 Sense.",title:"QSPI \u95ea\u5b58\u4f7f\u7528",keywords:["QSPI Flash"],image:"https://files.seeedstudio.com/wiki/seeed_logo/logo_2023.png",slug:"/cn/xiao-ble-qspi-flash-usage",last_update:{date:"10/30/2023",author:"\u5434\u98de\u98de"}},s="XIAO nRF52840 Sense\u4e0a \u7684 QSPI \u95ea\u5b58\u4f7f\u7528",o={unversionedId:"zh-CN/Sensor/SeeedStudio_XIAO/SeeedStudio_XIAO_nRF52840-Sense/CN_XIAO-BLE_QSPI-Usage",id:"zh-CN/Sensor/SeeedStudio_XIAO/SeeedStudio_XIAO_nRF52840-Sense/CN_XIAO-BLE_QSPI-Usage",title:"QSPI \u95ea\u5b58\u4f7f\u7528",description:"This article describes how to use the QSPI Flash on the XIAO nRF52840 Sense.",source:"@site/docs/zh-CN/Sensor/SeeedStudio_XIAO/SeeedStudio_XIAO_nRF52840-Sense/CN_XIAO-BLE_QSPI-Usage.md",sourceDirName:"zh-CN/Sensor/SeeedStudio_XIAO/SeeedStudio_XIAO_nRF52840-Sense",slug:"/cn/xiao-ble-qspi-flash-usage",permalink:"/cn/xiao-ble-qspi-flash-usage",draft:!1,editUrl:"https://github.com/Seeed-Studio/wiki-documents/blob/docusaurus-version/docs/zh-CN/Sensor/SeeedStudio_XIAO/SeeedStudio_XIAO_nRF52840-Sense/CN_XIAO-BLE_QSPI-Usage.md",tags:[],version:"current",lastUpdatedBy:"\u5434\u98de\u98de",lastUpdatedAt:1698624e3,formattedLastUpdatedAt:"Oct 30, 2023",frontMatter:{description:"This article describes how to use the QSPI Flash on the XIAO nRF52840 Sense.",title:"QSPI \u95ea\u5b58\u4f7f\u7528",keywords:["QSPI Flash"],image:"https://files.seeedstudio.com/wiki/seeed_logo/logo_2023.png",slug:"/cn/xiao-ble-qspi-flash-usage",last_update:{date:"10/30/2023",author:"\u5434\u98de\u98de"}},sidebar:"CNSidebar",previous:{title:"\u6570\u5b57\u9ea6\u514b\u98ce\uff08PDM\uff09\u4f7f\u7528",permalink:"/cn/XIAO-BLE-Sense-PDM-Usage"},next:{title:"\u5f15\u811a\u4e32\u53e3\u7684\u4f7f\u7528",permalink:"/cn/XIAO-BLE-Sense-Pin-Multiplexing"}},_={},S=[{value:"\u6280\u672f\u652f\u6301\u548c\u4ea7\u54c1\u8ba8\u8bba",id:"\u6280\u672f\u652f\u6301\u548c\u4ea7\u54c1\u8ba8\u8bba",level:2}],l={toc:S},p="wrapper";function d(e){let{components:n,...t}=e;return(0,r.yg)(p,(0,i.A)({},l,t,{components:n,mdxType:"MDXLayout"}),(0,r.yg)("h1",{id:"xiao-nrf52840-sense\u4e0a-\u7684-qspi-\u95ea\u5b58\u4f7f\u7528"},"XIAO nRF52840 Sense\u4e0a \u7684 QSPI \u95ea\u5b58\u4f7f\u7528"),(0,r.yg)("admonition",{type:"note"},(0,r.yg)("p",{parentName:"admonition"},"\u7279\u522b\u611f\u8c22\u793e\u533a\u7528\u6237 ",(0,r.yg)("strong",{parentName:"p"},"JM_Laird")," \u548c ",(0,r.yg)("strong",{parentName:"p"},"Haakonish")," \u5bf9\u672c\u6559\u7a0b\u7684\u652f\u6301\u548c\u5e2e\u52a9\uff01\u672c\u6587\u4e2d\u4f7f\u7528\u7684\u7a0b\u5e8f\u6765\u81ea Github \u7528\u6237 ",(0,r.yg)("strong",{parentName:"p"},"PMCheetham")," \uff0c\u6e90\u4ee3\u7801\u53ef\u4ee5\u5728 ",(0,r.yg)("strong",{parentName:"p"},(0,r.yg)("a",{parentName:"strong",href:"https://github.com/PMCheetham/SEEED_nRF52840_QSPI/tree/main"},"\u8fd9\u91cc"))," \u627e\u5230")),(0,r.yg)("p",null,"\u6b22\u8fce\u9605\u8bfb\u672c\u6559\u7a0b\uff0c\u4e86\u89e3\u5982\u4f55\u5728 XIAO nRF52840 \u548c XIAO nRF52840 Sense \u4e0a\u4f7f\u7528 QSPI Flash\uff01XIAO \u662f\u4e00\u6b3e\u529f\u80fd\u5f3a\u5927\u4e14\u7d27\u51d1\u7684\u4e3b\u677f\uff0c\u5177\u6709 256 KB RAM\u30011 MB \u95ea\u5b58\u548c 2 MB \u677f\u8f7d\u95ea\u5b58\u3002\u5728\u672c\u6559\u7a0b\u4e2d\uff0c\u60a8\u5c06\u5b66\u4e60\u5982\u4f55\u5728 XIAO \u677f\u4e0a\u4f7f\u7528 QSPI \u95ea\u5b58\uff0c\u8fd9\u53ef\u4ee5\u5927\u5927\u6269\u5c55\u5b58\u50a8\u5bb9\u91cf\u5e76\u52a0\u5feb\u60a8\u7684\u9879\u76ee\u3002\u8ba9\u6211\u4eec\u5f00\u59cb\u5427\uff01"),(0,r.yg)("p",null,"\u4ee5\u4e0b\u662f PMCheetham \u63d0\u4f9b\u7684\u793a\u4f8b\u7a0b\u5e8f\uff0c\u8be5\u7a0b\u5e8f\u9002\u7528\u4e8e XIAO nRF52840 Sense\u3002\u901a\u8fc7\u4ee5\u4e0b\u7a0b\u5e8f\uff0c\u60a8\u53ef\u4ee5\u5728 XIAO \u4e0a\u81ea\u7531\u4f7f\u7528 QSPI Flash\u3002"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-cpp"},'#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include "nrfx_qspi.h"\n#include "app_util_platform.h"\n#include "nrf_log.h"\n#include "nrf_log_ctrl.h"\n#include "nrf_log_default_backends.h"\n#include "sdk_config.h"\n#include "nrf_delay.h"\n#include "avr/interrupt.h"\n\n/* \n * Strange parts of this code ... Or things I don\'t understand\n * \n * After the first READ in Setup() it successfully reads the data (Returns 0 = NRFX_SUCCESS), but the status flag\n * has the top 8 bits set to 0xFF which causes nrfx_qspi_mem_busy_check() to show 17 (Returns 17 = NRFX_ERROR_BUSY). \n * However masking the STATUS register with 8 reveals the Ready Status = 1, QSPI is ready!\n * This was why I wrote the QSPI_IsReady().\n * \n * nrf_qspi_phy_conf_t not visible as a structure if you try and set it like this :\n *   QSPIConfig.phy_if {\n *     .xxx = yyy,\n *     .aaa = bbb\n *   };\n *   \n * I don\'t know what the significance of the 48ms Deep Power-down Mode (DPM) is. \n * Will it go into DPM if not used for 48ms and then take 48ms to wake up if instructed?\n * \n * Hope you enjoy this little snippet of code!  Feel free to butcher and use it.\n * Thanks to JM_Laird and Haakonish in Case ID: 224515.\n * And, yes, I could have made it neater, but really need to add some of the bits into a project and tidy them up there!\n */\n\n// QSPI Settings\n#define QSPI_STD_CMD_WRSR   0x01\n#define QSPI_STD_CMD_RSTEN  0x66\n#define QSPI_STD_CMD_RST    0x99\n#define QSPI_DPM_ENTER      0x0003 // 3 x 256 x 62.5ns = 48ms\n#define QSPI_DPM_EXIT       0x0003\n\nstatic uint32_t               *QSPI_Status_Ptr = (uint32_t*) 0x40029604;  // Setup for the SEEED XIAO BLE - nRF52840\nstatic nrfx_qspi_config_t     QSPIConfig;\nstatic nrf_qspi_cinstr_conf_t QSPICinstr_cfg;\nstatic const uint32_t         MemToUse = 64 * 1024;  // Alter this to create larger read writes, 64Kb is the size of the Erase\nstatic bool                   Debug_On = true;\nstatic uint16_t               pBuf[MemToUse / 2] = {0};  // 16bit used as that is what this memory is going to be used for\nstatic uint32_t               *BufMem = (uint32_t*) &pBuf;\nstatic bool                   QSPIWait = false;\n// QSPI Settings Complete\n\nstatic void qspi_handler(nrfx_qspi_evt_t event, void *p_context) {\n  // UNUSED_PARAMETER(p_context);\n  // Serial.println("QSPI Interrupt");\n  // if (event == NRFX_QSPI_EVENT_DONE) {\n  //   QSPI_HasFinished = true;\n  // }\n}\n\nstatic void QSPI_Status(char ASender[]) { // Prints the QSPI Status\n  Serial.print("(");\n  Serial.print(ASender);\n  Serial.print(") QSPI is busy/idle ... Result = ");\n  Serial.println(nrfx_qspi_mem_busy_check() & 8);\n  Serial.print("(");\n  Serial.print(ASender);\n  Serial.print(") QSPI Status flag = 0x");\n  Serial.print(NRF_QSPI->STATUS, HEX);\n  Serial.print(" (from NRF_QSPI) or 0x");\n  Serial.print(*QSPI_Status_Ptr, HEX);\n  Serial.println(" (from *QSPI_Status_Ptr)");\n}\n\nstatic void QSPI_PrintData(uint16_t *AnAddress, uint32_t AnAmount) {\n  uint32_t i;\n\n  Serial.print("Data :"); \n  for (i = 0; i < AnAmount; i++) {\n    Serial.print(" 0x");\n    Serial.print(*(AnAddress + i), HEX);\n  }\n  Serial.println("");\n}\n\nstatic nrfx_err_t QSPI_IsReady() {\n  if (((*QSPI_Status_Ptr & 8) == 8) && (*QSPI_Status_Ptr & 0x01000000) == 0) {\n    return NRFX_SUCCESS;  \n  } else {\n   return NRFX_ERROR_BUSY; \n  }\n}\n\nstatic nrfx_err_t QSPI_WaitForReady() {\n  while (QSPI_IsReady() == NRFX_ERROR_BUSY) {\n    if (Debug_On) {\n      Serial.print("*QSPI_Status_Ptr & 8 = ");\n      Serial.print(*QSPI_Status_Ptr & 8);\n      Serial.print(", *QSPI_Status_Ptr & 0x01000000 = 0x");\n      Serial.println(*QSPI_Status_Ptr & 0x01000000, HEX);\n      QSPI_Status("QSPI_WaitForReady");\n    }   \n  }\n  return NRFX_SUCCESS;\n}\n\nstatic nrfx_err_t QSPI_Initialise() { // Initialises the QSPI and NRF LOG\n  uint32_t Error_Code;\n\n  NRF_LOG_INIT(NULL); // Initialise the NRF Log\n  NRF_LOG_DEFAULT_BACKENDS_INIT();\n  // QSPI Config\n  QSPIConfig.xip_offset = NRFX_QSPI_CONFIG_XIP_OFFSET;                       \n  QSPIConfig.pins = { // Setup for the SEEED XIAO BLE - nRF52840                                                     \n   .sck_pin     = 21,                                \n   .csn_pin     = 25,                                \n   .io0_pin     = 20,                                \n   .io1_pin     = 24,                                \n   .io2_pin     = 22,                                \n   .io3_pin     = 23,                                \n  };                                                                  \n  QSPIConfig.irq_priority = (uint8_t)NRFX_QSPI_CONFIG_IRQ_PRIORITY;           \n  QSPIConfig.prot_if = {                                                        \n    // .readoc     = (nrf_qspi_readoc_t)NRFX_QSPI_CONFIG_READOC,\n    .readoc     = (nrf_qspi_readoc_t)NRF_QSPI_READOC_READ4O,       \n    // .writeoc    = (nrf_qspi_writeoc_t)NRFX_QSPI_CONFIG_WRITEOC,     \n    .writeoc    = (nrf_qspi_writeoc_t)NRF_QSPI_WRITEOC_PP4O,\n    .addrmode   = (nrf_qspi_addrmode_t)NRFX_QSPI_CONFIG_ADDRMODE,   \n    .dpmconfig  = false,                                            \n  };                   \n  QSPIConfig.phy_if.sck_freq   = (nrf_qspi_frequency_t)NRF_QSPI_FREQ_32MDIV1;  // I had to do it this way as it complained about nrf_qspi_phy_conf_t not being visible                                        \n  // QSPIConfig.phy_if.sck_freq   = (nrf_qspi_frequency_t)NRFX_QSPI_CONFIG_FREQUENCY; \n  QSPIConfig.phy_if.spi_mode   = (nrf_qspi_spi_mode_t)NRFX_QSPI_CONFIG_MODE;\n  QSPIConfig.phy_if.dpmen      = false;\n  // QSPI Config Complete\n  // Setup QSPI to allow for DPM but with it turned off\n  QSPIConfig.prot_if.dpmconfig = true;\n  NRF_QSPI->DPMDUR = (QSPI_DPM_ENTER << 16) | QSPI_DPM_EXIT; // Found this on the Nordic Q&A pages, Sets the Deep power-down mode timer\n  Error_Code = 1;\n  while (Error_Code != 0) {\n    Error_Code = nrfx_qspi_init(&QSPIConfig, NULL, NULL);\n    if (Error_Code != NRFX_SUCCESS) {\n      if (Debug_On) {\n        Serial.print("(QSPI_Initialise) nrfx_qspi_init returned : ");\n        Serial.println(Error_Code);\n      }\n    } else {\n      if (Debug_On) {\n        Serial.println("(QSPI_Initialise) nrfx_qspi_init successful");\n      }\n    }\n  }\n  QSPI_Status("QSPI_Initialise (Before QSIP_Configure_Memory)");\n  QSIP_Configure_Memory();\n  if (Debug_On) {\n    Serial.println("(QSPI_Initialise) Wait for QSPI to be ready ...");\n  }\n  NRF_QSPI->TASKS_ACTIVATE = 1;\n  QSPI_WaitForReady();\n  if (Debug_On) {\n    Serial.println("(QSPI_Initialise) QSPI is ready");\n  }\n  return QSPI_IsReady(); \n}\n\nstatic void QSPI_Erase(uint32_t AStartAddress) {\n  uint32_t   TimeTaken;\n  bool       QSPIReady = false;\n  bool       AlreadyPrinted = false;\n\n  if (Debug_On) {\n    Serial.println("(QSPI_Erase) Erasing memory");\n  }\n  while (!QSPIReady) {\n    if (QSPI_IsReady() != NRFX_SUCCESS) {\n      if (!AlreadyPrinted) {\n        QSPI_Status("QSPI_Erase (Waiting)");\n        AlreadyPrinted = true;\n      }\n    } else {\n      QSPIReady = true;\n      QSPI_Status("QSPI_Erase (Waiting Loop Breakout)");\n    }\n  }\n  if (Debug_On) {\n    QSPI_Status("QSPI_Erase (Finished Waiting)");\n    TimeTaken = millis();\n  }\n  if (nrfx_qspi_erase(NRF_QSPI_ERASE_LEN_64KB, AStartAddress) != NRFX_SUCCESS) {\n    if (Debug_On) {\n      Serial.print("(QSPI_Initialise_Page) QSPI Address 0x");\n      Serial.print(AStartAddress, HEX);\n      Serial.println(" failed to erase!");\n    }\n  } else {     \n    if (Debug_On) {\n      TimeTaken = millis() - TimeTaken;\n      Serial.print("(QSPI_Initialise_Page) QSPI took ");\n      Serial.print(TimeTaken);\n      Serial.println("ms to erase a 64Kb page");\n    }\n  }\n}\n\nstatic void QSIP_Configure_Memory() {\n  // uint8_t  temporary = 0x40;\n  uint8_t  temporary[] = {0x00, 0x02};\n  uint32_t Error_Code;\n  \n  QSPICinstr_cfg = {\n    .opcode    = QSPI_STD_CMD_RSTEN,\n    .length    = NRF_QSPI_CINSTR_LEN_1B,\n    .io2_level = true,\n    .io3_level = true,\n    .wipwait   = QSPIWait,\n    .wren      = true\n  };\n  QSPI_WaitForReady();\n  if (nrfx_qspi_cinstr_xfer(&QSPICinstr_cfg, NULL, NULL) != NRFX_SUCCESS) { // Send reset enable\n    if (Debug_On) {\n      Serial.println("(QSIP_Configure_Memory) QSPI \'Send reset enable\' failed!");\n    }\n  } else {\n    QSPICinstr_cfg.opcode = QSPI_STD_CMD_RST;\n    QSPI_WaitForReady();\n    if (nrfx_qspi_cinstr_xfer(&QSPICinstr_cfg, NULL, NULL) != NRFX_SUCCESS) { // Send reset command\n      if (Debug_On) {\n        Serial.println("(QSIP_Configure_Memory) QSPI Reset failed!");\n      }\n    } else {\n      QSPICinstr_cfg.opcode = QSPI_STD_CMD_WRSR;\n      QSPICinstr_cfg.length = NRF_QSPI_CINSTR_LEN_3B;\n      QSPI_WaitForReady();\n      if (nrfx_qspi_cinstr_xfer(&QSPICinstr_cfg, &temporary, NULL) != NRFX_SUCCESS) { // Switch to qspi mode\n        if (Debug_On) {\n          Serial.println("(QSIP_Configure_Memory) QSPI failed to switch to QSPI mode!");\n        }\n      } else {\n          QSPI_Status("QSIP_Configure_Memory");\n      }\n    }\n  }\n}\n\nvoid setup() {\n  uint32_t Error_Code;\n  uint32_t TimeTaken;\n  uint16_t i;\n\n  delay(10000);\n  Serial.begin(9600);\n  while (!Serial) {}\n\n  if (Debug_On) {\n    Serial.println("(Setup) QSPI Initialising ...");\n  }\n  if (QSPI_Initialise() != NRFX_SUCCESS) {\n    if (Debug_On) {\n      Serial.println("(Setup) QSPI Memory failed to start!");\n    }\n  } else {\n    if (Debug_On) {\n      Serial.println("(Setup) QSPI initialised and ready");\n      QSPI_Status("Setup (After initialise)");\n    }\n  }\n\n  if (Debug_On) {\n    Serial.print("(Setup) QSPI is about to be read and then erased. Current busy state is = ");\n    Serial.println(QSPI_IsReady());\n  }\n\n  // QSPI Speed Test\n  if (Debug_On) {\n    QSPI_Status("Setup (Before read)");\n    TimeTaken = millis();\n  }\n  Error_Code = nrfx_qspi_read(pBuf, MemToUse, 0x0);\n  if (Debug_On) {\n    TimeTaken = millis() - TimeTaken;\n    Serial.print("(Setup) QSPI took ");\n    Serial.print(TimeTaken);\n    Serial.print("ms to read ");\n    Serial.print(MemToUse / 1024);\n    Serial.print("Kb ... Read result = ");\n    Serial.println(Error_Code);\n    QSPI_Status("Setup (After read)");\n    QSPI_WaitForReady();\n    QSPI_PrintData(&pBuf[0], 10);\n  }\n  if (Debug_On) {\n    Serial.println("QSPI Erasing 64Kb of memory");\n  }\n  QSPI_Erase(0); \n  if (Debug_On) {\n    Serial.println("(Setup) QSPI read after erase");\n    TimeTaken = millis();\n  }\n  QSPI_WaitForReady();\n  Error_Code = nrfx_qspi_read(pBuf, MemToUse, 0x0);\n  if (Debug_On) {\n    TimeTaken = millis() - TimeTaken;\n    Serial.print("(Setup) QSPI took ");\n    Serial.print(TimeTaken);\n    Serial.print("ms to read ");\n    Serial.print(MemToUse / 1024);\n    Serial.print("Kb ... Read result = ");\n    Serial.println(Error_Code);\n    QSPI_WaitForReady();\n    QSPI_PrintData(&pBuf[0], 10);\n  }\n  for (i = 0; i < MemToUse / 2; i++) {\n    pBuf[i] = i * 2;\n  }\n  QSPI_WaitForReady();\n  if (Debug_On) {\n    Serial.println("(Setup) Just before QSPI write");\n    TimeTaken = millis();\n  }\n  Error_Code = nrfx_qspi_write(pBuf, MemToUse, 0x0);\n  if (Debug_On) {\n    TimeTaken = millis() - TimeTaken;\n    Serial.print("(Setup) QSPI took ");\n    Serial.print(TimeTaken);\n    Serial.print("ms to write ");\n    Serial.print(MemToUse / 1024);\n    Serial.print("Kb ... Write result = ");\n    Serial.println(Error_Code);\n  }\n  QSPI_WaitForReady();\n  if (Debug_On) {\n    Serial.println("(Setup) Just before QSPI read");\n    TimeTaken = millis();\n  }\n  Error_Code = nrfx_qspi_read(pBuf, MemToUse, 0x0);\n  if (Debug_On) {\n    TimeTaken = millis() - TimeTaken;\n    Serial.print("(Setup) QSPI took ");\n    Serial.print(TimeTaken);\n    Serial.print("ms to read ");\n    Serial.print(MemToUse / 1024);\n    Serial.print("Kb ... Read result = ");\n    Serial.println(Error_Code);\n    QSPI_WaitForReady();\n    QSPI_PrintData(&pBuf[0], 10);\n  }\n  QSPI_WaitForReady();\n  QSPI_Status("Setup");\n  // QSPI Speed Test Complete\n}\n\nvoid loop() {\n  delay(10000);\n}\n')),(0,r.yg)("p",null,"\u8be5\u7a0b\u5e8f\u4ec5\u9002\u7528\u4e8e ",(0,r.yg)("strong",{parentName:"p"},"mbed")," \u677f, \u56e0\u6b64\u8bf7\u5728\u7f16\u8bd1\u548c\u4e0a\u4f20\u65f6\u5728 mbed \u9009\u9879\u5361\u4e0b\u9009\u62e9 XIAO nRF52840\u3002"),(0,r.yg)("p",{style:{textAlign:"center"}},(0,r.yg)("img",{src:"https://files.seeedstudio.com/wiki/XIAO-BLE/XIAO_nRF52840_new7.png",alt:"pir",width:800,height:"auto"})),(0,r.yg)("h2",{id:"\u6280\u672f\u652f\u6301\u548c\u4ea7\u54c1\u8ba8\u8bba"},"\u6280\u672f\u652f\u6301\u548c\u4ea7\u54c1\u8ba8\u8bba"),(0,r.yg)("p",null,"\u611f\u8c22\u60a8\u9009\u62e9\u6211\u4eec\u7684\u4ea7\u54c1\uff01\u6211\u4eec\u5728\u8fd9\u91cc\u4e3a\u60a8\u63d0\u4f9b\u4e0d\u540c\u7684\u652f\u6301\uff0c\u4ee5\u786e\u4fdd\u60a8\u5bf9\u6211\u4eec\u4ea7\u54c1\u7684\u4f53\u9a8c\u5c3d\u53ef\u80fd\u987a\u7545\u3002\u6211\u4eec\u63d0\u4f9b\u591a\u79cd\u6c9f\u901a\u6e20\u9053\uff0c\u4ee5\u6ee1\u8db3\u4e0d\u540c\u7684\u504f\u597d\u548c\u9700\u6c42\u3002"),(0,r.yg)("div",{class:"button_tech_support_container"},(0,r.yg)("a",{href:"https://forum.seeedstudio.com/",class:"button_forum"}),(0,r.yg)("a",{href:"https://www.seeedstudio.com/contacts",class:"button_email"})),(0,r.yg)("div",{class:"button_tech_support_container"},(0,r.yg)("a",{href:"https://discord.gg/eWkprNDMU7",class:"button_discord"}),(0,r.yg)("a",{href:"https://github.com/Seeed-Studio/wiki-documents/discussions/69",class:"button_discussion"})))}d.isMDXComponent=!0}}]);