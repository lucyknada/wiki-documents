"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[11704],{15680:(e,t,n)=>{n.d(t,{xA:()=>u,yg:()=>g});var i=n(96540);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,i,a=function(e,t){if(null==e)return{};var n,i,a={},o=Object.keys(e);for(i=0;i<o.length;i++)n=o[i],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(i=0;i<o.length;i++)n=o[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var s=i.createContext({}),d=function(e){var t=i.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},u=function(e){var t=d(e.components);return i.createElement(s.Provider,{value:t},e.children)},c="mdxType",p={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},h=i.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,s=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),c=d(n),h=a,g=c["".concat(s,".").concat(h)]||c[h]||p[h]||o;return n?i.createElement(g,r(r({ref:t},u),{},{components:n})):i.createElement(g,r({ref:t},u))}));function g(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,r=new Array(o);r[0]=h;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[c]="string"==typeof e?e:a,r[1]=l;for(var d=2;d<o;d++)r[d]=n[d];return i.createElement.apply(null,r)}return i.createElement.apply(null,n)}h.displayName="MDXCreateElement"},91353:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>r,default:()=>p,frontMatter:()=>o,metadata:()=>l,toc:()=>d});var i=n(58168),a=(n(96540),n(15680));const o={description:"This tutorial introduces the use of the expansion board function of the circular screen.",title:"Hardware Usage",keywords:["Round display","XIAO"],image:"https://files.seeedstudio.com/wiki/seeed_logo/logo_2023.png",slug:"/seeedstudio_round_display_usage",last_update:{date:"04/27/2023",author:"Citric"}},r="Use of the Seeed Studio Round Display extension",l={unversionedId:"Sensor/SeeedStudio_XIAO/SeeedStudio_XIAO_Expansion_board/Round-display-for-XIAO/SeeedStudio_RoundDisplay_Usage",id:"Sensor/SeeedStudio_XIAO/SeeedStudio_XIAO_Expansion_board/Round-display-for-XIAO/SeeedStudio_RoundDisplay_Usage",title:"Hardware Usage",description:"This tutorial introduces the use of the expansion board function of the circular screen.",source:"@site/docs/Sensor/SeeedStudio_XIAO/SeeedStudio_XIAO_Expansion_board/Round-display-for-XIAO/SeeedStudio_RoundDisplay_Usage.md",sourceDirName:"Sensor/SeeedStudio_XIAO/SeeedStudio_XIAO_Expansion_board/Round-display-for-XIAO",slug:"/seeedstudio_round_display_usage",permalink:"/seeedstudio_round_display_usage",draft:!1,editUrl:"https://github.com/Seeed-Studio/wiki-documents/blob/docusaurus-version/docs/Sensor/SeeedStudio_XIAO/SeeedStudio_XIAO_Expansion_board/Round-display-for-XIAO/SeeedStudio_RoundDisplay_Usage.md",tags:[],version:"current",lastUpdatedBy:"Citric",lastUpdatedAt:1682553600,formattedLastUpdatedAt:"Apr 27, 2023",frontMatter:{description:"This tutorial introduces the use of the expansion board function of the circular screen.",title:"Hardware Usage",keywords:["Round display","XIAO"],image:"https://files.seeedstudio.com/wiki/seeed_logo/logo_2023.png",slug:"/seeedstudio_round_display_usage",last_update:{date:"04/27/2023",author:"Citric"}},sidebar:"ProductSidebar",previous:{title:"Getting Started with Seeed Studio Round Display for XIAO",permalink:"/get_start_round_display"},next:{title:"Using LVGL and TFT for all XIAO Series",permalink:"/using_lvgl_and_tft_on_round_display"}},s={},d=[{value:"Getting Started",id:"getting-started",level:2},{value:"Install a microSD card",id:"install-a-microsd-card",level:3},{value:"Install the RTC battery",id:"install-the-rtc-battery",level:3},{value:"Install power supply battery",id:"install-power-supply-battery",level:3},{value:"Round Display switch",id:"round-display-switch",level:3},{value:"Round Display circuit design",id:"round-display-circuit-design",level:3},{value:"Measure battery voltage pins",id:"measure-battery-voltage-pins",level:4},{value:"SD card circuit pins",id:"sd-card-circuit-pins",level:4},{value:"RTC circuit pins",id:"rtc-circuit-pins",level:4},{value:"Touch screen circuit pins",id:"touch-screen-circuit-pins",level:4},{value:"Round Display library Overview",id:"round-display-library-overview",level:2},{value:"lv_xiao_round_screen.h",id:"lv_xiao_round_screenh",level:3},{value:"lv_hardware_test.h",id:"lv_hardware_testh",level:3},{value:"KE Button &amp; GPIO",id:"ke-button--gpio",level:2},{value:"Measure battery voltage",id:"measure-battery-voltage",level:2},{value:"Program annotation",id:"program-annotation",level:3},{value:"RTC function",id:"rtc-function",level:2},{value:"Off-line manual calibration of the RTC",id:"off-line-manual-calibration-of-the-rtc",level:3},{value:"Get RTC time",id:"get-rtc-time",level:3},{value:"Network calibration RTC time",id:"network-calibration-rtc-time",level:3},{value:"Simple dial based on RTC time",id:"simple-dial-based-on-rtc-time",level:3},{value:"SD card function",id:"sd-card-function",level:2},{value:"All XIAO series (In addition to the XIAO nRF52840 series)",id:"all-xiao-series-in-addition-to-the-xiao-nrf52840-series",level:3},{value:"XIAO nRF52840",id:"xiao-nrf52840",level:3},{value:"XIAO ESP32S3 &amp; XIAO ESP32S3 Sense &amp; XIAO ESP32C3",id:"xiao-esp32s3--xiao-esp32s3-sense--xiao-esp32c3",level:3},{value:"Screen function",id:"screen-function",level:2},{value:"Touch function",id:"touch-function",level:3},{value:"Display Functions",id:"display-functions",level:3},{value:"Tech Support &amp; Product Discussion",id:"tech-support--product-discussion",level:2},{value:"Q1: Why do I get an error when I use XIAO nRF52840 (Sense)?",id:"q1-why-do-i-get-an-error-when-i-use-xiao-nrf52840-sense",level:3},{value:"Q2: When uploading a program for XIAO RP2040, an error occurs: unaligned opcodes detected in executable segment?",id:"q2-when-uploading-a-program-for-xiao-rp2040-an-error-occurs-unaligned-opcodes-detected-in-executable-segment",level:3},{value:"Q3: Why do I get a pin definition error when I compile a circular screen program for the XIAO SAMD21?",id:"q3-why-do-i-get-a-pin-definition-error-when-i-compile-a-circular-screen-program-for-the-xiao-samd21",level:3},{value:"Q4: Why does the screen not display after I upload the program to XIAO ESP32C3?",id:"q4-why-does-the-screen-not-display-after-i-upload-the-program-to-xiao-esp32c3",level:3},{value:"Tech Support &amp; Product Discussion",id:"tech-support--product-discussion-1",level:2}],u={toc:d},c="wrapper";function p(e){let{components:t,...n}=e;return(0,a.yg)(c,(0,i.A)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,a.yg)("h1",{id:"use-of-the-seeed-studio-round-display-extension"},"Use of the Seeed Studio Round Display extension"),(0,a.yg)("div",{style:{textAlign:"center"}},(0,a.yg)("img",{src:"https://files.seeedstudio.com/wiki/round_display_for_xiao/79.jpg",style:{width:800,height:"auto"}})),(0,a.yg)("div",{class:"get_one_now_container",style:{textAlign:"center"}},(0,a.yg)("a",{class:"get_one_now_item",href:"https://www.seeedstudio.com/Seeed-Studio-Round-Display-for-XIAO-p-5638.html"},(0,a.yg)("strong",null,(0,a.yg)("span",null,(0,a.yg)("font",{color:"FFFFFF",size:"4"}," Get One Now \ud83d\uddb1\ufe0f"))))),(0,a.yg)("br",null),(0,a.yg)("p",null,"This tutorial will explain in detail how to use the extended functions on the Round Display, including the use of the RTC function, SD card function, and screen function."),(0,a.yg)("h2",{id:"getting-started"},"Getting Started"),(0,a.yg)("p",null,"The content of this tutorial supports all XIAO series products. So you can use any XIAO to complete the content of this Wiki."),(0,a.yg)("p",null,"If you are using Round Display for the first time, you may want to read the prep content we wrote for it earlier and configure the library's environment according to this content to make sure you can use Round Display smoothly."),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},(0,a.yg)("a",{parentName:"strong",href:"https://wiki.seeedstudio.com/get_start_round_display#getting-started"},"Prep for using Seeed Studio Round Display for XIAO")))),(0,a.yg)("h3",{id:"install-a-microsd-card"},"Install a microSD card"),(0,a.yg)("p",null,"Round Display supports the use of microSD cards with ",(0,a.yg)("strong",{parentName:"p"},"FAT32")," format no larger than ",(0,a.yg)("strong",{parentName:"p"},"32GB"),". When installing a microSD card, the gold finger of the microSD card should be inserted towards the inside of the board."),(0,a.yg)("div",{style:{textAlign:"center"}},(0,a.yg)("img",{src:"https://files.seeedstudio.com/wiki/round_display_for_xiao/64.jpg",style:{width:500,height:"auto"}})),(0,a.yg)("h3",{id:"install-the-rtc-battery"},"Install the RTC battery"),(0,a.yg)("p",null,"Round Display supports RTC function, and it has a built-in PCF8563T chip. If you need to use the RTC function, you may need a coin cell battery to keep the RTC working."),(0,a.yg)("p",null,"We recommend using CR927 series button cell batteries with the positive (flat) terminal facing outward and the negative (slightly protruding surface) facing inward when installed."),(0,a.yg)("div",{style:{textAlign:"center"}},(0,a.yg)("img",{src:"https://files.seeedstudio.com/wiki/round_display_for_xiao/65.jpg",style:{width:500,height:"auto"}})),(0,a.yg)("admonition",{type:"note"},(0,a.yg)("p",{parentName:"admonition"},"The above picture only shows the battery installation direction, not fully installed battery. The correct installation of the battery should be fully inserted into the battery holder.")),(0,a.yg)("h3",{id:"install-power-supply-battery"},"Install power supply battery"),(0,a.yg)("p",null,"Round Display supports external 3.7V lithium battery. And with a built-in power management chip, the battery can be charged through XIAO's USB port."),(0,a.yg)("div",{style:{textAlign:"center"}},(0,a.yg)("img",{src:"https://files.seeedstudio.com/wiki/round_display_for_xiao/77.jpg",style:{width:500,height:"auto"}})),(0,a.yg)("p",null,"The Round Display also has a charging indicator. It has three states:"),(0,a.yg)("ol",null,(0,a.yg)("li",{parentName:"ol"},"The indicator light is always on at low brightness when the lithium battery is not connected."),(0,a.yg)("li",{parentName:"ol"},"Connect the lithium battery and the red light is always on at high brightness when charging the lithium battery."),(0,a.yg)("li",{parentName:"ol"},"Lithium battery is connected and the light goes off when the battery is fully charged.")),(0,a.yg)("div",{style:{textAlign:"center"}},(0,a.yg)("img",{src:"https://files.seeedstudio.com/wiki/round_display_for_xiao/78.jpg",style:{width:500,height:"auto"}})),(0,a.yg)("h3",{id:"round-display-switch"},"Round Display switch"),(0,a.yg)("p",null,"There is also a switch on the Round Display. The switch is used to control the on/off of the display and the power supply to the XIAO. When you flip the switch to OFF, the battery will not power the XIAO and the display screen will turn off. When you turn the switch to ON, the display will light up and the battery will power the XIAO (provided that a power supply battery is installed) to ensure that the program runs."),(0,a.yg)("div",{style:{textAlign:"center"}},(0,a.yg)("img",{src:"https://files.seeedstudio.com/wiki/round_display_for_xiao/66.jpg",style:{width:500,height:"auto"}})),(0,a.yg)("admonition",{type:"note"},(0,a.yg)("p",{parentName:"admonition"},"Powering the XIAO in the description here refers to powering the XIAO through the Round Display. If you are powering the XIAO directly, then the switch on the Round Display cannot disconnect the power to the XIAO. If you want to control the whole device through the switch on the Round Display, you need to install the power supply battery on the Round Display."),(0,a.yg)("p",{parentName:"admonition"},"Also note that some XIAOs (such as the XIAO ESP32C3) may require a press of the Reset button on the XIAO to start working when powering down and powering up again to run a program.")),(0,a.yg)("h3",{id:"round-display-circuit-design"},"Round Display circuit design"),(0,a.yg)("p",null,"In this section, we will intercept the circuit schematic of the hardware of Round Display and inform users which IO pins on XIAO are used in the hardware of Round Display to avoid conflicts in the use of IO."),(0,a.yg)("h4",{id:"measure-battery-voltage-pins"},"Measure battery voltage pins"),(0,a.yg)("div",{style:{textAlign:"center"}},(0,a.yg)("img",{src:"https://files.seeedstudio.com/wiki/round_display_for_xiao/70.png",style:{width:400,height:"auto"}})),(0,a.yg)("p",null,"For the design of the Round Display, we used the ",(0,a.yg)("strong",{parentName:"p"},"A0/D0")," pins on the XIAO to connect to the circuitry of the on-board battery. The remaining battery charge can be obtained by reading the analog value of this pin."),(0,a.yg)("h4",{id:"sd-card-circuit-pins"},"SD card circuit pins"),(0,a.yg)("div",{style:{textAlign:"center"}},(0,a.yg)("img",{src:"https://files.seeedstudio.com/wiki/round_display_for_xiao/67.png",style:{width:800,height:"auto"}})),(0,a.yg)("p",null,"The SD card section uses the four IO ports on the XIAO, which are used as shown in the table below."),(0,a.yg)("div",{class:"table-center"},(0,a.yg)("table",{align:"center"},(0,a.yg)("tr",null,(0,a.yg)("th",{align:"center"},"XIAO GPIO"),(0,a.yg)("th",{align:"center"},"microSD Card Slot")),(0,a.yg)("tr",null,(0,a.yg)("td",{align:"center"},"D2"),(0,a.yg)("td",{align:"center"},"CS")),(0,a.yg)("tr",null,(0,a.yg)("td",{align:"center"},"D8"),(0,a.yg)("td",{align:"center"},"SCK")),(0,a.yg)("tr",null,(0,a.yg)("td",{align:"center"},"D9"),(0,a.yg)("td",{align:"center"},"MISO")),(0,a.yg)("tr",null,(0,a.yg)("td",{align:"center"},"D10"),(0,a.yg)("td",{align:"center"},"MOSI")))),(0,a.yg)("h4",{id:"rtc-circuit-pins"},"RTC circuit pins"),(0,a.yg)("div",{style:{textAlign:"center"}},(0,a.yg)("img",{src:"https://files.seeedstudio.com/wiki/round_display_for_xiao/68.png",style:{width:500,height:"auto"}})),(0,a.yg)("p",null,"The RTC function uses the IIC protocol, so it occupies the ",(0,a.yg)("strong",{parentName:"p"},"D5 (SCL)")," and ",(0,a.yg)("strong",{parentName:"p"},"D4 (SDA)")," pins."),(0,a.yg)("h4",{id:"touch-screen-circuit-pins"},"Touch screen circuit pins"),(0,a.yg)("div",{style:{textAlign:"center"}},(0,a.yg)("img",{src:"https://files.seeedstudio.com/wiki/round_display_for_xiao/69.png",style:{width:400,height:"auto"}})),(0,a.yg)("p",null,"The touch screen section uses the four IO ports on the XIAO, which are used as shown in the table below."),(0,a.yg)("div",{class:"table-center"},(0,a.yg)("table",{align:"center"},(0,a.yg)("tr",null,(0,a.yg)("th",{align:"center"},"XIAO GPIO"),(0,a.yg)("th",{align:"center"},"Touch screen")),(0,a.yg)("tr",null,(0,a.yg)("td",{align:"center"},"D4 (SDA)"),(0,a.yg)("td",{align:"center"},"Touch Screen IIC")),(0,a.yg)("tr",null,(0,a.yg)("td",{align:"center"},"D5 (SCL)"),(0,a.yg)("td",{align:"center"},"Touch Screen IIC")),(0,a.yg)("tr",null,(0,a.yg)("td",{align:"center"},"D3"),(0,a.yg)("td",{align:"center"},"LCD_DC")),(0,a.yg)("tr",null,(0,a.yg)("td",{align:"center"},"D1"),(0,a.yg)("td",{align:"center"},"LCD_CS")),(0,a.yg)("tr",null,(0,a.yg)("td",{align:"center"},"D7"),(0,a.yg)("td",{align:"center"},"TP_INT")),(0,a.yg)("tr",null,(0,a.yg)("td",{align:"center"},"D6"),(0,a.yg)("td",{align:"center"},"Screen backlight")))),(0,a.yg)("h2",{id:"round-display-library-overview"},"Round Display library Overview"),(0,a.yg)("p",null,"The vast majority of Round Display's software development is based on XIAO's own hardware support. The graphics are based on the TFT library, the LVGL library, and the Arduino GFX library."),(0,a.yg)("p",null,"In order to facilitate users to use the functions on Round Display, we wrote a separate library that mainly calls the interfaces of the above libraries to reduce the threshold of independent development by the users themselves when they arrive at a later stage. In this chapter, we will focus on what are the functions of these libraries that I prepared for Round Display and how to use them respectively."),(0,a.yg)("div",{class:"github_container",style:{textAlign:"center"}},(0,a.yg)("a",{class:"github_item",href:"https://github.com/Seeed-Studio/Seeed_Arduino_RoundDisplay"},(0,a.yg)("strong",null,(0,a.yg)("span",null,(0,a.yg)("font",{color:"FFFFFF",size:"4"}," Download the Libraries")))," ",(0,a.yg)("svg",{"aria-hidden":"true",focusable:"false",role:"img",className:"mr-2",viewBox:"-3 10 9 1",width:16,height:16,fill:"currentColor",style:{textAlign:"center",display:"inline-block",userSelect:"none",verticalAlign:"text-bottom",overflow:"visible"}},(0,a.yg)("path",{d:"M8 0c4.42 0 8 3.58 8 8a8.013 8.013 0 0 1-5.45 7.59c-.4.08-.55-.17-.55-.38 0-.27.01-1.13.01-2.2 0-.75-.25-1.23-.54-1.48 1.78-.2 3.65-.88 3.65-3.95 0-.88-.31-1.59-.82-2.15.08-.2.36-1.02-.08-2.12 0 0-.67-.22-2.2.82-.64-.18-1.32-.27-2-.27-.68 0-1.36.09-2 .27-1.53-1.03-2.2-.82-2.2-.82-.44 1.1-.16 1.92-.08 2.12-.51.56-.82 1.28-.82 2.15 0 3.06 1.86 3.75 3.64 3.95-.23.2-.44.55-.51 1.07-.46.21-1.61.55-2.33-.66-.15-.24-.6-.83-1.23-.82-.67.01-.27.38.01.53.34.19.73.9.82 1.13.16.45.68 1.31 2.69.94 0 .67.01 1.3.01 1.49 0 .21-.15.45-.55.38A7.995 7.995 0 0 1 0 8c0-4.42 3.58-8 8-8Z"})))),(0,a.yg)("br",null),(0,a.yg)("h3",{id:"lv_xiao_round_screenh"},"lv_xiao_round_screen.h"),(0,a.yg)("p",null,"The ",(0,a.yg)("inlineCode",{parentName:"p"},"lv_xiao_round_screen.h")," file is a header file in the Round Display library, which drives the display and touch functions of the screen."),(0,a.yg)("p",null,"A macro definition check is made at the beginning of the file and is intended to require that developers using Round Display need to select the graphics library you want to develop when drawing screen patterns. There are two choices, ",(0,a.yg)("strong",{parentName:"p"},"TFT")," and ",(0,a.yg)("strong",{parentName:"p"},"Arduino GFX"),". if you choose the ",(0,a.yg)("strong",{parentName:"p"},"TFT")," library, then it is the one that can support ",(0,a.yg)("strong",{parentName:"p"},"LVGL"),"."),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-cpp"},'#if defined(USE_TFT_ESPI_LIBRARY) && defined(USE_ARDUINO_GFX_LIBRARY)\n#error "More than one graphics library is defined."\n#elif defined(USE_TFT_ESPI_LIBRARY)\n#include <TFT_eSPI.h>\nTFT_eSPI tft = TFT_eSPI(SCREEN_WIDTH, SCREEN_HEIGHT);\n#elif defined(USE_ARDUINO_GFX_LIBRARY)\n#include <Arduino_GFX_Library.h>\n')),(0,a.yg)("p",null,"The reason for this design is that certain XIAO has its own advantages in drawing patterns on different graphic libraries. For example if you are using the XIAO nRF52840, then you may be more memory efficient and stable using the Arduino GFX library. For XIAO ESP32S3, a large memory XIAO has an inherent advantage in handling graphics libraries like LVGL, and is also able to draw more complex patterns and UI."),(0,a.yg)("p",null,"So if you need to draw a pattern using Round Display, don't forget to select the graphics library you want to use and define it at the beginning of your Arduino program."),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},"If you want to use the TFT library or the LVGL library:")),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-cpp"},"#define USE_TFT_ESPI_LIBRARY\n")),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},"If you want to use the Arduino GFX library:")),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-cpp"},"#define USE_ARDUINO_GFX_LIBRARY\n")),(0,a.yg)("ol",null,(0,a.yg)("li",{parentName:"ol"},(0,a.yg)("p",{parentName:"li"},(0,a.yg)("inlineCode",{parentName:"p"},"void xiao_disp_init(void)"),": This function is used to initialize the display backlight and rotate the display to its initial position, with the device display backplane color being solid black. This function is generally not used alone, and the ",(0,a.yg)("inlineCode",{parentName:"p"},"lv_xiao_disp_init()")," function is used instead when initialization is needed.")),(0,a.yg)("li",{parentName:"ol"},(0,a.yg)("p",{parentName:"li"},(0,a.yg)("inlineCode",{parentName:"p"},"void lv_xiao_disp_init(void)"),": Initialize the backlight, and initialize the display driver. Typically used for display initialization.")),(0,a.yg)("li",{parentName:"ol"},(0,a.yg)("p",{parentName:"li"},(0,a.yg)("inlineCode",{parentName:"p"},"bool chsc6x_is_pressed(void)"),": This function is used to check if the screen is touched, and returns ",(0,a.yg)("inlineCode",{parentName:"p"},"Ture")," if the screen is touched.")),(0,a.yg)("li",{parentName:"ol"},(0,a.yg)("p",{parentName:"li"},(0,a.yg)("inlineCode",{parentName:"p"},"void lv_xiao_touch_init(void)"),": This function is used to initialize the touch screen and its driver.")),(0,a.yg)("li",{parentName:"ol"},(0,a.yg)("p",{parentName:"li"},(0,a.yg)("inlineCode",{parentName:"p"},"void chsc6x_read( lv_indev_drv_t * indev_driver, lv_indev_data_t * data )"),": This function is used to get the coordinate points of the touch screen."))),(0,a.yg)("h3",{id:"lv_hardware_testh"},"lv_hardware_test.h"),(0,a.yg)("p",null,"The ",(0,a.yg)("inlineCode",{parentName:"p"},"lv_hardware_test.h")," file is the header file in the sample ",(0,a.yg)("strong",{parentName:"p"},"HardwareTest")," in the Round Display library. This header file prepares most of the hardware usage functions for Round Display."),(0,a.yg)("p",null,"If you want to use the functions inside this header file, you can copy the file directly to the same file directory of your Arduino file."),(0,a.yg)("ol",null,(0,a.yg)("li",{parentName:"ol"},(0,a.yg)("p",{parentName:"li"},(0,a.yg)("inlineCode",{parentName:"p"},"int32_t battery_level_percent(void)"),": By calling this function, you can read and calculate the battery charge percentage to display the battery level in the application.")),(0,a.yg)("li",{parentName:"ol"},(0,a.yg)("p",{parentName:"li"},(0,a.yg)("inlineCode",{parentName:"p"},"void lv_hardware_test(void)"),": This function is used to test all hardware functions, including screen display, screen touch, RTC clock and battery level. You can refer to this function writing method to complete the development of the Round Display function you want."))),(0,a.yg)("h2",{id:"ke-button--gpio"},"KE Button & GPIO"),(0,a.yg)("p",null,"On the new version of the Round Display, we have designed a KE switch to selectively release certain GPIOs for selective use by the user."),(0,a.yg)("p",null,"The KE switch is designed in the middle of the microSD card slot and the row of pins that connect to the XIAO."),(0,a.yg)("div",{style:{textAlign:"center"}},(0,a.yg)("img",{src:"https://files.seeedstudio.com/wiki/round_display_for_xiao/90.jpg",style:{width:400,height:"auto"}})),(0,a.yg)("p",null,"The circuit design for this switch is shown below."),(0,a.yg)("div",{style:{textAlign:"center"}},(0,a.yg)("img",{src:"https://files.seeedstudio.com/wiki/round_display_for_xiao/91.png",style:{width:400,height:"auto"}})),(0,a.yg)("p",null,"This means that when the switch is closed ",(0,a.yg)("strong",{parentName:"p"},"(toggled to the ON side)")," then the Round Display's battery voltage reading function and display backlight function become available."),(0,a.yg)("p",null,"When the switch is disconnected ",(0,a.yg)("strong",{parentName:"p"},"(toggled to the digital side)"),", then pins A0 and D6 on the XIAO are the available states."),(0,a.yg)("h2",{id:"measure-battery-voltage"},"Measure battery voltage"),(0,a.yg)("p",null,"Due to the lack of IO pins on the XIAO, the majority of XIAOs are unable to measure battery voltage, although the power management chip is configured on some XIAOs to allow external batteries."),(0,a.yg)("p",null,"But if you choose to use Round Dislay and power the XIAO through the screen, then measuring the battery voltage will become a reality."),(0,a.yg)("p",null,"The following is a sample program to measure the battery voltage. The function ",(0,a.yg)("inlineCode",{parentName:"p"},"battery_level_percent()")," is selected from the ",(0,a.yg)("inlineCode",{parentName:"p"},"lv_hardware_test.h")," file."),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-cpp"},'#define NUM_ADC_SAMPLE 20           // Sampling frequency\n#define RP2040_VREF 3300            // When you use the XIAO RP2040, you need to measure the actual voltage at the 3.3V pin and modify that value. (unit: mV)\n#define BATTERY_DEFICIT_VOL 1850    // Battery voltage value at loss of charge\n#define BATTERY_FULL_VOL 2450       // Battery voltage value at full charge\n\nint32_t battery_level_percent(void)\n{\n  int32_t mvolts = 0;\n#if defined(CONFIG_IDF_TARGET_ESP32S3) || defined(CONFIG_IDF_TARGET_ESP32C3)\n  for(int8_t i=0; i<NUM_ADC_SAMPLE; i++){\n    mvolts += analogReadMilliVolts(D0);\n  }\n  mvolts /= NUM_ADC_SAMPLE;\n#elif defined(ARDUINO_SEEED_XIAO_NRF52840_SENSE) || defined(ARDUINO_SEEED_XIAO_NRF52840)\n  analogReference(AR_INTERNAL2V4);  // 0.6V ref  1/4 Gain\n  int32_t adc_raw = 0;\n  for(int8_t i=0; i<NUM_ADC_SAMPLE; i++){\n    adc_raw += analogRead(D0);\n  }\n  adc_raw /= NUM_ADC_SAMPLE;\n  mvolts = 2400 * adc_raw / (1<<12);\n#elif defined(ARDUINO_SEEED_XIAO_RP2040)\n  int32_t adc_raw = 0;\n  for(int8_t i=0; i<NUM_ADC_SAMPLE; i++){\n    adc_raw += analogRead(D0);\n  }\n  adc_raw /= NUM_ADC_SAMPLE;\n  mvolts = RP2040_VREF * adc_raw / (1<<12);\n#endif\n  int32_t level = (mvolts - BATTERY_DEFICIT_VOL) * 100 / (BATTERY_FULL_VOL-BATTERY_DEFICIT_VOL); // 1850 ~ 2100\n  level = (level<0) ? 0 : ((level>100) ? 100 : level); \n  return level;\n}\n\nvoid setup() {\n  // put your setup code here, to run once:\n  Serial.begin(115200);\n  while(!Serial);\n\n  analogReadResolution(12);\n}\n\nvoid loop() {\n  // put your main code here, to run repeatedly:\n  int32_t batteryVal = battery_level_percent();\n  Serial.print("The percentage of power remaining is: ");\n  Serial.print(batteryVal);\n  Serial.print(" %");\n  Serial.println();\n  delay(1000);\n}\n')),(0,a.yg)("admonition",{type:"tip"},(0,a.yg)("p",{parentName:"admonition"},"This program is not a universal program, and the measured battery percentage may not be accurate. This is because everyone uses different batteries and chips and development boards, so you may need to modify the program according to the actual situation when executing this program. Please refer to the ",(0,a.yg)("a",{parentName:"p",href:"#program-annotation"},"program annotation")," section of this section for the method of modification.")),(0,a.yg)("p",null,"Select the XIAO board you are using, upload the program, open the serial monitor, and set the baud rate to ",(0,a.yg)("strong",{parentName:"p"},"115200"),". If you have the battery connected and powered on, you should be able to see the battery voltage in the serial monitor."),(0,a.yg)("div",{style:{textAlign:"center"}},(0,a.yg)("img",{src:"https://files.seeedstudio.com/wiki/round_display_for_xiao/80.png",style:{width:700,height:"auto"}})),(0,a.yg)("h3",{id:"program-annotation"},"Program annotation"),(0,a.yg)("p",null,"This code uses an ADC to measure the battery voltage and calculate the battery level percentage. The implementation varies depending on the hardware platform:"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},"For ESP32-S3 and ESP32-C3 platforms, the ",(0,a.yg)("inlineCode",{parentName:"li"},"analogReadMilliVolts")," function is used to read the analog voltage values, and then the average value of multiple samples is taken to obtain the average battery voltage."),(0,a.yg)("li",{parentName:"ul"},"For Seeeduino XIAO NRF52840 platforms, the ",(0,a.yg)("inlineCode",{parentName:"li"},"analogReference")," function is first used to specify the reference voltage as 2.4V, and then the analogRead function is used to read the analog voltage values, and the average battery voltage is calculated."),(0,a.yg)("li",{parentName:"ul"},"For the Seeeduino XIAO RP2040 platform, the ",(0,a.yg)("inlineCode",{parentName:"li"},"analogRead")," function is used to read the analog voltage values, and the average battery voltage is calculated.")),(0,a.yg)("p",null,"In any case, the average battery voltage is calculated, and then the battery level percentage is calculated using the formula ",(0,a.yg)("inlineCode",{parentName:"p"},"(mvolts - BATTERY_DEFICIT_VOL) * 100 / (BATTERY_FULL_VOL - BATTERY_DEFICIT_VOL)"),", where mvolts is the average battery voltage, ",(0,a.yg)("inlineCode",{parentName:"p"},"BATTERY_DEFICIT_VOL")," is the minimum operating voltage of the battery, and ",(0,a.yg)("inlineCode",{parentName:"p"},"BATTERY_FULL_VOL")," is the maximum voltage of the battery. Finally, the code limits the battery level percentage to ensure that it is between 0 and 100."),(0,a.yg)("p",null,"In summary, the following parameters determine the accuracy of the voltage measurement when using this program."),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-c"},"#define RP2040_VREF 3300            // When you use the XIAO RP2040, you need to measure the actual voltage at the 3.3V pin and modify that value. (unit: mV)\n#define BATTERY_DEFICIT_VOL 1850    // Battery voltage value at loss of charge\n#define BATTERY_FULL_VOL 2450       // Battery voltage value at full charge\n")),(0,a.yg)("p",null,"The first thing you need to do is to get the analog value of the battery you purchased when it is at a loss of charge/full charge."),(0,a.yg)("p",null,"You can get the analog value of the battery by using this function. You need to get the value once in both full and deficit battery states."),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-cpp"},"int32_t battery_test(void)\n{\n  int32_t mvolts = 0;\n#if defined(CONFIG_IDF_TARGET_ESP32S3) || defined(CONFIG_IDF_TARGET_ESP32C3)\n  for(int8_t i=0; i<NUM_ADC_SAMPLE; i++){\n    mvolts += analogReadMilliVolts(D0);\n  }\n  mvolts /= NUM_ADC_SAMPLE;\n#elif defined(ARDUINO_SEEED_XIAO_NRF52840_SENSE) || defined(ARDUINO_SEEED_XIAO_NRF52840)\n  analogReference(AR_INTERNAL2V4);  // 0.6V ref  1/4 Gain\n  int32_t adc_raw = 0;\n  for(int8_t i=0; i<NUM_ADC_SAMPLE; i++){\n    adc_raw += analogRead(D0);\n  }\n  adc_raw /= NUM_ADC_SAMPLE;\n  mvolts = 2400 * adc_raw / (1<<12);\n#elif defined(ARDUINO_SEEED_XIAO_RP2040)\n  int32_t adc_raw = 0;\n  for(int8_t i=0; i<NUM_ADC_SAMPLE; i++){\n    adc_raw += analogRead(D0);\n  }\n  adc_raw /= NUM_ADC_SAMPLE;\n  mvolts = RP2040_VREF * adc_raw / (1<<12);\n#endif\n  return mvolts;\n}\n")),(0,a.yg)("admonition",{type:"tip"},(0,a.yg)("p",{parentName:"admonition"},"The ",(0,a.yg)("inlineCode",{parentName:"p"},"battery_test()")," function is actually the ",(0,a.yg)("inlineCode",{parentName:"p"},"battery_level_percent()")," function with the last two lines of code to calculate the percentage removed.")),(0,a.yg)("p",null,"Then just modify the value of the program corresponding to the value you measured."),(0,a.yg)("p",null,"If you are using the ",(0,a.yg)("strong",{parentName:"p"},"XIAO RP2040"),", then one additional step you will need to do is to use a voltmeter to measure the actual voltage on the 3.3V pin of the XIAO RP2040. The measured voltage value is converted into ",(0,a.yg)("strong",{parentName:"p"},"mV")," units, and the corresponding program is modified."),(0,a.yg)("p",null,"For example, here are the actual measurements I took using my XIAO RP2040 and battery."),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-c"},"#define RP2040_VREF 3080\n#define BATTERY_DEFICIT_VOL 1541\n#define BATTERY_FULL_VOL 1791\n")),(0,a.yg)("h2",{id:"rtc-function"},"RTC function"),(0,a.yg)("p",null,"RTC function part, we mainly divided into the following four sections to introduce its application."),(0,a.yg)("ol",null,(0,a.yg)("li",{parentName:"ol"},"First is for XIAO without network function, you can correct the RTC by manually setting the initial time."),(0,a.yg)("li",{parentName:"ol"},"Then power the RTC with the help of coin cell battery to get the accurate time continuously."),(0,a.yg)("li",{parentName:"ol"},"For XIAO with network function, you can use the network function to correct the time."),(0,a.yg)("li",{parentName:"ol"},"Draw a simple clock dial by combining the RTC function.")),(0,a.yg)("h3",{id:"off-line-manual-calibration-of-the-rtc"},"Off-line manual calibration of the RTC"),(0,a.yg)("p",null,"The following is a sample program to manually calibrate the RTC time. The settings are placed in the ",(0,a.yg)("inlineCode",{parentName:"p"},"Setup()")," function to ensure that the setup program is executed only once. This procedure is the most efficient way to set the initial RTC time for XIAO without network capability."),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-cpp"},'#include "I2C_BM8563.h"\n\nI2C_BM8563 rtc(I2C_BM8563_DEFAULT_ADDRESS, Wire);\n\nvoid setup() {\n  // Init Serial\n  Serial.begin(115200);\n  while(!Serial);\n  delay(50);\n\n  // Init I2C\n  Wire.begin();\n\n  // Init RTC\n  rtc.begin();\n\n  // Set RTC Date\n  I2C_BM8563_DateTypeDef dateStruct;\n  dateStruct.weekDay = 3;\n  dateStruct.month = 4;\n  dateStruct.date = 26;\n  dateStruct.year = 2023;\n  rtc.setDate(&dateStruct);\n\n  // Set RTC Time\n  I2C_BM8563_TimeTypeDef timeStruct;\n  timeStruct.hours   = 9;\n  timeStruct.minutes = 43;\n  timeStruct.seconds = 10;\n  rtc.setTime(&timeStruct);\n\n  Serial.println("RTC time calibration complete!");\n}\n\nvoid loop() {\n\n}\n')),(0,a.yg)("p",null,"After uploading the program and turning on the serial monitor, the RTC time will start to calibrate. When ",(0,a.yg)("strong",{parentName:"p"},"RTC time calibration complete!")," appears, calibration is complete."),(0,a.yg)("h3",{id:"get-rtc-time"},"Get RTC time"),(0,a.yg)("p",null,"The following program gets the time of the RTC every second and prints it out in the serial monitor."),(0,a.yg)("admonition",{type:"tip"},(0,a.yg)("p",{parentName:"admonition"},"The procedure to obtain the RTC time can be used after the manual calibration procedure above. The time calibration procedure needs to be performed only once and the RTC clock will be able to work continuously under the power of the coin cell battery, after which you only need to use the procedure for obtaining the time to get the exact time."),(0,a.yg)("p",{parentName:"admonition"},"We do not recommend to use the program to calibrate the time and get the time together, so that when the XIAO is powered up, both will reset once according to the time you configured, then you will never get the accurate time.")),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-cpp"},'#include "I2C_BM8563.h"\n\nI2C_BM8563 rtc(I2C_BM8563_DEFAULT_ADDRESS, Wire);\n\nvoid setup() {\n  // Init Serial\n  Serial.begin(115200);\n  delay(50);\n\n  // Init I2C\n  Wire.begin();\n\n  // Init RTC\n  rtc.begin();\n}\n\nvoid loop() {\n  I2C_BM8563_DateTypeDef dateStruct;\n  I2C_BM8563_TimeTypeDef timeStruct;\n\n  // Get RTC\n  rtc.getDate(&dateStruct);\n  rtc.getTime(&timeStruct);\n\n  // Print RTC\n#if defined(CONFIG_IDF_TARGET_ESP32S3) || defined(CONFIG_IDF_TARGET_ESP32C3)\n  Serial.printf("%04d/%02d/%02d %02d:%02d:%02d\\n",\n              dateStruct.year,\n              dateStruct.month,\n              dateStruct.date,\n              timeStruct.hours,\n              timeStruct.minutes,\n              timeStruct.seconds\n              );\n#else\n  Serial.print(dateStruct.year);\n  Serial.print(", ");\n  Serial.print(dateStruct.month);\n  Serial.print(", ");\n  Serial.print(dateStruct.date);\n  Serial.print(", ");\n  Serial.print(timeStruct.hours);\n  Serial.print(", ");\n  Serial.print(timeStruct.minutes);\n  Serial.print(", ");\n  Serial.print(timeStruct.seconds);\n  Serial.println();\n#endif\n\n  // Wait\n  delay(1000);\n}\n')),(0,a.yg)("div",{style:{textAlign:"center"}},(0,a.yg)("img",{src:"https://files.seeedstudio.com/wiki/round_display_for_xiao/71.png",style:{width:700,height:"auto"}})),(0,a.yg)("h3",{id:"network-calibration-rtc-time"},"Network calibration RTC time"),(0,a.yg)("p",null,"For XIAO, which has network capabilities, things seem to get a lot easier. With a network, you don't even need to use a coin cell battery to keep the RTC working out of the box, you just need to network the timing every time you power it up."),(0,a.yg)("p",null,"The following is a sample program for network timing and outputting the RTC time reading on the serial monitor."),(0,a.yg)("admonition",{type:"caution"},(0,a.yg)("p",{parentName:"admonition"},"This program is only applicable to XIAO ESP32 series. Because only this series has network function.")),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-cpp"},'#include "I2C_BM8563.h"\n#include <WiFi.h>\n\nI2C_BM8563 rtc(I2C_BM8563_DEFAULT_ADDRESS, Wire);\n\nconst char* ntpServer = "time.cloudflare.com";\nconst char *ssid     = "YOUR_SSID";\nconst char *password = "YOUR_PASSWORD";\n\nvoid setup() {\n  // Init Serial\n  Serial.begin(115200);\n  delay(50);\n\n  // Connect to an access point\n  WiFi.begin(ssid, password);\n  Serial.print("Connecting to Wi-Fi ");\n  while (WiFi.status() != WL_CONNECTED) {\n    delay(500);\n    Serial.print(".");\n  }\n  Serial.println(" CONNECTED");\n\n  // Set ntp time to local\n  configTime(9 * 3600, 0, ntpServer);\n\n  // Init I2C\n  Wire.begin();\n\n  // Init RTC\n  rtc.begin();\n\n  // Get local time\n  struct tm timeInfo;\n  if (getLocalTime(&timeInfo)) {\n    // Set RTC time\n    I2C_BM8563_TimeTypeDef timeStruct;\n    timeStruct.hours   = timeInfo.tm_hour;\n    timeStruct.minutes = timeInfo.tm_min;\n    timeStruct.seconds = timeInfo.tm_sec;\n    rtc.setTime(&timeStruct);\n\n    // Set RTC Date\n    I2C_BM8563_DateTypeDef dateStruct;\n    dateStruct.weekDay = timeInfo.tm_wday;\n    dateStruct.month   = timeInfo.tm_mon + 1;\n    dateStruct.date    = timeInfo.tm_mday;\n    dateStruct.year    = timeInfo.tm_year + 1900;\n    rtc.setDate(&dateStruct);\n  }\n}\n\nvoid loop() {\n  I2C_BM8563_DateTypeDef dateStruct;\n  I2C_BM8563_TimeTypeDef timeStruct;\n\n  // Get RTC\n  rtc.getDate(&dateStruct);\n  rtc.getTime(&timeStruct);\n\n  // Print RTC\n#if defined(CONFIG_IDF_TARGET_ESP32S3) || defined(CONFIG_IDF_TARGET_ESP32C3)\n    Serial.printf("%04d/%02d/%02d %02d:%02d:%02d\\n",\n                dateStruct.year,\n                dateStruct.month,\n                dateStruct.date,\n                timeStruct.hours,\n                timeStruct.minutes,\n                timeStruct.seconds\n               );\n#else\n     Serial.print(dateStruct.year);\n     Serial.print(", ");\n     Serial.print(dateStruct.month);\n     Serial.print(", ");\n     Serial.print(dateStruct.date);\n     Serial.print(", ");\n     Serial.print(timeStruct.hours);\n     Serial.print(", ");\n     Serial.print(timeStruct.minutes);\n     Serial.print(", ");\n     Serial.print(timeStruct.seconds);\n     Serial.println();\n#endif\n\n  // Wait\n  delay(1000);\n}\n')),(0,a.yg)("p",null,"When you use this program, please fill in the name and password of the network according to your actual situation. After uploading the program, open the serial monitor and set the baud rate to 115200, then you can see the exact time."),(0,a.yg)("div",{style:{textAlign:"center"}},(0,a.yg)("img",{src:"https://files.seeedstudio.com/wiki/round_display_for_xiao/72.png",style:{width:700,height:"auto"}})),(0,a.yg)("h3",{id:"simple-dial-based-on-rtc-time"},"Simple dial based on RTC time"),(0,a.yg)("p",null,"The following program is a dial program based on RTC clock drawing."),(0,a.yg)("admonition",{type:"caution"},(0,a.yg)("p",{parentName:"admonition"},"The following program is only compatible with XIAO except for XIAO nRF52840. XIAO nRF52840 currently has problems with TFT compatibility. But you may consider using the Arduino GFX library or LVGL to draw the dials.")),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-cpp"},'#include <Arduino.h>\n#include <TFT_eSPI.h>\n#include <SPI.h>\n#include "I2C_BM8563.h"\n#include <Wire.h>\n\n#define USE_TFT_ESPI_LIBRARY\n\n#include "lv_xiao_round_screen.h"\n\nI2C_BM8563 rtc(I2C_BM8563_DEFAULT_ADDRESS, Wire);\n\n#if defined(CONFIG_IDF_TARGET_ESP32S3) || defined(CONFIG_IDF_TARGET_ESP32C3)\n#include "esp_wifi.h"\n#include "WiFi.h"\n\n  const char *ntpServer = "time.cloudflare.com";\n  const char *ssid     = "YOUR_SSID";\n  const char *password = "YOUR_PASSWORD";\n#elif defined(ARDUINO_SEEED_XIAO_NRF52840_SENSE) || defined(ARDUINO_SEEED_XIAO_NRF52840)\n#error "This procedure is not applicable to XIAO nRF52840 series, please replace other XIAO and try again."\n#endif\n\n\n//TFT_eSPI tft = TFT_eSPI();  // Invoke library, pins defined in User_Setup.h\nTFT_eSprite face = TFT_eSprite(&tft);\n\n#define CLOCK_X_POS 0\n#define CLOCK_Y_POS 0\n\n#define CLOCK_FG   TFT_SKYBLUE\n#define CLOCK_BG   TFT_NAVY\n#define SECCOND_FG TFT_RED\n#define LABEL_FG   TFT_GOLD\n\n#define CLOCK_R       240.0f / 2.0f // Clock face radius (float type)\n#define H_HAND_LENGTH CLOCK_R/2.0f\n#define M_HAND_LENGTH CLOCK_R/1.4f\n#define S_HAND_LENGTH CLOCK_R/1.3f\n\n// Calculate 1 second increment angles. Hours and minute hand angles\n// change every second so we see smooth sub-pixel movement\n#define SECOND_ANGLE 360.0 / 60.0\n#define MINUTE_ANGLE SECOND_ANGLE / 60.0\n#define HOUR_ANGLE   MINUTE_ANGLE / 12.0\n\n// Sprite width and height\n#define FACE_W CLOCK_R * 2 + 1\n#define FACE_H CLOCK_R * 2 + 1\n\n// Time h:m:s\nuint8_t h = 0, m = 0, s = 0;\n\nfloat time_secs = h * 3600 + m * 60 + s;\n\n// Time for next tick\nuint32_t targetTime = 0;\n\n// =========================================================================\n// Setup\n// =========================================================================\nvoid setup() {\n  Serial.begin(115200);\n  Serial.println("Booting...");\n\n  // Initialise the screen\n  tft.init();\n\n  // Ideally set orientation for good viewing angle range because\n  // the anti-aliasing effectiveness varies with screen viewing angle\n  // Usually this is when screen ribbon connector is at the bottom\n  tft.setRotation(0);\n  tft.fillScreen(TFT_BLACK);\n\n  // Create the clock face sprite\n  //face.setColorDepth(8); // 8 bit will work, but reduces effectiveness of anti-aliasing\n  face.createSprite(FACE_W, FACE_H);\n\n  // Draw the whole clock - NTP time not available yet\n  renderFace(time_secs);\n\n#if defined(CONFIG_IDF_TARGET_ESP32S3) || defined(CONFIG_IDF_TARGET_ESP32C3)\n  WiFi.begin(ssid, password);\n  while ( WiFi.status() != WL_CONNECTED ) \n  {\n    delay ( 500 );\n    Serial.print ( "." );\n  }\n  configTime(8 * 3600, 0, ntpServer);\n#endif\n\n  Wire.begin();\n  rtc.begin();\n\n//  struct tm timeInfo;\n  I2C_BM8563_TimeTypeDef timeStruct;\n  I2C_BM8563_DateTypeDef dateStruct;\n\n// In case of XIAO ESP32 series, use network timing.\n#if defined(CONFIG_IDF_TARGET_ESP32S3) || defined(CONFIG_IDF_TARGET_ESP32C3)\n  struct tm timeInfo;\n  if (getLocalTime(&timeInfo)) {\n    timeStruct.hours   = timeInfo.tm_hour;\n    timeStruct.minutes = timeInfo.tm_min;\n    timeStruct.seconds = timeInfo.tm_sec;\n    rtc.setTime(&timeStruct);\n  }\n#else\n  // Set RTC time, Other XIAOs do not have network functions and require manual time alignment.\n  // Please note that the setting time should be set only once.\n  timeStruct.hours   = 9;\n  timeStruct.minutes = 43;\n  timeStruct.seconds = 10;\n  rtc.setTime(&timeStruct);\n#endif\n\n  targetTime = millis() + 100;\n  rtc.getTime(&timeStruct);\n  time_secs = timeStruct.hours * 3600 + timeStruct.minutes * 60 + timeStruct.seconds;\n}\n\n// =========================================================================\n// Loop\n// =========================================================================\nvoid loop() {\n  // Update time periodically\n  if (targetTime < millis()) {\n\n    // Update next tick time in 100 milliseconds for smooth movement\n    targetTime = millis() + 100;\n\n    // Increment time by 100 milliseconds\n    time_secs += 0.100;\n\n    // Midnight roll-over\n    if (time_secs >= (60 * 60 * 24)) time_secs = 0;\n\n    // All graphics are drawn in sprite to stop flicker\n    renderFace(time_secs);\n\n    I2C_BM8563_DateTypeDef dateStruct;\n    I2C_BM8563_TimeTypeDef timeStruct;\n\n    // Get RTC\n    rtc.getTime(&timeStruct);\n  \n    // Print RTC\n#if defined(CONFIG_IDF_TARGET_ESP32S3) || defined(CONFIG_IDF_TARGET_ESP32C3)\n    Serial.printf("%02d:%02d:%02d\\n",\n                timeStruct.hours,\n                timeStruct.minutes,\n                timeStruct.seconds\n               );\n#else\n     Serial.print(timeStruct.hours);\n     Serial.print(", ");\n     Serial.print(timeStruct.minutes);\n     Serial.print(", ");\n     Serial.print(timeStruct.seconds);\n     Serial.println();\n#endif\n  }\n}\n\n// =========================================================================\n// Draw the clock face in the sprite\n// =========================================================================\nstatic void renderFace(float t) {\n  float h_angle = t * HOUR_ANGLE;\n  float m_angle = t * MINUTE_ANGLE;\n  float s_angle = t * SECOND_ANGLE;\n\n  // The face is completely redrawn - this can be done quickly\n  face.fillSprite(TFT_BLACK);\n\n  // Draw the face circle\n  face.fillSmoothCircle( CLOCK_R, CLOCK_R, CLOCK_R, CLOCK_BG );\n\n  // Set text datum to middle centre and the colour\n  face.setTextDatum(MC_DATUM);\n\n  // The background colour will be read during the character rendering\n  face.setTextColor(CLOCK_FG, CLOCK_BG);\n\n  // Text offset adjustment\n  constexpr uint32_t dialOffset = CLOCK_R - 10;\n\n  float xp = 0.0, yp = 0.0; // Use float pixel position for smooth AA motion\n\n  // Draw digits around clock perimeter\n  for (uint32_t h = 1; h <= 12; h++) {\n    getCoord(CLOCK_R, CLOCK_R, &xp, &yp, dialOffset, h * 360.0 / 12);\n    face.drawNumber(h, xp, 2 + yp);\n  }\n\n  // Add text (could be digital time...)\n  face.setTextColor(LABEL_FG, CLOCK_BG);\n  face.drawString("TFT_eSPI", CLOCK_R, CLOCK_R * 0.75);\n\n  // Draw minute hand\n  getCoord(CLOCK_R, CLOCK_R, &xp, &yp, M_HAND_LENGTH, m_angle);\n  face.drawWideLine(CLOCK_R, CLOCK_R, xp, yp, 6.0f, CLOCK_FG);\n  face.drawWideLine(CLOCK_R, CLOCK_R, xp, yp, 2.0f, CLOCK_BG);\n\n  // Draw hour hand\n  getCoord(CLOCK_R, CLOCK_R, &xp, &yp, H_HAND_LENGTH, h_angle);\n  face.drawWideLine(CLOCK_R, CLOCK_R, xp, yp, 6.0f, CLOCK_FG);\n  face.drawWideLine(CLOCK_R, CLOCK_R, xp, yp, 2.0f, CLOCK_BG);\n\n  // Draw the central pivot circle\n  face.fillSmoothCircle(CLOCK_R, CLOCK_R, 4, CLOCK_FG);\n\n  // Draw cecond hand\n  getCoord(CLOCK_R, CLOCK_R, &xp, &yp, S_HAND_LENGTH, s_angle);\n  face.drawWedgeLine(CLOCK_R, CLOCK_R, xp, yp, 2.5, 1.0, SECCOND_FG);\n  face.pushSprite(0, 0, TFT_TRANSPARENT);\n}\n\n// =========================================================================\n// Get coordinates of end of a line, pivot at x,y, length r, angle a\n// =========================================================================\n// Coordinates are returned to caller via the xp and yp pointers\n#define DEG2RAD 0.0174532925\nvoid getCoord(int16_t x, int16_t y, float *xp, float *yp, int16_t r, float a)\n{\n  float sx1 = cos( (a - 90) * DEG2RAD);\n  float sy1 = sin( (a - 90) * DEG2RAD);\n  *xp =  sx1 * r + x;\n  *yp =  sy1 * r + y;\n}\n')),(0,a.yg)("p",null,"The above code you will need to make some minor modifications depending on the type of development board you are using. If you are using an XIAO with networking capabilities, you will need to configure the WiFi name and password. If not, you need to manually adjust the real time."),(0,a.yg)("p",null,"Upload the program and you will see the dial that automatically goes according to the set time."),(0,a.yg)("div",{style:{textAlign:"center"}},(0,a.yg)("img",{src:"https://files.seeedstudio.com/wiki/round_display_for_xiao/75.gif",style:{width:500,height:"auto"}})),(0,a.yg)("h2",{id:"sd-card-function"},"SD card function"),(0,a.yg)("p",null,"The Round Display supports the use of microSD cards to read and write data. Before using the microSD card, please format the microSD card to ",(0,a.yg)("strong",{parentName:"p"},"FAT32")," format to make sure it can be recognized and used properly."),(0,a.yg)("h3",{id:"all-xiao-series-in-addition-to-the-xiao-nrf52840-series"},"All XIAO series (In addition to the XIAO nRF52840 series)"),(0,a.yg)("p",null,"This section applies to all of XIAO (In addition to the XIAO nRF52840 series), which is a simple program for reading and writing files."),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-cpp"},'#include <SPI.h>\n#include <SD.h>\n#include <TFT_eSPI.h>\n\nTFT_eSPI tft = TFT_eSPI();\n\nFile myFile;\n\nvoid setup() {\n  // Open serial communications and wait for port to open:\n  Serial.begin(115200);\n  while(!Serial);\n\n  // Display initialization\n  tft.init();\n\n  Serial.print("Initializing SD card...");\n\n  pinMode(D2, OUTPUT);\n  if (!SD.begin(D2)) {\n    Serial.println("initialization failed!");\n    return;\n  }\n  Serial.println("initialization done.");\n\n  // open the file. note that only one file can be open at a time,\n  // so you have to close this one before opening another.\n  myFile = SD.open("/test.txt", FILE_WRITE);\n\n  // if the file opened okay, write to it:\n  if (myFile) {\n    Serial.print("Writing to test.txt...");\n    myFile.println("testing 1, 2, 3.");\n    // close the file:\n    myFile.close();\n    Serial.println("done.");\n  } else {\n    // if the file didn\'t open, print an error:\n    Serial.println("error opening test.txt");\n  }\n\n  // re-open the file for reading:\n  myFile = SD.open("/test.txt");\n  if (myFile) {\n    Serial.println("test.txt:");\n\n    // read from the file until there\'s nothing else in it:\n    while (myFile.available()) {\n      Serial.write(myFile.read());\n    }\n    // close the file:\n    myFile.close();\n  } else {\n    // if the file didn\'t open, print an error:\n    Serial.println("error opening test.txt");\n  }\n}\n\nvoid loop() {\n  // nothing happens after setup\n}\n')),(0,a.yg)("p",null,"This program will create a new program called ",(0,a.yg)("strong",{parentName:"p"},"test.txt")," on your microSD card and write the contents of ",(0,a.yg)("strong",{parentName:"p"},"testing 1, 2, 3."),". Finally, it reads the file and prints out the contents of the file through the serial monitor."),(0,a.yg)("div",{style:{textAlign:"center"}},(0,a.yg)("img",{src:"https://files.seeedstudio.com/wiki/round_display_for_xiao/83.png",style:{width:700,height:"auto"}})),(0,a.yg)("admonition",{type:"caution"},(0,a.yg)("p",{parentName:"admonition"},"You will find that the screen TFT initialization is used in the program for the SD card. Please do not think that this is useless and can be removed, but in fact it is necessary to use the SD card, otherwise you will get an error message that the microSD card failed to mount."),(0,a.yg)("p",{parentName:"admonition"},"Due to the hardware design, some of the pins are low by default, which will cause the microSD mount program to think there is no pull-up resistor causing the mount to fail. So when using the SD card function with Round Display, please make sure to initialize the screen display before initializing the SD card.")),(0,a.yg)("h3",{id:"xiao-nrf52840"},"XIAO nRF52840"),(0,a.yg)("p",null,"If you are using the XIAO nRF52840 series then you may need to download the ",(0,a.yg)("a",{parentName:"p",href:"https://github.com/greiman/SdFat"},"SdFat library")," separately in order to use the SD card function."),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-cpp"},'#include <SPI.h>\n#include "SdFat.h"\n#include <TFT_eSPI.h>\n\nTFT_eSPI tft = TFT_eSPI();\nSdFat SD;\n\n#define SD_CS_PIN D2\nFile myFile;\n\nvoid setup() {\n  // Open serial communications and wait for port to open:\n  Serial.begin(9600);\n  while (!Serial) {\n    ; // wait for serial port to connect. Needed for native USB port only\n  }\n\n  // Display initialization\n  tft.init();\n\n  Serial.print("Initializing SD card...");\n\n  if (!SD.begin(SD_CS_PIN)) {\n    Serial.println("initialization failed!");\n    return;\n  }\n  Serial.println("initialization done.");\n\n  // open the file. note that only one file can be open at a time,\n  // so you have to close this one before opening another.\n  myFile = SD.open("/test.txt", FILE_WRITE);\n\n  // if the file opened okay, write to it:\n  if (myFile) {\n    Serial.print("Writing to test.txt...");\n    myFile.println("testing 1, 2, 3.");\n    // close the file:\n    myFile.close();\n    Serial.println("done.");\n  } else {\n    // if the file didn\'t open, print an error:\n    Serial.println("error opening test.txt");\n  }\n\n  // re-open the file for reading:\n  myFile = SD.open("test.txt");\n  if (myFile) {\n    Serial.println("test.txt:");\n\n    // read from the file until there\'s nothing else in it:\n    while (myFile.available()) {\n      Serial.write(myFile.read());\n    }\n    // close the file:\n    myFile.close();\n  } else {\n    // if the file didn\'t open, print an error:\n    Serial.println("error opening test.txt");\n  }\n}\n\nvoid loop() {\n  // nothing happens after setup\n}\n')),(0,a.yg)("h3",{id:"xiao-esp32s3--xiao-esp32s3-sense--xiao-esp32c3"},"XIAO ESP32S3 & XIAO ESP32S3 Sense & XIAO ESP32C3"),(0,a.yg)("p",null,"Since the ESP32 series has very powerful file system support, we have written a series of examples for the XIAO ESP32 on how to use the file system and save the microSD card, which you can learn to use in the links below."),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},(0,a.yg)("a",{parentName:"strong",href:"https://wiki.seeedstudio.com/xiao_esp32s3_sense_filesystem"},"File System and XIAO ESP32S3 Sense")))),(0,a.yg)("p",null,"The tutorials in this Wiki apply to the XIAO ESP32 series, but since you now want to use the Round Display's SD card slot, and the above tutorial focuses on using the SD card slot on the XIAO ESP32S3 Sense, you will need to modify the initialization of the SD card to the line below."),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-c"},"// Display initialization\ntft.init();\n\npinMode(D2, OUTPUT);\nSD.begin(D2);\n")),(0,a.yg)("admonition",{type:"tip"},(0,a.yg)("p",{parentName:"admonition"},"Don't forget that you also need to initialize the TFT screen first to use the SD card function.")),(0,a.yg)("h2",{id:"screen-function"},"Screen function"),(0,a.yg)("p",null,"In the use part of the screen, the two main components are divided into touch and display."),(0,a.yg)("h3",{id:"touch-function"},"Touch function"),(0,a.yg)("p",null,"Touch function is a special feature of Round Display. You can use the touch function to perform some tap-and-hold display operations."),(0,a.yg)("p",null,"The following program can be used to output the result of whether the display was touched or not."),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-cpp"},'#define USE_TFT_ESPI_LIBRARY\n#include "lv_xiao_round_screen.h"\n\nvoid setup() {\n  // put your setup code here, to run once:\n  Serial.begin(115200);\n  pinMode(TOUCH_INT, INPUT_PULLUP);\n  Wire.begin();\n}\n\nvoid loop() {\n  // put your main code here, to run repeatedly:\n  if(chsc6x_is_pressed()){\n    Serial.println("The display is touched.");\n  }\n  else\n    Serial.println("The display is not touched.");\n  delay(50);\n}\n')),(0,a.yg)("p",null,"The following program is a simple example of a touch function combined with a display function. Upload the following program and then tap the screen, a small circle will be drawn at the location where the screen is tapped."),(0,a.yg)("admonition",{type:"caution"},(0,a.yg)("p",{parentName:"admonition"},"If you are using XIAO nRF52840, then the following program based on TFT library display may not work properly, you need to modify the program to use Arduino GFX library.")),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-cpp"},'#include <TFT_eSPI.h>\n#include <SPI.h>\n#define USE_TFT_ESPI_LIBRARY\n#include "lv_xiao_round_screen.h"\n\nlv_coord_t touchX, touchY;\n\nvoid setup() {\n  // put your setup code here, to run once:\n  Serial.begin(115200);\n\n  pinMode(TOUCH_INT, INPUT_PULLUP);\n  Wire.begin();\n  \n  // Initialise the screen\n  tft.init();\n\n  tft.setRotation(0);\n  tft.fillScreen(TFT_BLACK);\n}\n\nvoid loop() {\n  // put your main code here, to run repeatedly:\n  if(chsc6x_is_pressed())\n  {\n    Serial.println("The display is touched.");\n    chsc6x_get_xy(&touchX, &touchY);\n    tft.drawCircle(touchX, touchY, 15, TFT_WHITE);\n  }\n  \n  delay(50);\n}\n')),(0,a.yg)("div",{style:{textAlign:"center"}},(0,a.yg)("img",{src:"https://files.seeedstudio.com/wiki/round_display_for_xiao/81.gif",style:{width:500,height:"auto"}})),(0,a.yg)("h3",{id:"display-functions"},"Display Functions"),(0,a.yg)("p",null,"About the display part, we mainly introduce the use of LVGL library and TFT library. Due to the space issue, we will go into details on how to draw complex dials using the supported graphics libraries in a new Wiki."),(0,a.yg)("p",null,(0,a.yg)("a",{parentName:"p",href:"https://wiki.seeedstudio.com/using_lvgl_and_tft_on_round_display"},"Using LVGL and TFT on the Seeed Studio Round Display for XIAO")),(0,a.yg)("p",null,"Of course, if you just want to implement some simple examples, the graphics library also has a very rich set of examples for your reference use."),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("p",{parentName:"li"},(0,a.yg)("a",{parentName:"p",href:"https://github.com/Bodmer/TFT_eSPI/tree/master/examples"},"TFT library example"))),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("p",{parentName:"li"},(0,a.yg)("a",{parentName:"p",href:"https://github.com/moononournation/Arduino_GFX/tree/master/examples"},"Arduino GFX library example"))),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("p",{parentName:"li"},(0,a.yg)("a",{parentName:"p",href:"https://github.com/lvgl/lvgl/tree/master/examples"},"LVGL library example")))),(0,a.yg)("p",null,"If you already have these libraries installed, you can easily find the examples inside ",(0,a.yg)("strong",{parentName:"p"},"File->Example->library name")," on the Arduino IDE."),(0,a.yg)("div",{style:{textAlign:"center"}},(0,a.yg)("img",{src:"https://files.seeedstudio.com/wiki/round_display_for_xiao/82.png",style:{width:800,height:"auto"}})),(0,a.yg)("admonition",{type:"tip"},(0,a.yg)("p",{parentName:"admonition"},"The examples here are for reference only and not every example will necessarily work. You may need to modify the program to be compatible with the Round Display pinout and hardware definition.")),(0,a.yg)("h2",{id:"tech-support--product-discussion"},"Tech Support & Product Discussion"),(0,a.yg)("h3",{id:"q1-why-do-i-get-an-error-when-i-use-xiao-nrf52840-sense"},"Q1: Why do I get an error when I use XIAO nRF52840 (Sense)?"),(0,a.yg)("p",null,"When using the content of this tutorial, two different types of problems may occur for the XIAO nRF52840."),(0,a.yg)("ol",null,(0,a.yg)("li",{parentName:"ol"},(0,a.yg)("p",{parentName:"li"},"Compatibility issues between nRF52840 and TFT library."),(0,a.yg)("p",{parentName:"li"},"If you are using TFT library, compile and upload without any error, very smooth. But when you are displaying it, you find that there is no image. Then you may have encountered a compatibility issue between nRF52840 and TFT library. This means you can only replace XIAO or use Arduino GFX library to finish the image.")),(0,a.yg)("li",{parentName:"ol"},(0,a.yg)("p",{parentName:"li"},"Compilation error caused by choosing the wrong development board."))),(0,a.yg)("p",null,"If you are having problems with the compilation process. The error message is usually about an SPI error, for example ",(0,a.yg)("inlineCode",{parentName:"p"},"'SPI_X' was not declared in this scope"),"\n. Then it means that you are choosing the wrong type of development board. To use all of this tutorial, you need to use the ",(0,a.yg)("strong",{parentName:"p"},"non-mbed")," version of the XIAO nRF52840. --\x3e"),(0,a.yg)("div",{style:{textAlign:"center"}},(0,a.yg)("img",{src:"https://files.seeedstudio.com/wiki/round_display_for_xiao/73.png",style:{width:700,height:"auto"}})),(0,a.yg)("h3",{id:"q2-when-uploading-a-program-for-xiao-rp2040-an-error-occurs-unaligned-opcodes-detected-in-executable-segment"},"Q2: When uploading a program for XIAO RP2040, an error occurs: unaligned opcodes detected in executable segment?"),(0,a.yg)("p",null,"Please modify the upload options of XIAO RP2040 according to the settings in the image below. All options work fine except the default ",(0,a.yg)("strong",{parentName:"p"},"Small (-Os) (standard)"),"."),(0,a.yg)("div",{style:{textAlign:"center"}},(0,a.yg)("img",{src:"https://files.seeedstudio.com/wiki/round_display_for_xiao/74.png",style:{width:600,height:"auto"}})),(0,a.yg)("h3",{id:"q3-why-do-i-get-a-pin-definition-error-when-i-compile-a-circular-screen-program-for-the-xiao-samd21"},"Q3: Why do I get a pin definition error when I compile a circular screen program for the XIAO SAMD21?"),(0,a.yg)("p",null,"When you encounter this error, please update your ",(0,a.yg)("strong",{parentName:"p"},"Seeed SAMD")," development board on-board package to the latest version."),(0,a.yg)("div",{style:{textAlign:"center"}},(0,a.yg)("img",{src:"https://files.seeedstudio.com/wiki/round_display_for_xiao/76.png",style:{width:700,height:"auto"}})),(0,a.yg)("h3",{id:"q4-why-does-the-screen-not-display-after-i-upload-the-program-to-xiao-esp32c3"},"Q4: Why does the screen not display after I upload the program to XIAO ESP32C3?"),(0,a.yg)("p",null,"If there is no problem with the program and it does not show up after uploading it may be that it needs to be reset. Just press the reset button on the XIAO ESP32C3."),(0,a.yg)("h2",{id:"tech-support--product-discussion-1"},"Tech Support & Product Discussion"),(0,a.yg)("p",null,"."),(0,a.yg)("p",null,"Thank you for choosing our products! We are here to provide you with different support to ensure that your experience with our products is as smooth as possible. We offer several communication channels to cater to different preferences and needs."),(0,a.yg)("div",{class:"button_tech_support_container"},(0,a.yg)("a",{href:"https://forum.seeedstudio.com/",class:"button_forum"}),(0,a.yg)("a",{href:"https://www.seeedstudio.com/contacts",class:"button_email"})),(0,a.yg)("div",{class:"button_tech_support_container"},(0,a.yg)("a",{href:"https://discord.gg/eWkprNDMU7",class:"button_discord"}),(0,a.yg)("a",{href:"https://github.com/Seeed-Studio/wiki-documents/discussions/69",class:"button_discussion"})))}p.isMDXComponent=!0}}]);