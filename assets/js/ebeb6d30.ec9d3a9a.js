"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[83824],{15680:(e,n,t)=>{t.d(n,{xA:()=>c,yg:()=>h});var i=t(96540);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function a(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);n&&(i=i.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,i)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?a(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):a(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,i,r=function(e,n){if(null==e)return{};var t,i,r={},a=Object.keys(e);for(i=0;i<a.length;i++)t=a[i],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(i=0;i<a.length;i++)t=a[i],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var l=i.createContext({}),d=function(e){var n=i.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):o(o({},n),e)),t},c=function(e){var n=d(e.components);return i.createElement(l.Provider,{value:n},e.children)},p="mdxType",g={inlineCode:"code",wrapper:function(e){var n=e.children;return i.createElement(i.Fragment,{},n)}},u=i.forwardRef((function(e,n){var t=e.components,r=e.mdxType,a=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),p=d(t),u=r,h=p["".concat(l,".").concat(u)]||p[u]||g[u]||a;return t?i.createElement(h,o(o({ref:n},c),{},{components:t})):i.createElement(h,o({ref:n},c))}));function h(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var a=t.length,o=new Array(a);o[0]=u;var s={};for(var l in n)hasOwnProperty.call(n,l)&&(s[l]=n[l]);s.originalType=e,s[p]="string"==typeof e?e:r,o[1]=s;for(var d=2;d<a;d++)o[d]=t[d];return i.createElement.apply(null,o)}return i.createElement.apply(null,t)}u.displayName="MDXCreateElement"},88578:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>g,frontMatter:()=>a,metadata:()=>s,toc:()=>d});var i=t(58168),r=(t(96540),t(15680));const a={description:"Getting Strarted with Grove Lightning Sensor AS3935",title:"Grove Lightning Sensor AS3935",keywords:["lightning"],image:"https://files.seeedstudio.com/wiki/seeed_logo/logo_2023.png",slug:"/grove-lightning-sensor-as3935",last_update:{date:"06/07/2023",author:"Citric"}},o=void 0,s={unversionedId:"Sensor/Grove/Grove_Sensors/Light/Grove-Lightning-Sensor-AS3935",id:"Sensor/Grove/Grove_Sensors/Light/Grove-Lightning-Sensor-AS3935",title:"Grove Lightning Sensor AS3935",description:"Getting Strarted with Grove Lightning Sensor AS3935",source:"@site/docs/Sensor/Grove/Grove_Sensors/Light/Grove-Lightning-Sensor-AS3935.md",sourceDirName:"Sensor/Grove/Grove_Sensors/Light",slug:"/grove-lightning-sensor-as3935",permalink:"/grove-lightning-sensor-as3935",draft:!1,editUrl:"https://github.com/Seeed-Studio/wiki-documents/blob/docusaurus-version/docs/Sensor/Grove/Grove_Sensors/Light/Grove-Lightning-Sensor-AS3935.md",tags:[],version:"current",lastUpdatedBy:"Citric",lastUpdatedAt:1686096e3,formattedLastUpdatedAt:"Jun 7, 2023",frontMatter:{description:"Getting Strarted with Grove Lightning Sensor AS3935",title:"Grove Lightning Sensor AS3935",keywords:["lightning"],image:"https://files.seeedstudio.com/wiki/seeed_logo/logo_2023.png",slug:"/grove-lightning-sensor-as3935",last_update:{date:"06/07/2023",author:"Citric"}},sidebar:"ProductSidebar",previous:{title:"Grove-Single Axis Analog Gyro",permalink:"/Grove-Single_Axis_Analog_Gyro"},next:{title:"Sensor - Light(introduction)",permalink:"/Sensor_light"}},l={},d=[{value:"Introduction",id:"introduction",level:2},{value:"Features",id:"features",level:3},{value:"Hardware Overview",id:"hardware-overview",level:2},{value:"Specifications",id:"specifications",level:3},{value:"Getting Started",id:"getting-started",level:2},{value:"Module power supply selection",id:"module-power-supply-selection",level:3},{value:"Arduino Example",id:"arduino-example",level:2},{value:"Demo: Using Grove Lightning Sensor on the Seeeduino",id:"demo-using-grove-lightning-sensor-on-the-seeeduino",level:3},{value:"Materials Required",id:"materials-required",level:4},{value:"Resources",id:"resources",level:2},{value:"Tech Support &amp; Product Discussion",id:"tech-support--product-discussion",level:2}],c={toc:d},p="wrapper";function g(e){let{components:n,...t}=e;return(0,r.yg)(p,(0,i.A)({},c,t,{components:n,mdxType:"MDXLayout"}),(0,r.yg)("div",{style:{textAlign:"center"}},(0,r.yg)("img",{src:"https://files.seeedstudio.com/wiki/Grove-lightning-sensor/6.jpg",style:{width:400,height:"auto"}})),(0,r.yg)("div",{class:"get_one_now_container",style:{textAlign:"center"}},(0,r.yg)("a",{class:"get_one_now_item",href:"https://www.seeedstudio.com/Grove-Lightning-Sensor-AS3935-p-5603.html"},(0,r.yg)("strong",null,(0,r.yg)("span",null,(0,r.yg)("font",{color:"FFFFFF",size:"4"}," Get One Now \ud83d\uddb1\ufe0f"))))),(0,r.yg)("br",null),(0,r.yg)("h2",{id:"introduction"},"Introduction"),(0,r.yg)("p",null,"The Grove Lightning Sensor is a highly sensitive sensor that detects electric fields free in air and using an internal proprietary algorithm determines if it is caused by the front end of a storm with lightning events. It is very easy to be used as a plug and play device using the Grove standard cable can accept several adjustments to be optimized for the application environment, both indoor or outdoor. "),(0,r.yg)("p",null,"The use is for preventive alert on incoming lightning front of a storm so to avoid injuries to electrical equipment or human and for weather research because can furnish several data on the strength and number of events. This sensor can be fully integrated with other sensors in a forecast weather station and be very useful in agriculture for crop protection in case of  incoming storms. Can detect the lightning front of a storm up to 30 \u2013 40 km distance, when is still out of sight."),(0,r.yg)("h3",{id:"features"},"Features"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("p",{parentName:"li"},"Extremely compact and easy to use sensor.")),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("p",{parentName:"li"},"Very sensitive to electric fields in air selects only ones that meet the wave form typical of lightning front, other are rejected.")),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("p",{parentName:"li"},"Communication trough I2C protocol with easy interface to Arduino, Seeeduino or Raspberry Pi development boards.")),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("p",{parentName:"li"},"Extremely low consumption, can go in sleep mode to reduce consume and Prolong battery life.")),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("p",{parentName:"li"},"Sends out on an IRQ pin the interrupt signal any time a lightning front is validated. Useful for micro-controller connection and software control.")),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("p",{parentName:"li"},"Grove system fully compatible interface.")),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("p",{parentName:"li"},"Easy integration in weather station or alerting devices to prevent injuries in electronic equipment or humans."))),(0,r.yg)("h2",{id:"hardware-overview"},"Hardware Overview"),(0,r.yg)("p",null,"Before everything starts, it is quite essential to have some basic parameters of the product. The following table provides information about the characteristics of Grove Lightning Sensor."),(0,r.yg)("h3",{id:"specifications"},"Specifications"),(0,r.yg)("table",{align:"center"},(0,r.yg)("tr",null,(0,r.yg)("th",{align:"center"},"Parameter"),(0,r.yg)("th",{align:"center"},"Range/Value")),(0,r.yg)("tr",null,(0,r.yg)("td",{align:"center"},"Input Voltage"),(0,r.yg)("td",{align:"center"},"5 Volt or 3.3 Volt (select appropriate solder pads)")),(0,r.yg)("tr",null,(0,r.yg)("td",{align:"center"},"Communication"),(0,r.yg)("td",{align:"center"},"I2C standard, SPI using the provided output")),(0,r.yg)("tr",null,(0,r.yg)("td",{align:"center"},"Maximum detection range"),(0,r.yg)("td",{align:"center"},"40 km")),(0,r.yg)("tr",null,(0,r.yg)("td",{align:"center"},"Programmable"),(0,r.yg)("td",{align:"left"},"Yes, appropriate registers can be programmed to fit the application and environment where the sensor is mounted."))),(0,r.yg)("h2",{id:"getting-started"},"Getting Started"),(0,r.yg)("h3",{id:"module-power-supply-selection"},"Module power supply selection"),(0,r.yg)("p",null,"The Grove Lightning Sensor supports two different supply voltages - 5V and 3.3V. You will need to determine your supply voltage and perform simple soldering before using the module."),(0,r.yg)("p",null,"If you choose for the ",(0,r.yg)("strong",{parentName:"p"},"5 Volt")," supply then solder pads (5V) and (0) on the Grove Lightning Sensor together as picture below."),(0,r.yg)("div",{style:{textAlign:"center"}},(0,r.yg)("img",{src:"https://files.seeedstudio.com/wiki/Grove-lightning-sensor/1.png",style:{width:500,height:"auto"}})),(0,r.yg)("p",null,"If you choose for the ",(0,r.yg)("strong",{parentName:"p"},"3.3 Volt")," supply then solder pads on the Grove Lightning Sensor together as picture below. This is the case if you are using the Seeed Arduino Breakout for Linkt Smart 7688 Duo board that works at 3.3 Volt."),(0,r.yg)("div",{style:{textAlign:"center"}},(0,r.yg)("img",{src:"https://files.seeedstudio.com/wiki/Grove-lightning-sensor/2.png",style:{width:500,height:"auto"}})),(0,r.yg)("admonition",{type:"note"},(0,r.yg)("p",{parentName:"admonition"},"The Grove Lightning Sensor can withstand a hot swap insertion with the boards supply ",(0,r.yg)("strong",{parentName:"p"},"ON")," but this is not recommended, always turn off supply before connecting the Grove Lightning Sensor to the board connector.")),(0,r.yg)("h2",{id:"arduino-example"},"Arduino Example"),(0,r.yg)("p",null,"The Arduino code here furnished permits to dialog with the sensor and to modify all the relevant registers which determines the best behaviour during operation. The sensor is furnished with  base values in registers as well described in the code, and this is a good starting point for application. Some work is necessary to get the best fit to application and this is a very challenging job working with the sensor, because shows extremely adaptable to the environment where is used."),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Step 1.")," Launch the Arduino application."),(0,r.yg)("div",{style:{textAlign:"center"}},(0,r.yg)("img",{src:"https://files.seeedstudio.com/wiki/seeed_logo/arduino.jpg",style:{width:800,height:"auto"}})),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Step 2.")," Select your development board model and add it to the Arduino IDE."),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("p",{parentName:"li"},"If you want to use ",(0,r.yg)("strong",{parentName:"p"},"Seeeduino")," for the later routines, please refer to ",(0,r.yg)("a",{parentName:"p",href:"https://wiki.seeedstudio.com/Seeed_Arduino_Boards/"},"this tutorial")," to finish adding.")),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("p",{parentName:"li"},"If you want to use ",(0,r.yg)("strong",{parentName:"p"},"Seeed Studio XIAO SAMD21")," for the later routines, please refer to ",(0,r.yg)("a",{parentName:"p",href:"https://wiki.seeedstudio.com/Seeeduino-XIAO/#software"},"this tutorial")," to finish adding.")),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("p",{parentName:"li"},"If you want to use ",(0,r.yg)("strong",{parentName:"p"},"Seeed Studio XIAO RP2040")," for the later routines, please refer to ",(0,r.yg)("a",{parentName:"p",href:"https://wiki.seeedstudio.com/XIAO-RP2040-with-Arduino/#software-setup"},"this tutorial")," to finish adding.")),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("p",{parentName:"li"},"If you want to use ",(0,r.yg)("strong",{parentName:"p"},"Seeed Studio XIAO nRF52840")," for the later routines, please refer to ",(0,r.yg)("a",{parentName:"p",href:"https://wiki.seeedstudio.com/XIAO_BLE/#software-setup"},"this tutorial")," to finish adding.")),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("p",{parentName:"li"},"If you want to use ",(0,r.yg)("strong",{parentName:"p"},"Seeed Studio XIAO ESP32C3")," for the later routines, please refer to ",(0,r.yg)("a",{parentName:"p",href:"https://wiki.seeedstudio.com/XIAO_ESP32C3_Getting_Started/#software-setup"},"this tutorial")," to finish adding."))),(0,r.yg)("h3",{id:"demo-using-grove-lightning-sensor-on-the-seeeduino"},"Demo: Using Grove Lightning Sensor on the Seeeduino"),(0,r.yg)("h4",{id:"materials-required"},"Materials Required"),(0,r.yg)("table",null,(0,r.yg)("thead",{parentName:"table"},(0,r.yg)("tr",{parentName:"thead"},(0,r.yg)("th",{parentName:"tr",align:"center"},"Seeeduino V4.3"),(0,r.yg)("th",{parentName:"tr",align:"center"},"Grove - Lightning Sensor AS3935"))),(0,r.yg)("tbody",{parentName:"table"},(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:"center"},(0,r.yg)("div",{style:{textAlign:"center"}},(0,r.yg)("img",{src:"https://files.seeedstudio.com/wiki/SeeeduinoV4/images/cover.JPG",style:{width:250,height:"auto"}}))),(0,r.yg)("td",{parentName:"tr",align:"center"},(0,r.yg)("div",{style:{textAlign:"center"}},(0,r.yg)("img",{src:"https://files.seeedstudio.com/wiki/Grove-lightning-sensor/6.jpg",style:{width:250,height:"auto"}})))),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:"center"},(0,r.yg)("a",{parentName:"td",href:"https://www.seeedstudio.com/Seeeduino-V4-2-p-2517.html"},(0,r.yg)("strong",{parentName:"a"},"Get ONE Now"))),(0,r.yg)("td",{parentName:"tr",align:"center"},(0,r.yg)("a",{parentName:"td",href:"https://www.seeedstudio.com/Grove-Lightning-Sensor-AS3935-p-5603.html"},(0,r.yg)("strong",{parentName:"a"},"Get ONE Now")))))),(0,r.yg)("admonition",{type:"caution"},(0,r.yg)("p",{parentName:"admonition"},"Please check that the front pads of the sensor have been soldered before use. If the position indicated in the picture is not soldered, you may experience problems with the IIC device not being detected when executing the programme later."),(0,r.yg)("div",{style:{textAlign:"center"}},(0,r.yg)("img",{src:"https://files.seeedstudio.com/wiki/Grove-lightning-sensor/7.jpg",style:{width:400,height:"auto"}}))),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Step 3"),". Connect Grove Lightning Sensor to port I2C of Seeeduino V4."),(0,r.yg)("div",{style:{textAlign:"center"}},(0,r.yg)("img",{src:"https://files.seeedstudio.com/wiki/Grove-lightning-sensor/3.jpg",style:{width:700,height:"auto"}})),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Step 4"),". Connect Seeeduino to PC via a Micro-USB cable."),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Step 5"),". Upload the following program to Seeeduino."),(0,r.yg)("details",null,(0,r.yg)("summary",null,"Click here to preview the full code"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-cpp"},'//*********************************************************************************\n//***************  Designed for Seeed Grove sensor developments *******************\n//***************  GROVE   FRANKLYN LIGHTNING SENSOR AS3935     *******************\n//***************  front of lightning fall detection sensor     ******************* \n//***************                                               *******************\n//*************** first release: 1.0 - 10/15/2022               ******************* \n//*************** Author: Davide Cogliati                       *******************\n//*********************************************************************************\n//\n//Abstract on the work:\n//------------------------------------------------------------------------------------------------------\n//This GROVE Sensor board integrates the AS3935 a programmable fully integrated Lightning\n//Sensor IC that detects the  approach of lightning activity in the vicinity and provides an\n//estimation of distance to the head of the storm. In the AS3935 there is an embedded lightning\n//algorithm that checks the incoming signal form during time and rejects the potential man-made \n//disturbers as false alarms.\n//The AS3935 can also provide information on the noise level and inform the external microcontroller  \n//in case of high  noise conditions, with the noise floor generator and noise floor  evaluation blocks. \n//These latter functions are  programmable via the internal registers to optimize the working on \n//field of the sensor itself (INDOOR, OUTDOOR).\n//The AS3935 can be programmed via I\xb2C or a 4-wire standard SPI. Also along with I\xb2C it is possible to \n//choose among three different addresses (0X01, 0X02, 0X03). Two  clocks are internally generated by two different \n//RC-Oscillators: TRCO and SRCO and an automatic calibration  procedure can be run on command to increase the \n//precision of those oscillators any time the sensor is turned ON. \n//The board can be supplied by 5 Volt or by an internal  3.3 Volt voltage   regulator by choosing the correct settings \n//by jumper on the board.\n//The board results very sensitive to electromagnetic fields so accidental peaks or false lightnings can be \n//revealed, of course the setup of the internal registers can optimize the false triggering events. \n//If a microprocessor is connected to the board via the  I\xb2C bus and the IRQ pin provided on the board the \n//lightning alarms can be managed in the best way achieving also a filtering on the events writing an \n//appropriate algorithm.\n//This board was tested connecting an oscilloscope on the IRQ pin output and running the SERIAL PLOTTER & SERIAL \n//MONITOR of  ARDUINO GUI then simulating disturbing actions or simulating lightning so to make the device \n//trigger as appropriate.\n//Analisis of the experimental result show an extreme sensitivity to events and capability of the internal \n//firmware of the AS3935 to capture disturbance or simulated lightnings. Of course during test, modification \n//of the  internal registers was done in order to watch how the response changed.\n//\n//-----------------------------------------------------------------------------------------------------\n//Sketch philosophy:                     ---------------------------------------------------------------\n//-----------------------------------------------------------------------------------------------------\n//This sketch has been designed to give an easy way to get working with the AS3935\n//Grove sensor with all in a sketch. This sketch is an example on how to work out\n//the sensor functionality in direct way, optimizing the register contents to influence\n//the final behaviour of the sensor. Working with this sketch let you manage also in\n//way the data ouput that can be in plain text form using the SERIAL MONITOR or in a\n//graphical way using the SERIAL PLOTTER in the ARDUINO GUI.\n//Only 1 library is needed, the "#include <Wire.h>  //FOR I2C MODE COMUNICATION BUS" in order\n//to make all very simple, all other Software features are written by hand.\n//\n//This sketch provides testing of sensor internal registers and an I2C Device Address identification\n//routine to test  the board  soldering   A0, A1 taps in order to change device address.\n//This sketch doesn\'t manage the SPI functionality communication port but the the I2C port\n//which is the GROVE standard. To work with the SPI port some jumper and soldering taps are\n//provided on the board (SI tap) and a 4 way connector pads for SPI connection are\n//placed on one side of the board.\n//\n//This board can work at 5.0 Volt or 3.3 Volt supply   to optimize the interfacing to the\n//microcontroller supply voltage. To choose one or the other supply a system of easy\n//jumper selection is provided on the board, the Standard supply is 5.0 Volt.\n//If the SPI communication port will be used the communication instructions of these sketch\n//should be modified so to use SPI instead of I2C and the ARDUINO \n//free "#include <SPI.h>  //FOR SPI MODE COMUNICATION BUS" is to be put instead of the \n//"#include <Wire.h>".\n//This sketch is to get quickly using the sensor AS3935 without boring on many features\n//to understand, but of course all necessary modification can be made to adapt it to final\n//use in application.\n//----------------------------------------------------------------------------------------------------\n//\n//********************************************************************************\n//********************************************************************************\n//********************************************************************************\n\n#include <Wire.h>  //FOR I2C MODE COMUNICATION BUS\n\n\n//------------------------------------------------------------------------------------------------\n//bit0= 0  0= power ON ------\x3e SET THIS MANUALLY to  POWER OFF STATE the SENSOR !!!\n//         1= power OFF\n//bit 1..5= AFE (gain) = 10010 (default value)\n//Indoor  10010 suggested\n//Outdoor 01110 suggested\n//-----------------------------------------------------------------------------------------------\n#define INDOOR            0b00100100 //power ON bit0= 0\n#define OUTDOOR           0b00011100 //power ON bit0= 0\n//-----------------------------------------------------------------------------------------------\n#define DIRECT_COMMAND    0x96 //write this value in the following registers to operate a command\n//---------------------------------\n//  Action                 REGISTER\n//---------------------------------\n//  PRESET_DEFAULT          0x3C\n//  CALIB_RCO               0x3D\n//---------------------------------\n//--------------------------------------------------\n//global variables\n//--------------------------------------------------\n char REG0X02reset_startup ;         //this is used during resetting STATISTICAL in working operation\n char REG0X02reset_startup_up ;      //this is used to start up the sensor\n char REG0X02reset_startup_down ;    //this is used to start down the sensor\n\n//-----------------------------------------------------------------------------\n//VERY IMPORTANT TO SEE RESULTS OUTPUT WITH ARDUINO SERIAL          -----------\n//-----------------------------------------------------------------------------\n//SET THE DISPLAY MODE WITH ARDUINO:\n//select directly in ARDUINO GUI for "SERIAL MONITOR" or "SERIAL PLOTTING"\n//----------------------------------------------------------------------------\n//+) serial monitor   = data flow in legible format and variables readout\n//+) serial plotting  = show  plotting of lightning events and other variables\n//--------------------------------------------------------------------------------------------------------\nchar LITERAL_mode =1;  //0= no print data in SERIAL MONITOR,    1= yes print data on SERIAL MONITOR\nchar GRAPH_mode =0;    //0= no graphical data in SERIAL PLOTTER,  1= yes graphical data   SERIAL PLOTTER\n//--------------------------------------------------------------------------------------------------------\n  \n\n\n//--------------------------------------------------------------------------------\n//I2C ADDRESS SCANNER - FINDER          |\n//---------------------------------------\n//checks the presence of a valid AS3935 sensor online (this part can be omitted \n//in final application but use it during setting up for first time the I2C address\n//----------------------------------------------------------------------------------\nvoid setup()\n{\n  Serial.begin(9600); \n  \n  if (LITERAL_mode ==1)\n      {\n      Serial.println("AS3935 LIGHTNING SENSOR| i2C SCANNER");\n      Serial.println("Starting....");\n      Serial.println("------------------------------------");\n      delay(1000);\n      }\n  Wire.begin();\n  Wire.setClock(100000); // set I2C  speed \n\n}\n\n//------------------------------------------------------------------------------------\n//------------------------------------------------------------------------------------\nvoid loop()\n{\n  int c;\n  int indevice;   //device number I2C address, in final application you can assign \n                  //directly the address (for example: indevice = 3;)\n \n  //---------------------------------------------------\n  // read/write functions for I2C mode:\n  //---------------------------------------------------\n  //**************************************************************************\n  //**************************************************************************\n  int done =1;       //flag to start self test on I2C sensor address\n    indevice = 0;    //reset address value\n    while (done)\n    {\n\n     \n    indevice = indevice +1 ; \n    if (indevice > 7)\n        indevice=0;\n       \n    Wire.requestFrom(indevice, 1);    // Request 1 bytes from slave device \n    \n    if (LITERAL_mode ==1)\n      {\n       Serial.print("scanning device = 0x0");         // Print the character\n       Serial.print(indevice);       \n       Serial.println(" ");\n      }\n    delay(250);\n  \n    //-----------------------------------------------------------\n    // SCANNED & FOUNF VALID  ADDRESS SHOWING REGISTER CONTENT\n    //-----------------------------------------------------------\n    //-----------------------------------------------------------\n    while(Wire.available()) \n    {\n        c = Wire.read();    // Receive a byte as character\n        if (LITERAL_mode ==1)\n         {\n           Serial.println();               \n           Serial.print("data=.......... valid address .................. ");  // Print the character RECEIVED\n           Serial.println();             \n           Serial.print("found ADDR: 0X0");\n           Serial.print(indevice);\n           Serial.print(" --\x3e  answer: ");\n           Serial.print("[ ");\n           Serial.print((int)c);         // Print the character\n           Serial.print(" ]");           \n         }  \n        //-------------------------------------------------------------------------------------------------\n        //registers FOR SETTING I2C ADDRESS: A0 & A1 using the soldering TAPS on the GROVE SENSOR A0, A1\n        //-------------------------------------------------------------------------------------------------\n        //A0        A1         ADR  0X0 \n        //****************************************************\n        //SOLDER   SOLDER    < NOT ALLOWED !!!!>         *****\n        //SOLDER   NO        0X01    ;SOLDER TAP A0      *****\n        //NO       SOLDER    0X02    ;SOLDER TAP A1      *****\n        //NO       NO        0X03    ;NO SOLDERED TAPS   *****\n        //----------------------------------------------------\n        //--------------------------------------------------------------------------------------------\n        //LIST OF THE  SETUP AND RESULT REGISTERS OF THE AS3935       --------------------------------\n        //--------------------------------------------------------------------------------------------\n        //AS3935_REGISTER_NAMES     |  write=W / read=R  |   reserved bits = x, modifiable bits= a\n        //--------------------------------------------------------------------------------------------\n        // AFE_GAIN          = 0x00     W/R                 > XXaa aaaa                            \n        // THRESHOLD,        = 0X01     W/R                 > aaaa aaaa\n        // LIGHTNING_REG     = 0X02     W/R                 > Xaaa aaaa\n        // INT_MASK_ANT      = 0X03     W/R                 > aaaa Xaaa\n        // ENERGY_LIGHT_LSB  = 0X04     R                   > -\n        // ENERGY_LIGHT_MSB  = 0X05     R                   > -\n        // ENERGY_LIGHT_MMSB = 0X06     R                   > -\n        // DISTANCE          = 0X07     R                   > -\n        // DISP /TUNING CAP  = 0X08     W/R                 > aaaa aaaa\n        // CALIB_TRCO        = 0x3A     R                   > -\n        // CALIB_SRCO        = 0x3B     R                   > -\n        // PRESET            = 0x3C     W/R                 > aaaa aaaa  <--YOU CAN SEND DIRECT COMMAND IN THIS REGISTER (set all to default)!!!\n        // CALIB_RCO         = 0x3D     W/R                 > aaaa aaaa  <--YOU CAN SEND DIRECT COMMAND IN THIS REGISTER (self calibration) !!!\n        //--------------------------------------------------------------------------------------------\n        //\n        //--------------------------------------------------------------------------------------------\n        //TUNE UP THE SENSOR &  write  data to  selected register  !                 ----------------\n        //--------------------------------------------------------------------------------------------\n        //for more .... PLEASE REFERE TO DATASHEET AS3935 !!!                        -----------------\n        //--------------------------------------------------------------------------------------------\n        //REGISTER 0X00: bits [0] and bits [1..5]\n        //----------------------------------------\n          if (LITERAL_mode ==1)\n          {  \n            Serial.println();\n            Serial.print("writing to REGISTER 0x00 ");\n          }  \n        Wire.beginTransmission(indevice);\n        Wire.write(0x00);\n        //------------------------------\n        //bit0= 0  power ON ------\x3e SET THIS MANUALLY IF WANT TO PUT IN POWER OFF STATE THE SENSOR !!!\n        //bit 1..5= AFE (gain) = 10010 (default value)\n        //Indoor  10010 suggested\n        //Outdoor 01110 suggested\n        //------------------------------\n        //BYTE = 00 10010 0 (0x24 hex)\n        //------------------------------\n        //INDOOR  = if indoor ...\n        //OUTDOOR = if outdoor...\n        Wire.write(INDOOR);\n        Wire.endTransmission(true);\n        if (LITERAL_mode ==1)\n           {   \n             Serial.println();\n             Serial.print("Done ! ");\n             Serial.println();\n           }  \n        delay(200);\n        //------------------------------------------\n        //REGISTER 0X01: bits [0..3] and bits[4..6]\n        //------------------------------------------\n        if (LITERAL_mode ==1)\n         { \n          Serial.println();\n          Serial.print("writing to REGISTER 0x01 ");\n         }  \n        Wire.beginTransmission(indevice);\n        Wire.write(0x01);\n        //-------------------------------------------------\n        //bit0..3 watchdog threshold = 0010 (default value)\n        //bit4..6 noise floor level  = 010  (default value)\n        //---------------------------------------------------------------------------------------------------------------------------------------------\n        // Continuous Input Noise Level |[\u03bcVrms]              Continuous Input Noise Level                     REG0x01[6]  REG0x01[5]    REG0x01[4]\n        //    [\u03bcVrms] (oudoor)                                        [\u03bcVrms] (Indoor)  \n        //---------------------------------------------------------------------------------------------------------------------------------------------\n        //      390                                                          28                                   0         0           0\n        //      630                                                          45                                   0         0           1\n        //      860                                                          62                                   0         1           0\n        //      1100                                                         78                                   0         1           1\n        //      1140                                                         95                                   1         0           0\n        //      1570                                                         112                                  1         0           1\n        //      1800                                                         130                                  1         1           0\n        //      2000                                                         146                                  1         1           1\n        //---------------------------------------------------------------------------------------------------------------------------------------------  \n        //BYTE = 0 010 0010 (0x22 hex)\n        //-------------------------------------------------\n        \n        Wire.write(0b00100010);\n        Wire.endTransmission(true);\n        if (LITERAL_mode ==1)\n        {  \n          Serial.println();\n          Serial.print("Done ! ");\n          Serial.println();\n        } \n        delay(200);\n        //-------------------------------------\n        //REGISTER 0X02:\n        //-------------------------------------\n        if (LITERAL_mode ==1)\n        {  \n         Serial.println();\n         Serial.print("writing to REGISTER 0x02 ");\n        }  \n        Wire.beginTransmission(indevice);\n        Wire.write(0x02);\n        //-------------------------------------------------\n        //bit0..3 spike rejection = 0010 (default value)    ------\x3e greater values gives more rejection\n        //                                                  ------\x3e against disturbance but decreases sensitivity\n        //bit4..5 number of lightnings = 00 (default value) ------\x3e you can modify these 2 bits as required\n        //bit6   clear statistics = 1 (default value)       ------\x3e clear internal collected data\n        //BYTE = 0 100 0010 (0x42 hex)\n        //-------------------------------------------------\n        REG0X02reset_startup_up =   0b01000010;   //this is used during resetting STATISTICAL in working operation\n        REG0X02reset_startup_down = 0b00000010;   //this is used during resetting STATISTICAL in working operation\n        REG0X02reset_startup   = 0b01000010;      //this is used at start  the sensor\n        Wire.write( REG0X02reset_startup);\n        Wire.endTransmission(true);\n        if (LITERAL_mode ==1)\n        {   \n          Serial.println();\n          Serial.print("Done ! ");\n          Serial.println();\n        }  \n        delay(200);\n        //-------------------------------------\n        //REGISTER 0X03:\n        //-------------------------------------\n          if (LITERAL_mode ==1)\n      {     \n        Serial.println();\n        Serial.print("writing to REGISTER 0x03");\n       }  \n        Wire.beginTransmission(indevice);\n        Wire.write(0x03);\n        //-------------------------------------------------\n        //bit5    mask disturber  = 0 (default value -> NO MASKING)\n        //bit6..7 frequency division ratio for  tuning  = 00 (default value)\n        //all other bits  are reserved or read only !!!\n        //BYTE = 0 000 0000 (0x00 hex)\n        //-------------------------------------------------\n        Wire.write(0b00000000);\n        Wire.endTransmission(true);\n        if (LITERAL_mode ==1)\n         {    \n          Serial.println();\n          Serial.print("Done ! ");\n          Serial.println();\n         }  \n        delay(200);\n        //-----------------------------------------------------\n        //REGISTER 0X08:\n        //-----------------------------------------------------\n        if (LITERAL_mode ==1)\n        {   \n          Serial.println();\n          Serial.print("writing to REGISTER 0x08 ");\n        }  \n        Wire.beginTransmission(indevice);\n        Wire.write(0x08);\n        //-------------------------------------------------\n        //bit0..3 Internal Tuning Capacitors (from 0 to 120pF in steps of 8pF) = 000 (default value) ---\x3e to get best match to 500 kHz resonance frequency\n        //------------------------------------\n        // Here you give the value of the capacitor you want turned on. It accepts up to 120pF in steps of 8pF: 8, 16, 24, 32 etc.The change in frequency is\n        // somewhat modest. At the maximum value you can lower the frequency up to 22kHz. As a starting point, the products designed in house ship around 496kHz\n        //(though of course every board is different) putting you within one percenT of a perfect resonance; the datasheet specifies being within 3.5 percent as\n        // optimal. \n        //\n        //\n        //bit5    Display TRCO on IRQ pin  = 0 (default value) ---------\x3e put it to "1" to enable frequency square wave OUT on INT pin of the board !\n        //bit6    Display SRCO on IRQ pin  = 0 (default value) ---------\x3e put it to "1" to enable frequency square wave OUT on INT pin of the board !\n        //bit7    Display LCO on IRQ pin   = 0 (default value) ---------\x3e put it to "1" to enable antenna resonance frequency square wave OUT on INT pin of the board !\n        //-------------------------------------\n        //TRCO - Timer RCO Oscillators 1.1MHz\n        //SRCO - System RCO at 32.768kHz\n        //LCO - Frequency of the Antenna\n        //-------------------------------------\n        //BYTE = 0 000 0000 (0x00 hex)\n        //-----------------------------------------------------------------------------------------------------------------------------------\n        //STEPS TO DEBUG HARDWARE THE RESONANCE FREQUENCY OF THE BOARD:\n        //--------------------------------------------------------------\n        //1) Observing LCO 500 Khz center resonance frequency requires to connect an oscilloscope probe to the IRQ pin of the Seed Grove AS3935\n        //2) Then place bit 7= 1 and bit 5=0, bit 6=0;\n        //3) Then start application after programming with this Sketch.\n        //4) Finally the frequency measured must be multiplied by the internal DIVISION FACTOR as shown below:\n        //-----------------------------------------------------------------------------------------------------------------------------------\n        // Division Ratio REG0x03[7] REG0x03[6]\n        //  16          0               0\n        //  32          0               1\n        //  64          1               0\n        //  128         1               1\n        //-------------------------------------------------------------------------------------------------------------------------------\n        //In this case DIV RATIO= 16, so if the measure is 31.9 kHz this is finally 510.4 kHz 31.9 x 16), and is a 2.0 % variation \n        //and is OK because  the data sheet suggests to stay < 3.5 % to achieve best results with the board.\n        //--------------------------------------------------------------------------------------------------------------------------------\n        Wire.write(0b00000000);  //to achieve LCO on IRQ pin program (0b10000000)\n        Wire.endTransmission(true);\n        if (LITERAL_mode ==1)\n         { \n           Serial.println();\n           Serial.print("Done ! ");\n           Serial.println();\n         } \n        delay(200);\n        //***************************************************************************\n        //------------------------------------------------\n        //OPTIONAL direct command issue to the AS3935\n        //------------------------------------------------\n        //-----------------------------------------------------------------------------------------------\n        //  DIRECT_COMMAND    0x96 //write this value in the following registers to operate a command\n        //---------------------------------\n        //  Action                 REGISTER\n        //---------------------------------\n        //  PRESET_DEFAULT          0x3C\n        //  CALIB_RCO               0x3D\n        //---------------------------------\n             if (false)     //------\x3e write "true" to activate direct command\n            { \n             Wire.beginTransmission(indevice);\n             Wire.write(0x3C);\n             Wire.write(0x96);\n             Wire.endTransmission(true);\n             if (LITERAL_mode ==1)\n              {    \n                Serial.println();\n                Serial.print("Done PRESET DEFAULT ! ");\n                Serial.println();\n               }  \n             delay(1500);\n            }\n            //---------------------------------\n            if (false)     //------\x3e write "true" to activate direct command\n            { \n             Wire.beginTransmission(indevice);\n             Wire.write(0x3D);\n             Wire.write(0x96);\n             Wire.endTransmission(true);\n             if (LITERAL_mode ==1)\n              {    \n                Serial.println();\n                Serial.print("Done CALIBRATION RCO ! ");\n                Serial.println();\n               }  \n             delay(1500);\n             }\n        //***************************************************************************\n        //-------------------------------------------------------------------------\n        //SCAN INTERNAL SETTING REGISTERS AND SHOW SETUP SAVED IN I2C   !!!\n        //-------------------------------------------------------------------------\n        int NOISEFLOOR;\n        int SPIKEREJECTION; \n        int WATCHDOGTHRESHOLD; \n        \n        if (LITERAL_mode ==1)\n         {   \n           Serial.print("DEVICE REGISTERS [0X00] to [0x08]  and [0x3A, 0X3B] ");\n         }     \n        //indevice = 3;\n        for (int i=0; i<9; i++)\n          { \n            Wire.beginTransmission(indevice);\n            Wire.write(i); //address to be read  \n            Wire.endTransmission(false);   //do not release the line!\n            if (LITERAL_mode ==1)\n              {   \n               //Serial.print("DEVICE REGISTERS [0X00] to [0x08]  and [0x3A, 0X3B] "); \n               Serial.println();             \n               Serial.print("REGISTER address = 0x0");   \n               Serial.print(i);               // Print the character\n            } \n            delay(200);\n            Wire.requestFrom(indevice,1); // request bytes from register XY\n             //-----------------------------------------------------------------------\n\n            c=0;\n            while(Wire.available())\n              {\n                 c = Wire.read();    // Receive a byte as character\n               if (i== 1)\n                {\n                 NOISEFLOOR= c;\n                 NOISEFLOOR = NOISEFLOOR & (0b01110000);\n                 NOISEFLOOR = NOISEFLOOR / 16; ; //shift  to right 4 bits.\n                }\n               if (i== 1)         \n                {\n                 SPIKEREJECTION= c;\n                 SPIKEREJECTION = SPIKEREJECTION & (0b00001111);\n                }\n                if (i== 2)\n                {\n                  WATCHDOGTHRESHOLD= c;\n                  WATCHDOGTHRESHOLD =  WATCHDOGTHRESHOLD & (0b00001111);\n                }\n\n               if (LITERAL_mode ==1)\n               {        \n                Serial.print(" *** REGISTER data= [ ");         // Print the character\n                Serial.print((unsigned int)c);\n                Serial.print(" ]");\n               }   \n             }\n             delay(200);\n          }\n            //------------------------------------------------\n            //OUTPUT OF MAIN SETUP\n            //------------------------------------------------\n            if (LITERAL_mode ==1)\n              {  \n               Serial.println();\n               Serial.println("*************************************************************************");\n               Serial.println("* THESE REGISTER INFLUENCE SYSTEM DETECTION FIGURE, MODIFY AS NECESSARY *");\n               Serial.println("*************************************************************************");\n               Serial.println();\n               Serial.print("Noise floor set: ");\n               Serial.println(NOISEFLOOR,DEC);\n               Serial.print("Spike rejection is: ");\n               Serial.println(SPIKEREJECTION,DEC);\n               Serial.print("WATCHDOG setpoint is: ");\n               Serial.println(WATCHDOGTHRESHOLD,DEC);\n               }\n\n         \n            //----------------------------------\n            //----------------------------------\n            //---------------------------------------------------------------------------------\n            //special registers SETUP   -------------------------------------------------------\n            //---------------------------------------------------------------------------------\n            // TRCO              = 0x3A  calibration state of TRCO\n            // bit7 =  TRCO_CALIB_DONE  Calibration of TRCO done (1=successful)\n            // bit6 =  TRCO_CALIB_NOK   Calibration of TRCO unsuccessful (1=not successful)\n            //---------------------------------------------------------------------------------  \n            // SRCO              = 0X3B calibration state of SRCO\n            // bit7 =  SRCO_CALIB_DONE  Calibration of TRCO done (1=successful)\n            // bit6 =  SRCO_CALIB_NOK   Calibration of TRCO unsuccessful (1=not successful)\n            //---------------------------------------------------------------------------------\n            if (LITERAL_mode ==1)\n             { \n              Serial.println("*****************************************************");\n              Serial.println("State of calibration of the sensor:");\n              Serial.println("*****************************************************");\n              }\n            Wire.beginTransmission(indevice);\n            Wire.write(0x3A); //address to be read \n            Wire.endTransmission(false);   //do not release the line!\n             if (LITERAL_mode ==1)\n              { \n                Serial.println();        // carriage return after the last label\n                Serial.print("REGISTER address = 0x3A");         // Print the character\n              }\n            Wire.requestFrom(indevice,1); // request bytes from register XY\n            //-------------------------------------------------------------------------\n            c=0;\n            while(Wire.available())\n            {\n               c = Wire.read();    // Receive a byte as character\n                if (LITERAL_mode ==1)\n               {\n                 Serial.print(" *** REGISTER data= [ ");         // Print the character\n                 Serial.print(c, BIN);         // Print the character \n                 Serial.print(" ]");\n                 Serial.println();\n                 c= c & 0b10000000;\n                   if(c > 0)\n                   Serial.print("< TRCO calibration DONE >");         // Print the character\n                   if(c == 0)\n                   Serial.print("< TRCO calibration NOT DONE >");         // Print the character\n              }\n             }\n            delay(200);\n            //-----------------------------------------------------------\n            Wire.beginTransmission(indevice);\n            Wire.write(0x3B); //address to be read \n            Wire.endTransmission(false);   //do not release the line!\n\n            if (LITERAL_mode ==1)\n             { \n               Serial.println();        // carriage return after the last label\n               Serial.print("REGISTER address = 0x3B");         // Print the character\n              }\n            Wire.requestFrom(indevice,1); // request bytes from register XY\n            c=0;\n            while(Wire.available())\n             {\n               c = Wire.read();    // Receive a byte as character\n                 if (LITERAL_mode ==1)\n                  { \n                    Serial.print(" *** REGISTER data= [ ");         // Print the character\n                    Serial.print(c,BIN);         // Print the character \n                    Serial.print(" ]");\n                    Serial.println();\n                     c= c & 0b10000000;\n                       if(c > 0)\n                       Serial.print("< SRCO calibration DONE >");             // Print the character\n                       if(c == 0)\n                       Serial.print("< SRCO calibration NOT DONE >");         // Print the character\n                    Serial.println();\n                    Serial.println("*****************************************************");\n                   }\n            done =0;     //---------\x3e DONE THE CALIBRATION AND INTERNAL REGISTERS SETUP EXIT "while loop"\n            }\n            delay(200);\n        }\n        delay(1000); \n     }\n             //--------------------------------------------------------------------------\n             //WAITING CYCLE - ENDLESS - LOOKING FOR LIGHTNINGS\n             //variables from AS3935 during operative cycle\n             //--------------------------------------------------------------------------\n             int INT_struck ; //event interrupt register\n             int N_lightning; //number of lightnings detected\n             int Av_distance; //average distance extimation\n             int NOISE; //interrupt for high noise level\n             int Disturber; //interrupt for disturber detected\n             int L_struck; //interrupt for lightning detected\n             int Distance; //estimated hit distance\n             int Energy_LSB; //energy single event LOW BYTE\n             int Energy_MSB; //energy single event HIGH BYTE\n             int Energy_MMSB; //energy single event AV.Energy content\n             //-------------------------------------------------\n             //-------------------------------------------------\n             //GRAPH SCALING MIN-MAX: MODIFY AS YOU LIKE!!!\n             //-------------------------------------------------\n             int  MAX_scale =30;        //setting max Y of plotting\n             int  min_scale =0;         //setting min Y of plotting\n             //-------------------------------------------------\n             //PRINT OUT METHOD:\n             //---------------------------------------------------------------------------\n             //  LITERAL_mode =0;    //0= no printing data on SERIAL MONITOR\n             //  GRAPH_mode   =1;    //1= yes print graphical data in SERIAL PLOTTER\n             //---------------------------------------------------------------------------\n             //*****************************************\n             //SET UP THE PLOTTER X-Y READINGS (X= time)\n             //*****************************************\n            Serial.print("MAX"); //max line marker\n            Serial.print(" ");\n            Serial.print("min");//min line marker \n            Serial.print(" ");\n            //*****************************************\n            //SETUP LABELS NAME\n            //*****************************************\n            Serial.print("NOISE");\n            Serial.print(" ");\n            Serial.print("Disturber");\n            Serial.print(" ");\n            Serial.print("Distance");\n            Serial.print(" ");\n            Serial.print("Energy_MSB/20");  //SCALED FACTOR /20\n            Serial.print(" ");\n            Serial.print("Energy_MMSB");\n            //Serial.print(" ");\n            Serial.println();\n            //**************************************************\n            //**************************************************\n            // STARTING ENDLESS OBSERVATION CYCLE FOR EVENTS\n            //**************************************************\n            //**************************************************\n             while (1)\n             {\n               if (LITERAL_mode ==1)\n              { \n               Serial.println();\n               Serial.print(" *** WAITING FOR LIGHTNING - WATCHING ");         // Print the character\n               Serial.println();\n              } \n               //------------------------------------------------------------------------\n               //register OF INTEREST reading !\n               //------------------------------------------------------------------------               \n           // indevice = 3;\n\n               //------------------------------------------------------------------\n               //CHECK FOR INCOMING INT MESSAGE ON REG 0X03 bit= INT_L ---\x3e "1000"\n               //------------------------------------------------------------------\n            Wire.beginTransmission(indevice);\n            Wire.write(0x03); //address to be read\n            Wire.endTransmission(false);   //do not release the line!\n            Wire.requestFrom(indevice,1); // request bytes from register XY\n            c=0;\n            while(Wire.available())\n            {\n              //------------------------\n              //CLEAN the variables\n              //------------------------\n              NOISE =0 ;\n              Disturber =0;\n              L_struck =0 ;\n              Distance =0 ;\n              Energy_LSB =0 ;\n              Energy_MSB =0 ;\n              Energy_MMSB =0 ;\n              //------------------------\n              c = Wire.read();    // Receive a byte as character\n              INT_struck = c;\n              NOISE  =INT_struck & (0b00000001);\n              Disturber  =INT_struck & (0b00000100);\n              L_struck  =(INT_struck & (0b00001000))/8;  //this is a flag bit so can be 0 or 1.\n             }\n           //------------------------------------------------------------------------------------------------\n           //DEBUG ALL !!!\n           //------------------------------------------------------------------------------------------------\n           // L_struck =1; ---\x3e   this show all messages, testing purpose-DEBUG of AS3935 system remove "//"\n           //\n           //-------------------------------------------------------------------------------------------------\n          if ((GRAPH_mode == 1) & (L_struck ==0))\n            {\n            //------------------------------------------------\n            //GRAPH- PLOTTER  FORM OF EVENT READINGS\n            //------------------------------------------------\n          \n            Serial.print(MAX_scale);\n            Serial.print(" ");\n            \n            Serial.print(min_scale);\n            Serial.print(" ");\n            //Disturber=20;\n            //Distance=30;\n            //Energy_MMSB=40;\n            //------------------------------------------------\n            Serial.print(NOISE,DEC);\n            Serial.print(" ");\n            Serial.print(Disturber,DEC);\n            Serial.print(" ");\n            Serial.print(Distance,DEC);\n            Serial.print(" ");\n            //Serial.println(Energy_LSB,DEC);\n            //Serial.print(" ");\n            Energy_MSB = Energy_MSB/20;   //JUST A SCALING FACTOR TO PLOT !\n            Serial.print(Energy_MSB,DEC);\n            Serial.print(" ");\n            Serial.print(Energy_MMSB,DEC);\n            Serial.print(" ");\n            Serial.println();\n            } \n           //------------------------------------------------------------------------------\n           if (L_struck > 0)\n            {\n          \n           //----------------------------------------------------------------\n           //distance estimation - other lightning data - energy calculation\n           //----------------------------------------------------------------\n           //DISTANCE:\n           //---------------\n            Wire.beginTransmission(indevice);\n            Wire.write(0x07); //address to be read\n            Wire.endTransmission(false);   //do not release the line!\n            Wire.requestFrom(indevice,1); // request bytes from register XY\n            c=0;\n            while(Wire.available())\n            {\n            c = Wire.read();    // Receive a byte as character\n            Distance = c;\n            Distance  = Distance & (0b00111111);\n            }\n            //-------------------------\n            //ENERGY LSB - MSB - MAIN\n            //-------------------------\n            Wire.beginTransmission(indevice);\n            Wire.write(0x04);              //address to be read\n            Wire.endTransmission(false);   //do not release the line!\n            Wire.requestFrom(indevice,1);  // request bytes from register XY\n            c=0;\n            while(Wire.available())\n            {\n            c = Wire.read();    // Receive a byte as character\n            Energy_LSB = c;\n             }\n            //-------------------------\n            //ENERGY MSB \n            //-------------------------\n            Wire.beginTransmission(indevice);\n           // Wire.requestFrom(indevice, 1);    // Request 1 bytes from slave device \n            Wire.write(0x05); //address to be read\n            Wire.endTransmission(false);   //do not release the line!\n            Wire.requestFrom(indevice,1); // request bytes from register XY\n            c=0;\n            while(Wire.available())\n            {\n            c = Wire.read();    // Receive a byte as character\n            Energy_MSB = c;\n             }\n            //-------------------------\n            //ENERGY MMSB \n            //-------------------------\n            Wire.beginTransmission(indevice);\n            Wire.write(0x06); //address to be read\n            Wire.endTransmission(false);   //do not release the line!\n            Wire.requestFrom(indevice,1); // request bytes from register XY\n            c=0;\n            while(Wire.available())\n            {\n            c = Wire.read();    // Receive a byte as character\n            Energy_MMSB = c;\n            Energy_MMSB  = Energy_MMSB & (0b00011111);\n            }\n            //-------------------------------------------------------------------------\n            //select type of readout FULL NUMERICAL DATA or GRAPH DATA\n            //-------------------------------------------------------------------------\n            if (GRAPH_mode == 1)\n            {\n            //------------------------------------------------\n            //LEGIBILE FORM OF EVENT READINGS\n            //------------------------------------------------\n            Serial.print(MAX_scale);\n            Serial.print(" ");\n            \n            Serial.print(min_scale);\n            Serial.print(" ");\n            //------------------------------------------------\n            Serial.print(NOISE,DEC);\n            Serial.print(" ");\n            Serial.print(Disturber,DEC);\n            Serial.print(" ");\n            Serial.print(Distance,DEC);\n            Serial.print(" ");\n            //Serial.println(Energy_LSB,DEC);\n            //Serial.print(" ");\n            Energy_MSB = Energy_MSB/20;   //JUST A SCALING FACTOR TO PLOT !\n            Serial.print(Energy_MSB,DEC);\n            Serial.print(" ");\n            Serial.print(Energy_MMSB,DEC);\n            Serial.print(" ");\n            Serial.println();\n            } \n            if (LITERAL_mode == 1)\n            {\n            //------------------------------------------------\n            //LEGIBILE FORM OF EVENT READINGS\n            //------------------------------------------------\n            Serial.println();\n            Serial.println("*****************************************************");\n            Serial.println();\n            Serial.print("Noise LEVEL detected: ");\n            Serial.println(NOISE,DEC);\n            Serial.print("Disturber detected: ");\n            Serial.println(Disturber,DEC);\n            Serial.print("Lightining detected: ");\n            Serial.println( L_struck,DEC);\n            Serial.println();\n            Serial.print("Estimated hit distance: ");\n            Serial.println(Distance,DEC);\n            Serial.print("LSB single event energy: ");\n            Serial.println(Energy_LSB,DEC);\n            Serial.print("MSB single event energy: ");\n            Serial.println(Energy_MSB,DEC);\n            Serial.print("MMSB single event energy: ");\n            Serial.println(Energy_MMSB,DEC);\n            } \n        //---------------------------------------------------------------------------------\n        //-----------------------------------------------------------\n        //CLEAN UP REGISTERS for  OLD DATA activate if required\n        //for final application\n        //-----------------------------------------------------------\n       if (false)  //replace with "true" to activate !\n        {\n        //-------------------------------------\n        //REGISTER 0X02:\n        //-------------------------------------\n         if (LITERAL_mode == 1)\n           {\n            Serial.println();\n            Serial.print("writing to REGISTER 0x02 ");\n          }\n         Wire.beginTransmission(indevice);\n         Wire.write(0x02);\n        //-------------------------------------------------\n        //bit0..3 spike rejection = 0010 (default value)  --------\x3e greater values gives more rejection\n        //                                                --------\x3e against disturbance but decreases sensitivity\n        //bit4..5 number of lightnings = 00 (default value)\n        //bit6   clear statistics = 1 (default value)\n        //BYTE = 0 100 0010 (0x42 hex)\n        //-------------------------------------------------\n        //toggle 1-0-1 to reset statistics\n        //-------------------------------------------------\n        Wire.write(REG0X02reset_startup_up);\n        Wire.endTransmission(true);\n        delay(200);\n        //--------------------------\n        Wire.write(REG0X02reset_startup_down);\n        Wire.endTransmission(true);\n        delay(200);\n        //-------------------------\n        Wire.write(REG0X02reset_startup_up);\n        Wire.endTransmission(true);\n        if (LITERAL_mode == 1)\n          {\n            Serial.println();\n            Serial.print("Done ! ");\n            Serial.println();\n          } \n        }\n        delay(200);\n        //------------------------------\n        //------------------------------\n        //------------------------------\n      }         \n     delay(1000);  // <------------- SCANNING INTERVAL .... MODIFY AS NEEDED !!!\n             \n    }\n\n  }   \n//-----------------------------------------------------------------------------\n//------------------ END OF SKETCH  -------------------------------------------\n//-----------------------------------------------------------------------------\n'))),(0,r.yg)("p",null,"If the sensor detects lightning, then you will see the following results."),(0,r.yg)("div",{style:{textAlign:"center"}},(0,r.yg)("img",{src:"https://files.seeedstudio.com/wiki/Grove-lightning-sensor/4.png",style:{width:500,height:"auto"}})),(0,r.yg)("p",null,"For testing purposes, you can use the lighter's igniter to simulate lightning to check if the sensor is working properly."),(0,r.yg)("div",{style:{textAlign:"center"}},(0,r.yg)("img",{src:"https://files.seeedstudio.com/wiki/Grove-lightning-sensor/5.jpg",style:{width:600,height:"auto"}})),(0,r.yg)("h2",{id:"resources"},"Resources"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("strong",{parentName:"li"},"[PDF]"),(0,r.yg)("a",{parentName:"li",href:"https://files.seeedstudio.com/wiki/Grove-lightning-sensor/AS3935_Datasheet_EN_v2.pdf"},"AS3935 Datasheet")),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("strong",{parentName:"li"},"[PDF]"),(0,r.yg)("a",{parentName:"li",href:"https://files.seeedstudio.com/wiki/Grove-lightning-sensor/Demo-Tuning_example.pdf"},"Demo Tuning example")),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("strong",{parentName:"li"},"[PDF]"),(0,r.yg)("a",{parentName:"li",href:"https://files.seeedstudio.com/wiki/Grove-lightning-sensor/SCHEMATIC-GROVE-AS3935-rev1.pdf"},"SCHEMATIC GROVE AS3935 rev1"))),(0,r.yg)("h2",{id:"tech-support--product-discussion"},"Tech Support & Product Discussion"),(0,r.yg)("p",null,"Thank you for choosing our products! We are here to provide you with different support to ensure that your experience with our products is as smooth as possible. We offer several communication channels to cater to different preferences and needs."),(0,r.yg)("div",{class:"button_tech_support_container"},(0,r.yg)("a",{href:"https://forum.seeedstudio.com/",class:"button_forum"}),(0,r.yg)("a",{href:"https://www.seeedstudio.com/contacts",class:"button_email"})),(0,r.yg)("div",{class:"button_tech_support_container"},(0,r.yg)("a",{href:"https://discord.gg/eWkprNDMU7",class:"button_discord"}),(0,r.yg)("a",{href:"https://github.com/Seeed-Studio/wiki-documents/discussions/69",class:"button_discussion"})))}g.isMDXComponent=!0}}]);