"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[2921],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>m});var i=n(67294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,i,a=function(e,t){if(null==e)return{};var n,i,a={},r=Object.keys(e);for(i=0;i<r.length;i++)n=r[i],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(i=0;i<r.length;i++)n=r[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var s=i.createContext({}),d=function(e){var t=i.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},p=function(e){var t=d(e.components);return i.createElement(s.Provider,{value:t},e.children)},u="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},h=i.forwardRef((function(e,t){var n=e.components,a=e.mdxType,r=e.originalType,s=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),u=d(n),h=a,m=u["".concat(s,".").concat(h)]||u[h]||c[h]||r;return n?i.createElement(m,o(o({ref:t},p),{},{components:n})):i.createElement(m,o({ref:t},p))}));function m(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var r=n.length,o=new Array(r);o[0]=h;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[u]="string"==typeof e?e:a,o[1]=l;for(var d=2;d<r;d++)o[d]=n[d];return i.createElement.apply(null,o)}return i.createElement.apply(null,n)}h.displayName="MDXCreateElement"},76941:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>o,default:()=>c,frontMatter:()=>r,metadata:()=>l,toc:()=>d});var i=n(87462),a=(n(67294),n(3905));const r={description:"Pin multiplexing and Arduino Programming tutorial",title:"Arduino Cheat Sheet",keywords:["esp32sc6","xiao","pin multiple"],image:"https://files.seeedstudio.com/wiki/SeeedStudio-XIAO-ESP32C6/img/xiaoc6.jpg",slug:"/xiao_arduino_esp33c6",sidebar_position:2,last_update:{date:"04/09/2024",author:"Spencer"}},o="Arduino Programming with Seeed Studio XIAO ESP32C6",l={unversionedId:"Sensor/SeeedStudio_XIAO/SeeedStudio_XIAO_ESP32C6/XIAO_ESP32C6_Arduino",id:"Sensor/SeeedStudio_XIAO/SeeedStudio_XIAO_ESP32C6/XIAO_ESP32C6_Arduino",title:"Arduino Cheat Sheet",description:"Pin multiplexing and Arduino Programming tutorial",source:"@site/docs/Sensor/SeeedStudio_XIAO/SeeedStudio_XIAO_ESP32C6/XIAO_ESP32C6_Arduino.md",sourceDirName:"Sensor/SeeedStudio_XIAO/SeeedStudio_XIAO_ESP32C6",slug:"/xiao_arduino_esp33c6",permalink:"/xiao_arduino_esp33c6",draft:!1,editUrl:"https://github.com/Seeed-Studio/wiki-documents/blob/docusaurus-version/docs/Sensor/SeeedStudio_XIAO/SeeedStudio_XIAO_ESP32C6/XIAO_ESP32C6_Arduino.md",tags:[],version:"current",lastUpdatedBy:"Spencer",lastUpdatedAt:1712620800,formattedLastUpdatedAt:"Apr 9, 2024",sidebarPosition:2,frontMatter:{description:"Pin multiplexing and Arduino Programming tutorial",title:"Arduino Cheat Sheet",keywords:["esp32sc6","xiao","pin multiple"],image:"https://files.seeedstudio.com/wiki/SeeedStudio-XIAO-ESP32C6/img/xiaoc6.jpg",slug:"/xiao_arduino_esp33c6",sidebar_position:2,last_update:{date:"04/09/2024",author:"Spencer"}},sidebar:"ProductSidebar",previous:{title:"Getting Started",permalink:"/xiao_esp32c6_getting_started"},next:{title:"Getting Started with Seeed Studio XIAO ESP32S3 (Sense)",permalink:"/xiao_esp32s3_getting_started"}},s={},d=[{value:"Getting Started",id:"getting-started",level:2},{value:"Pinout Overview",id:"pinout-overview",level:3},{value:"Serial",id:"serial",level:2},{value:"Hardware Preparation",id:"hardware-preparation",level:3},{value:"Code",id:"code",level:3},{value:"Software Serial",id:"software-serial",level:4},{value:"Hardware Serial",id:"hardware-serial",level:4},{value:"Digital I/O",id:"digital-io",level:2},{value:"Hardware Preparation",id:"hardware-preparation-1",level:3},{value:"Software Implementation",id:"software-implementation",level:3},{value:"Interrupt Method",id:"interrupt-method",level:4},{value:"ADC - Analog to Digital Converter",id:"adc---analog-to-digital-converter",level:2},{value:"Hardware Setup",id:"hardware-setup",level:3},{value:"Software Implementation",id:"software-implementation-1",level:3},{value:"PWM Signal / LED Control",id:"pwm-signal--led-control",level:2},{value:"Hardware Setup",id:"hardware-setup-1",level:3},{value:"Software Implementation",id:"software-implementation-2",level:3},{value:"General PWM",id:"general-pwm",level:4},{value:"LED Control",id:"led-control",level:4},{value:"I2C",id:"i2c",level:2},{value:"Hardware Preparation",id:"hardware-preparation-2",level:3},{value:"Software Implementation",id:"software-implementation-3",level:3},{value:"Master Mode",id:"master-mode",level:4},{value:"Slave Mode",id:"slave-mode",level:4},{value:"SPI",id:"spi",level:2},{value:"Hardware Preparation",id:"hardware-preparation-3",level:3},{value:"Software Implementation",id:"software-implementation-4",level:3},{value:"Wi-Fi",id:"wi-fi",level:2},{value:"Wi-Fi Scanning",id:"wi-fi-scanning",level:3},{value:"Connecting to a Wi-Fi Network",id:"connecting-to-a-wi-fi-network",level:3},{value:"State machine | Wi-Fi Events",id:"state-machine--wi-fi-events",level:3},{value:"Use ULP LP-Core Coprocessor",id:"use-ulp-lp-core-coprocessor",level:2},{value:"Resources",id:"resources",level:2}],p={toc:d},u="wrapper";function c(e){let{components:t,...n}=e;return(0,a.kt)(u,(0,i.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"arduino-programming-with-seeed-studio-xiao-esp32c6"},"Arduino Programming with Seeed Studio XIAO ESP32C6"),(0,a.kt)("div",{class:"table-center"},(0,a.kt)("table",null,(0,a.kt)("tr",null,(0,a.kt)("th",null,"Seeed Studio XIAO ESP32C6")),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("div",{style:{textAlign:"center"}},(0,a.kt)("img",{src:"https://files.seeedstudio.com/wiki/SeeedStudio-XIAO-ESP32C6/img/xiaoc6.jpg",style:{width:250,height:"auto"}})))),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("div",{class:"get_one_now_container",style:{textAlign:"center"}},(0,a.kt)("a",{class:"get_one_now_item",href:"https://www.seeedstudio.com/Seeed-Studio-XIAO-ESP32C6-p-5884.html "},(0,a.kt)("strong",null,(0,a.kt)("span",null,(0,a.kt)("font",{color:"FFFFFF",size:"4"}," Get One Now \ud83d\uddb1\ufe0f"))))))))),(0,a.kt)("p",null,"The Seeed Studio XIAO ESP32C6 is powered by the highly-integrated ",(0,a.kt)("a",{parentName:"p",href:"https://www.espressif.com/en/products/socs/esp32-c6"},"ESP32-C6 SoC"),", built on ",(0,a.kt)("strong",{parentName:"p"},"two 32-bit RISC-V processors"),", with a high-performance (HP) processor with ",(0,a.kt)("strong",{parentName:"p"},"running up to 160 MHz"),", and a low-power (LP) 32-bit RISC-V processor, which can be clocked up to 20 MHz. There are ",(0,a.kt)("strong",{parentName:"p"},"512KB SRAM and 4 MB Flash on the chip"),", allowing for more programming space, and binging more possibilities to the IoT control scenarios. "),(0,a.kt)("h2",{id:"getting-started"},"Getting Started"),(0,a.kt)("h3",{id:"pinout-overview"},"Pinout Overview"),(0,a.kt)("p",null,"Before we begin, let's review all the pins that the XIAO ESP32C6 has and its functions with the following schematic."),(0,a.kt)("table",{align:"center"},(0,a.kt)("tr",null,(0,a.kt)("th",null,"XIAO ESP32C6/XIAO ESP32C6 indication diagram")),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("div",{style:{textAlign:"center"}},(0,a.kt)("img",{src:"https://wdcdn.qpic.cn/MTY4ODg1Nzc0ODUwMjM3NA_556525_Slxs4ARdyuXRrJK-_1711096256?w=9854&h=3367&type=image/png",style:{width:700,height:"auto"}})))),(0,a.kt)("tr",null,(0,a.kt)("th",null,"XIAO ESP32C6/XIAO ESP32C6 Sense Pin List")),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("div",{style:{textAlign:"center"}},(0,a.kt)("img",{src:"https://wdcdn.qpic.cn/MTY4ODg1Nzc0ODUwMjM3NA_318648_dMoXitoaQiq2N3-a_1711678067?w=1486&h=1228",style:{width:1e3,height:"auto"}}))))),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"5V - This is 5v out from the USB port. You can also use this as a voltage input but you must have some sort of diode (schottky, signal, power) between your external power source and this pin with anode to battery, cathode to 5V pin.")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"3V3 - This is the regulated output from the onboard regulator. You can draw 700mA")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"GND - Power/data/signal ground "))),(0,a.kt)("h2",{id:"serial"},"Serial"),(0,a.kt)("p",null,"The XIAO ESP32C6 has a hardware UART for serial communication."),(0,a.kt)("h3",{id:"hardware-preparation"},"Hardware Preparation"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"Connect the ",(0,a.kt)("strong",{parentName:"li"},"TX pin")," of an ",(0,a.kt)("em",{parentName:"li"},"external device")," to the RX pin (",(0,a.kt)("inlineCode",{parentName:"li"},"D7"),") of the XIAO."),(0,a.kt)("li",{parentName:"ol"},"Connect the ",(0,a.kt)("strong",{parentName:"li"},"RX pin")," of the ",(0,a.kt)("em",{parentName:"li"},"external device")," to the TX pin (",(0,a.kt)("inlineCode",{parentName:"li"},"D6"),") of the XIAO.")),(0,a.kt)("h3",{id:"code"},"Code"),(0,a.kt)("p",null,"Here's an Arduino sketch demonstrating serial communication:"),(0,a.kt)("h4",{id:"software-serial"},"Software Serial"),(0,a.kt)("p",null,"You'll need to install ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/plerup/espsoftwareserial"},"EspSoftwareSerial")," to implement Arduino software serial."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},'#include <SoftwareSerial.h>\n\n// RX pin, TX pin\nSoftwareSerial mySerial(D7, D6);\n\nvoid setup() {\n  Serial.begin(9600);\n  mySerial.begin(9600); // Baud rate for software serial\n}\n\nvoid loop() {\n  if (mySerial.available()) {\n    char data = mySerial.read();\n    Serial.print("Received via software serial: ");\n    Serial.println(data);\n  }\n\n  if (Serial.available()) {\n    char data = Serial.read();\n    mySerial.print("Received via hardware serial: ");\n    mySerial.println(data);\n  }\n}\n')),(0,a.kt)("p",null,"In this example, software serial communication is set up on pins 2 (RX) and 3 (TX) using a baud rate of 9600. The ",(0,a.kt)("inlineCode",{parentName:"p"},"loop")," function checks for incoming data on both the hardware serial port (",(0,a.kt)("inlineCode",{parentName:"p"},"Serial"),") and the software serial port (",(0,a.kt)("inlineCode",{parentName:"p"},"mySerial"),"), and echoes back the received data to the other port."),(0,a.kt)("h4",{id:"hardware-serial"},"Hardware Serial"),(0,a.kt)("p",null,"In the Arduino framework, the UART0 peripheral, which corresponds to pins D6/D7 at the hardware level, is referred to as Serial1."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},'#define mySerial Serial1 // Alias for UART0 (Serial1)\nvoid setup() {\n  Serial.begin(9600); // Initialize hardware serial (USB)\n  mySerial.begin(9600); // Initialize UART0 (Serial1)\n}\n\nvoid loop() {\n  if (Serial.available()) { // Check if data is available on USB serial\n    char data = Serial.read();\n    Serial.print("Received on USB: ");\n    Serial.println(data);\n  }\n  \n  if (mySerial.available()) { // Check if data is available on UART0 (Serial1)\n    char data = mySerial.read();\n    Serial.print("Received on UART0: ");\n    Serial.println(data);\n  }\n}\n')),(0,a.kt)("p",null,"This code demonstrates using the hardware serial port UART0 (referred to as Serial1 in the Arduino framework) for serial communication. It initializes both the USB serial port (",(0,a.kt)("inlineCode",{parentName:"p"},"Serial"),") and the UART0 serial port (",(0,a.kt)("inlineCode",{parentName:"p"},"mySerial"),") in the setup() function."),(0,a.kt)("p",null,"In the loop() function, it checks for incoming data on both serial ports. If data is available on the USB serial port (Serial), it reads the data and prints a message indicating it was received on USB. If data is available on the UART0 serial port (",(0,a.kt)("inlineCode",{parentName:"p"},"mySerial"),"), it reads the data and prints a message indicating it was received on UART0."),(0,a.kt)("h2",{id:"digital-io"},"Digital I/O"),(0,a.kt)("p",null,"The XIAO ESP32C6 has 12 GPIO pins that you can configure as input or output."),(0,a.kt)("h3",{id:"hardware-preparation-1"},"Hardware Preparation"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"Connect an LED to pin ",(0,a.kt)("inlineCode",{parentName:"li"},"D10"),", with a current-limiting resistor in series."),(0,a.kt)("li",{parentName:"ol"},"Connect a button to pin ",(0,a.kt)("inlineCode",{parentName:"li"},"D1"),", with an external pull-up resistor (optional if using the internal pull-up resistor).")),(0,a.kt)("h3",{id:"software-implementation"},"Software Implementation"),(0,a.kt)("p",null,"The GPIO API provides functions to configure and interact with the GPIO pins. Refer to the ",(0,a.kt)("a",{parentName:"p",href:"https://docs.espressif.com/projects/arduino-esp32/en/latest/api/gpio.html"},"GPIO API")," documentation for more details."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"const int buttonPin = D1; // Button pin\nconst int ledPin = D10; // LED pin\n\nvoid setup() {\n  pinMode(ledPin, OUTPUT); // Set LED pin as output\n  pinMode(buttonPin, INPUT); // Set button pin as input\n  // If not using an external pull-up resistor\n  pinMode(buttonPin, INPUT_PULLUP); // Enable internal pull-up resistor\n}\n\nvoid loop() {\n  int buttonState = digitalRead(buttonPin); // Read button state\n  digitalWrite(ledPin, buttonState); // Write button state to LED\n}\n")),(0,a.kt)("h4",{id:"interrupt-method"},"Interrupt Method"),(0,a.kt)("p",null,"You can also use interrupts to handle button presses more efficiently."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},'// Define the pin numbers for the button and LED\nconst int buttonPin = D1;\nconst int ledPin = D10;\n\n// Define a structure to hold button-related data\nstruct Button {\n    const uint8_t PIN; // Pin number for the button\n    uint32_t numberKeyPresses; // Counter for the number of button presses\n    bool pressed; // Flag to indicate if the button is currently pressed\n};\n\n// Create an instance of the Button structure for the button\nButton my_button = {buttonPin, 0, false};\n\n// Interrupt Service Routine (ISR) to handle button presses\nvoid ARDUINO_ISR_ATTR isr(void* arg) {\n    Button* s = static_cast<Button*>(arg); // Cast the argument to a Button pointer\n    s->numberKeyPresses += 1; // Increment the number of button presses\n    s->pressed = true; // Set the pressed flag\n}\n\nvoid setup() {\n    Serial.begin(115200);\n    pinMode(my_button.PIN, INPUT_PULLUP); // Set the button pin as input with internal pull-up resistor\n    attachInterruptArg(my_button.PIN, isr, &my_button, FALLING); // Attach the ISR to the button pin, triggered on falling edge\n}\n\nvoid loop() {\n    if (my_button.pressed) { // Check if the button is pressed\n        Serial.printf("Button 1 has been pressed %lu times\\n", my_button.numberKeyPresses); // Print the number of button presses\n        my_button.pressed = false; // Reset the pressed flag\n    }\n\n    static uint32_t lastMillis = 0; // Variable to store the last time the interrupt was detached\n    if (millis() - lastMillis > 10000) { // Check if 10 seconds have elapsed\n        lastMillis = millis(); // Update the last detach time\n        detachInterrupt(my_button.PIN); // Detach the interrupt from the button pin\n    }\n}\n')),(0,a.kt)("p",null,"In this example, we use a ",(0,a.kt)("inlineCode",{parentName:"p"},"Button")," structure to hold the button-related data, including the pin number, the number of key presses, and a flag to indicate if the button is currently pressed."),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"isr")," function is an Interrupt Service Routine (ISR) that handles button presses. It increments the number of button presses and sets the pressed flag to true."),(0,a.kt)("p",null,"In the ",(0,a.kt)("inlineCode",{parentName:"p"},"setup")," function, we initialize the serial communication, set the button pin as an input with an internal pull-up resistor, and attach the ",(0,a.kt)("inlineCode",{parentName:"p"},"isr")," function to the button pin as an interrupt handler triggered on a falling edge (button press)."),(0,a.kt)("p",null,"In the ",(0,a.kt)("inlineCode",{parentName:"p"},"loop")," function, we check if the button is pressed. If it is, we print the number of button presses to the serial monitor and reset the pressed flag. Additionally, we include a section that detaches the interrupt from the button pin every 10 seconds, presumably to allow for other operations or to prevent unintended interrupts.\nOkay, got it. Here is the rewritten and more comprehensible version:"),(0,a.kt)("h2",{id:"adc---analog-to-digital-converter"},"ADC - Analog to Digital Converter"),(0,a.kt)("p",null,"The XIAO ESP32C6 has several analog input pins that allow reading analog voltages."),(0,a.kt)("p",null,"Refer to the ",(0,a.kt)("a",{parentName:"p",href:"https://docs.espressif.com/projects/arduino-esp32/en/latest/api/adc.html"},"ADC API")," documentation for more details."),(0,a.kt)("h3",{id:"hardware-setup"},"Hardware Setup"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"Connect a potentiometer to pin A0, with one end connected to 3.3V and the other to GND.")),(0,a.kt)("h3",{id:"software-implementation-1"},"Software Implementation"),(0,a.kt)("p",null,"Here's an Arduino sketch that reads an analog value:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},'const int analogPin = A0; \n\nvoid setup() {\n  // Initialize serial communication at 115200 bits per second\n  Serial.begin(115200);\n  \n  // Set the resolution to 12 bits (0-4095)\n  analogReadResolution(12);\n}\n\nvoid loop() {\n  // Read the analog value and millivolts for the analogPin\n  int analogValue = analogRead(analogPin);\n  int analogVolts = analogReadMilliVolts(analogPin);\n  \n  // Print the values to the Serial Monitor\n  Serial.printf("ADC analog value = %d\\n", analogValue);\n  Serial.printf("ADC millivolts value = %d\\n", analogVolts);\n  \n  delay(100); // Delay for clear reading from serial\n}\n')),(0,a.kt)("p",null,"This code reads the analog value from the specified pin and prints it, along with the millivolt value, to the Serial Monitor."),(0,a.kt)("h2",{id:"pwm-signal--led-control"},"PWM Signal / LED Control"),(0,a.kt)("p",null,"The XIAO  ESP32-C6 has 6 LEDC channels that can generate independent waveforms, which can be used, for example, to drive RGB LED devices."),(0,a.kt)("p",null,"Refer to the ",(0,a.kt)("a",{parentName:"p",href:"https://docs.espressif.com/projects/arduino-esp32/en/latest/api/ledc.html"},"LEDC API")," documentation for more details."),(0,a.kt)("h3",{id:"hardware-setup-1"},"Hardware Setup"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"Connect an LED to pin ",(0,a.kt)("inlineCode",{parentName:"li"},"D2")," with a current-limiting resistor in series.")),(0,a.kt)("h3",{id:"software-implementation-2"},"Software Implementation"),(0,a.kt)("p",null,"Here are Arduino sketches that demonstrate PWM output:"),(0,a.kt)("h4",{id:"general-pwm"},"General PWM"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"const int ledPin = D2;\n\nvoid setup() {\n  pinMode(ledPin, OUTPUT);\n}\n\nvoid loop() {\n  for (int dutyCycle = 0; dutyCycle <= 255; dutyCycle++) {\n    analogWrite(ledPin, dutyCycle);\n    delay(10);\n  }\n}\n")),(0,a.kt)("p",null,"This code gradually increases the LED brightness using PWM."),(0,a.kt)("h4",{id:"led-control"},"LED Control"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"/*\n LEDC Software Fade\n\n This example shows how to software fade an LED\n using the ledcWrite function.\n\n Code adapted from the original Arduino Fade example:\n https://www.arduino.cc/en/Tutorial/Fade\n\n This example code is in the public domain.\n */\n\n// Use 12-bit precision for the LEDC timer\n#define LEDC_TIMER_12_BIT  12\n\n// Use 5000 Hz as the LEDC base frequency\n#define LEDC_BASE_FREQ     5000\n\n// Fade LED PIN (replace with LED_BUILTIN constant for the built-in LED)\n#define LED_PIN            D5\n\nint brightness = 0;    // How bright the LED is\nint fadeAmount = 5;    // How many points to fade the LED by\n\n// Arduino-like analogWrite\n// Value has to be between 0 and valueMax\nvoid ledcAnalogWrite(uint8_t pin, uint32_t value, uint32_t valueMax = 255) {\n  // Calculate duty, 4095 from 2 ^ 12 - 1\n  uint32_t duty = (4095 / valueMax) * min(value, valueMax);\n\n  // Write duty to LEDC\n  ledcWrite(pin, duty);\n}\n\nvoid setup() {\n  // Setup timer and attach timer to the LED pin\n  ledcAttach(LED_PIN, LEDC_BASE_FREQ, LEDC_TIMER_12_BIT);\n}\n\nvoid loop() {\n  // Set the brightness on the LEDC channel\n  ledcAnalogWrite(LED_PIN, brightness);\n\n  // Change the brightness for the next loop iteration\n  brightness = brightness + fadeAmount;\n\n  // Reverse the direction of the fading at the ends of the fade\n  if (brightness <= 0 || brightness >= 255) {\n    fadeAmount = -fadeAmount;\n  }\n  // Wait for 30 milliseconds to see the dimming effect\n  delay(30);\n}\n")),(0,a.kt)("p",null,"This code demonstrates how to fade an LED using the ledcWrite function. The LED brightness gradually increases and decreases in a continuous loop."),(0,a.kt)("h2",{id:"i2c"},"I2C"),(0,a.kt)("p",null,"The XIAO ESP32C6 has a hardware I2C interface for communicating with I2C devices."),(0,a.kt)("p",null,"Refer to the ",(0,a.kt)("a",{parentName:"p",href:"https://docs.espressif.com/projects/arduino-esp32/en/latest/api/i2c.html"},"I2C API")," documentation for more details."),(0,a.kt)("h3",{id:"hardware-preparation-2"},"Hardware Preparation"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"Connect the SDA pin of the I2C device to the SDA pin (",(0,a.kt)("inlineCode",{parentName:"li"},"D4"),") of the XIAO."),(0,a.kt)("li",{parentName:"ol"},"Connect the SCL pin of the I2C device to the SCL pin (",(0,a.kt)("inlineCode",{parentName:"li"},"D5"),") of the XIAO.")),(0,a.kt)("h3",{id:"software-implementation-3"},"Software Implementation"),(0,a.kt)("h4",{id:"master-mode"},"Master Mode"),(0,a.kt)("p",null,"Here's an Arduino sketch that demonstrates reading from an I2C sensor:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"#include <Wire.h>\n\nconst int sensorAddress = 0x40;\n\nvoid setup() {\n  Wire.begin();\n  Serial.begin(115200);\n}\n\nvoid loop() {\n  Wire.beginTransmission(sensorAddress);\n  Wire.write(0x01);  // Register address\n  Wire.endTransmission();\n\n  Wire.requestFrom(sensorAddress, 2);\n  if (Wire.available() >= 2) {\n    int data = Wire.read() << 8 | Wire.read();\n    Serial.println(data);\n  }\n\n  delay(100);\n}\n")),(0,a.kt)("p",null,"This code reads a 16-bit value from register ",(0,a.kt)("inlineCode",{parentName:"p"},"0x01")," of an I2C sensor."),(0,a.kt)("h4",{id:"slave-mode"},"Slave Mode"),(0,a.kt)("p",null,"Here's an Arduino sketch that demonstrates using the XIAO ESP32C6 as an I2C ",(0,a.kt)("em",{parentName:"p"},"slave device"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},'#include "Wire.h"\n\n#define I2C_DEV_ADDR 0x55\n\nuint32_t i = 0;\n\nvoid onRequest() {\n  Wire.print(i++);\n  Wire.print(" Packets.");\n  Serial.println("onRequest");\n}\n\nvoid onReceive(int len) {\n  Serial.printf("onReceive[%d]: ", len);\n  while (Wire.available()) {\n    Serial.write(Wire.read());\n  }\n  Serial.println();\n}\n\nvoid setup() {\n  Serial.begin(115200);\n  Serial.setDebugOutput(true);\n  Wire.onReceive(onReceive);\n  Wire.onRequest(onRequest);\n  Wire.begin((uint8_t)I2C_DEV_ADDR);\n\n#if CONFIG_IDF_TARGET_ESP32\n  char message[64];\n  snprintf(message, 64, "%lu Packets.", i++);\n  Wire.slaveWrite((uint8_t *)message, strlen(message));\n#endif\n}\n\nvoid loop() {\n  // Slave device code here\n}\n')),(0,a.kt)("p",null,"In this slave mode example, the XIAO ESP32C6 is configured as an I2C slave device with address ",(0,a.kt)("inlineCode",{parentName:"p"},"0x55"),". The ",(0,a.kt)("inlineCode",{parentName:"p"},"onReceive")," callback function is called when the slave receives data from the master, and the ",(0,a.kt)("inlineCode",{parentName:"p"},"onRequest")," callback function is called when the master requests data from the slave."),(0,a.kt)("h2",{id:"spi"},"SPI"),(0,a.kt)("p",null,"The XIAO ESP32C6 microcontroller board features a built-in SPI interface, facilitating fast data exchange with other SPI-compatible devices. This is particularly useful in projects that require quick communication between multiple devices."),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"For detailed technical specifications, refer to the ",(0,a.kt)("a",{parentName:"li",href:"https://www.espressif.com/sites/default/files/documentation/esp32-c6_datasheet_en.pdf"},"XIAO ESP32C6 Datasheet"),"."),(0,a.kt)("li",{parentName:"ul"},"Learn more about how to use the SPI interface with the XIAO ESP32C6 by consulting the ",(0,a.kt)("a",{parentName:"li",href:"https://docs.espressif.com/projects/arduino-esp32/en/latest/api/spi.html#"},"SPI API Documentation"),".")),(0,a.kt)("h3",{id:"hardware-preparation-3"},"Hardware Preparation"),(0,a.kt)("p",null,"To connect your XIAO ESP32C6 to another SPI device, follow these steps:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("strong",{parentName:"li"},"MOSI (Master Out Slave In):")," Connect the ",(0,a.kt)("inlineCode",{parentName:"li"},"MOSI")," pin of the SPI device to pin ",(0,a.kt)("inlineCode",{parentName:"li"},"D10")," on the XIAO."),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("strong",{parentName:"li"},"MISO (Master In Slave Out):")," Connect the ",(0,a.kt)("inlineCode",{parentName:"li"},"MISO")," pin of the SPI device to pin ",(0,a.kt)("inlineCode",{parentName:"li"},"D9")," on the XIAO."),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("strong",{parentName:"li"},"SCK (Serial Clock):")," Connect the ",(0,a.kt)("inlineCode",{parentName:"li"},"SCK")," pin of the SPI device to pin ",(0,a.kt)("inlineCode",{parentName:"li"},"D8")," on the XIAO."),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("strong",{parentName:"li"},"CS (Chip Select):")," Connect the ",(0,a.kt)("inlineCode",{parentName:"li"},"CS")," pin of the SPI device to a digital pin (for example, ",(0,a.kt)("inlineCode",{parentName:"li"},"D3"),") on the XIAO.")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"MOSI -> D10\nMISO -> D9\nSCK -> D8\nCS -> D3 (as an example)\n")),(0,a.kt)("h3",{id:"software-implementation-4"},"Software Implementation"),(0,a.kt)("p",null,"Below is a simplified Arduino sketch that demonstrates basic SPI communication with an SPI device using the XIAO ESP32C6. This sketch sends a command to the SPI device and reads back the response."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"#include <SPI.h>\n\nconst int csPin = 3;  // Use pin D3 for Chip Select (CS)\n\nvoid setup() {\n  // Initialize SPI communication\n  SPI.begin();            \n  // Set the CS pin as an output\n  pinMode(csPin, OUTPUT); \n  // Set the CS pin high to indicate no active communication\n  digitalWrite(csPin, HIGH);\n}\n\nvoid loop() {\n  // Start communication with the device\n  digitalWrite(csPin, LOW);\n  SPI.transfer(0x01);  // Send a command to the device\n  int data = SPI.transfer(0);  // Read the response\n  digitalWrite(csPin, HIGH);  // End communication\n\n  // Print the received data\n  Serial.println(data);       \n  delay(100);  // Wait for a short period\n}\n")),(0,a.kt)("p",null,"Note: Ensure the pin assignments in your sketch match the physical connections in your hardware setup. The above example uses predefined pin numbers based on the ",(0,a.kt)("inlineCode",{parentName:"p"},"pin_arduino.h")," file for the XIAO ESP32-C6, with an additional definition for the CS pin."),(0,a.kt)("p",null,"This code sends a command and reads back data from an SPI device."),(0,a.kt)("p",null,"Here's the completed section of the Arduino code example:"),(0,a.kt)("h2",{id:"wi-fi"},"Wi-Fi"),(0,a.kt)("p",null,"Refer to the ",(0,a.kt)("a",{parentName:"p",href:"https://docs.espressif.com/projects/arduino-esp32/en/latest/api/wifi.html"},"Wi-Fi API")," documentation for more details."),(0,a.kt)("h3",{id:"wi-fi-scanning"},"Wi-Fi Scanning"),(0,a.kt)("p",null,"You can scan for available Wi-Fi networks using the ",(0,a.kt)("inlineCode",{parentName:"p"},"WiFi.scanNetworks()")," function. Here's an example:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},'#include <WiFi.h>\n\nvoid setup() {\n  Serial.begin(115200);\n  \n  // Set WiFi to station mode and disconnect from an AP if it was previously connected\n  WiFi.mode(WIFI_STA);\n  WiFi.disconnect();\n  delay(100);\n\n  Serial.println("Setup done");\n}\n\nvoid loop() {\n  Serial.println("Starting Wi-Fi scan...");\n\n  // WiFi.scanNetworks will return the number of networks found\n  int numNetworks = WiFi.scanNetworks();\n  Serial.println("Scan done");\n\n  if (numNetworks == 0) {\n    Serial.println("No networks found");\n  } else {\n    Serial.print(numNetworks);\n    Serial.println(" networks found");\n    for (int i = 0; i < numNetworks; i++) {\n      // Print SSID and RSSI for each network found\n      Serial.print(i + 1);\n      Serial.print(": ");\n      Serial.print(WiFi.SSID(i));\n      Serial.print(" (");\n      Serial.print(WiFi.RSSI(i));\n      Serial.print(")");\n      Serial.println((WiFi.encryptionType(i) == WIFI_AUTH_OPEN) ? " " : "*");\n      delay(10);\n    }\n  }\n  Serial.println("");\n\n  // Wait a bit before scanning again\n  delay(5000);\n}\n')),(0,a.kt)("p",null,"This code scans for available networks, prints the number of networks found, and then lists the SSID, signal strength (RSSI), and encryption type (open or secured) for each network."),(0,a.kt)("h3",{id:"connecting-to-a-wi-fi-network"},"Connecting to a Wi-Fi Network"),(0,a.kt)("p",null,"To connect to a Wi-Fi network, you can use the ",(0,a.kt)("inlineCode",{parentName:"p"},"WiFi.begin()")," function. Here's an example:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},'#include <WiFi.h>\n\nconst char* ssid = "your_SSID";\nconst char* password = "your_PASSWORD";\n\nvoid setup() {\n  Serial.begin(115200);\n  \n  // Set WiFi to station mode\n  WiFi.mode(WIFI_STA);\n  \n  // Connect to the Wi-Fi network\n  WiFi.begin(ssid, password);\n  \n  Serial.print("Connecting to ");\n  Serial.println(ssid);\n  \n  while (WiFi.status() != WL_CONNECTED) {\n    delay(500);\n    Serial.print(".");\n  }\n  \n  Serial.println("");\n  Serial.println("WiFi connected");\n  Serial.println("IP address: ");\n  Serial.println(WiFi.localIP());\n}\n\nvoid loop() {\n  // Your code here\n}\n')),(0,a.kt)("p",null,"Replace ",(0,a.kt)("inlineCode",{parentName:"p"},"your_SSID")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"your_PASSWORD")," with the actual SSID and password of the Wi-Fi network you want to connect to. The code will attempt to connect to the network and wait until the connection is established. Once connected, it will print the assigned IP address."),(0,a.kt)("h3",{id:"state-machine--wi-fi-events"},"State machine | Wi-Fi Events"),(0,a.kt)("p",null,"You can use the ",(0,a.kt)("inlineCode",{parentName:"p"},"WiFi.onEvent()")," function to register callbacks for various Wi-Fi events. Here's an example:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},'#include <WiFi.h>\n\nconst char* ssid = "your_SSID";\nconst char* password = "your_PASSWORD";\n\nvoid WiFiEvent(WiFiEvent_t event) {\n  switch (event) {\n    case ARDUINO_EVENT_WIFI_STA_START:\n      Serial.println("Station Mode Started");\n      break;\n    case ARDUINO_EVENT_WIFI_STA_CONNECTED:\n      Serial.println("Connected to AP");\n      break;\n    case ARDUINO_EVENT_WIFI_STA_GOT_IP:\n      Serial.print("Got IP: ");\n      Serial.println(WiFi.localIP());\n      break;\n    case ARDUINO_EVENT_WIFI_STA_DISCONNECTED:\n      Serial.println("Disconnected from AP");\n      // Reconnect to Wi-Fi\n      WiFi.reconnect();\n      break;\n    default:\n      break;\n  }\n}\n\nvoid setup() {\n  Serial.begin(115200);\n  \n  // Register the Wi-Fi event handler\n  WiFi.onEvent(WiFiEvent);\n  \n  // Set WiFi to station mode\n  WiFi.mode(WIFI_STA);\n  \n  // Connect to the Wi-Fi network\n  WiFi.begin(ssid, password);\n  \n  Serial.print("Connecting to ");\n  Serial.println(ssid);\n}\n\nvoid loop() {\n  // Your code here\n}\n')),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},"Remember to replace ",(0,a.kt)("inlineCode",{parentName:"p"},"your_SSID")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"your_PASSWORD")," with the actual SSID and password of your Wi-Fi network.")),(0,a.kt)("p",null,"This code registers a callback function ",(0,a.kt)("inlineCode",{parentName:"p"},"WiFiEvent")," that will be called whenever a Wi-Fi event occurs. The callback function uses a switch statement to handle different event types, such as station mode started, connected to AP, got IP address, and disconnected from AP. You can add your own logic inside each case to perform specific actions based on the event."),(0,a.kt)("h2",{id:"use-ulp-lp-core-coprocessor"},"Use ULP LP-Core Coprocessor"),(0,a.kt)("p",null,"Stay tuned:  "),(0,a.kt)("h2",{id:"resources"},"Resources"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://wiki.seeedstudio.com/xiao_esp32c6_getting_started/"},"XIAO ESP32C6 Documentation")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://www.espressif.com/sites/default/files/documentation/esp32-c6_datasheet_en.pdf"},"ESP32-C6 Datasheet")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://www.arduino.cc/reference/en/"},"Arduino Reference")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://docs.espressif.com/projects/arduino-esp32/en/latest/index.html"},"Arduino ESP32 Reference"))))}c.isMDXComponent=!0}}]);